# 5. Selection Statements

 C는 그 수많은 연산자들에 비해 구문은 매우 적다. 지금까지 다룬 구문은 딱 두 가지다. `return`문과 표현문이다. C의 구문은 크게 세 가지로 나뉘는데, 그 기준은 그 구문이 구문들을 실행할 때의 순서에 어떤 영향을 미치는가이다.

- **선택문selection statements**. `if`문과 `switch`문은 프로그램이 여러 방법 중 특정한 방법을 실행시킨다.
- **반복문iteration statements**. `while`문, `do`문, 그리고 `for`문은 반복(루프)를 가능케 해준다.
- **도약문jump statements**. `break`문, `continue`문, 그리고 `goto`문은 프로그램이 조건없이 특정한 지점으로 가게 만든다. `return`문 또한 이 유형에 속한다.

이것 외에는 `복합문`과 `null문`이 있다. 복합문이란 여러 개의 구문을 하나의 구문으로 만들어주는 구문이다. null문이란 아무 행동을 하지 않는 구문이다.

본 단원에서는 선택문과 복합문을 다룬다. 6단원에서 반복문과 도약문, 그리고 null문을 다룬다. `if`문을 다루기 이전 우선 `if`가 검사할 수 있는 조건인 논리표현식을 배울 것이다. 5.1단원에서 논리표현식을 구성하는 관계연산자(`<`, `<=`, `>`, `>=`), 동등연산자(`==` , `!=`), 그리고 논리연산자(`&&`, `||`, `!`)를 다룬다. 5.2단원에선 `if`문과 복합문을 다루고, 표현식 내에서 조건을 검사하게 만들어주는 조건연산자(`?:`)를 다룬다. 5.3단원에선 `switch`문을 다룬다.

### 5.1 논리표현식

`if`처럼 C언어의 몇가지 구문들은 표현식의 값이 "참"인지 "거짓"인지 반드시 확인해야한다. 예를 들어 만약 `if`문이 `i < j`와 같은 표현식을 평가해야한다고 하자. 이 표현식의 값이 참이라면 `i`가 `j`보다 값이 작다는 것을 의미한다. 많은 프로그래밍 언어에선 `i < j`와 같은 표현식은 "불리언"이나 "논리"라는 특수한 타입을 띨 것이다. 이러한 타입은 참과 거짓을 유일한 값으로 갖는다. C에서는 이와는 다르게 `i < j`와 같은 비교식의 결과값은 1 혹은 0인 정수다. 1이면 참을 의미하고, 0은 거짓을 의미한다. 이 기본을 바탕으로 논리식을 구성하는 연산자들을 살펴보도록 하자.

#### 관계 연산자

C에서 사용되는 **관계연산자relational operator**(표 5.1)는 수학에서 사용되는 <, >, ≤, ≥와 기본적으로 동일하지만, 표현식에서 사용되었을 때 결과값으로 0 또는 1이 나온다. `10 < 11`의 값은 1이고, `11 < 10`의 값은 0이다.

| 기호 | 의미                           |
| :--- | :----------------------------- |
| `<`  | (왼쪽이 오른쪽보다) 작다; 미만 |
| `>`  | 크다; 초과                     |
| `<=` | 작거나 같다; 이하              |
| `>=` | 크거나 같다; 이상              |

표 5.1: 관계 연산자

관계연산자는 정수와 고정소수를 비교하는데 사용할 수 있으며, 둘을 섞어서 사용해도 된다. 즉, `1 < 2.5`의 값은 1이고, `5.6 < 4`의 값은 0이다.

관계연산자의 평가순서는 산술연산자보다 낮다. 그렇기 때문에 `i + j < k - 1`은 `(i + j) < (k - 1)`과도 같다. 관계연산자는 좌향결합적이다.

> **[!!!]**
>
> C언에서 `i < j < k`와 같은 표현식은 구문상 문제될 것은 없다. 다만 실제로 평가했을 때 우리가 의도했던 의미와는 다른 결과가 나온다. **`<` 연산자가 좌향결합적**이기 때문에 위의 표현식은 다음과 같다.
>
> ```
> (i < j) < k
> ```
>
> 즉, 이 표현식은 우선 `i`가 `j`보다 작은지 평가한다. 그렇게 되면 이 표현식은 `k`가 0 또는 1보다 큰지를 평가하는 식이 된다. 그렇기 때문에 `j`가 `i`보다 크고 `k`보다는 작다는 것을 위와 같이 표현해줄 수 없다. (추후에 배울 개념을 사용한다면, 올바른 식은 `i < j && j < k`이다.)

#### 동등 연산자

관계연산자는 `<`, `>`와 같이 다른 프로그래밍 언어에서 흔히 사용하는 기호를 그대로 사용한다. 허나 **동등연산자equality operator**는 좀 특수한 기호(표 5.2)를 사용한다. "같다"를 의미하는 연산자는 우리가 흔히 사용하는 `=` 기호를 하나로 사용할 수 없다. `=` 기호 하나를 사용하는 연산자는 할당연산자이기 때문에 동등연산은 한 개가 아니라 두 개 붙여서 사용한다. "같지 않음"을 나타내는 연산자는 `!`와 `=`를 붙여서 사용한다.

| 기호 | 의미                   |
| :--- | :--------------------- |
| `==` | (왼쪽이 오른쪽과) 같다 |
| `!=` | 같지 않다              |

표 5.2: 동등 연산자

관계연산자처럼 동등연산자들도 좌향결합적이며 결과값으로 0 또는 1을 낸다. 다만, 동등연산자는 관계연산자보다 평가순서가 낮다. 즉, 표현식

```
i < j == j < k
```

은 다음과 같다.

```
(i < j) == (j < k)
```

`i < j`와 `j < k` 둘이 동시에 참이거나 거짓이라면 위의 표현식은 참이다.

몇몇 똑똑한 프로그래머들은 관계연산자와 동등연산자가 정수값을 반환한다는 점에서 착안해서 다양한 표현식을 만들어낸다. 예를 들어 표현식 `(i >= j) + (i == j)`은 `i`가 `j`보다 작거나, 크거나, 같느냐에 따라 순서대로 0, 1이거나 2를 값으로 갖는다. 이런 복잡한 코드는 일반적으로 좋은 생각은 아닐 뿐더러 프로그램의 가독성을 떨어뜨린다.

#### 논리 연산자

수많은 복잡한 논리식들은 아이러니하게도 가장 간단한 연산자 중 하나인 **논리연산자logical operator**에 의해 탄생된다. 논리연산자(표 5.3)은 and, or, 그리고 not으로 구성된다. `!` 연산자는 단항이고, `&&`와 `||` 연산자는 이항이다.

| 기호 | 의미   |
| :--- | :----- |
| `!`  | 부정   |
| `&&` | 논리곱 |
| `||` | 논리합 |

표 5.3: 논리 연산자

논리연산자는 결과값으로 0 또는 1을 반환한다. 피연산자들은 주로 0이나 1의 값을 갖지만, 필수는 아니다. 논리연산자는 0이 아닌 피연산자를 참으로, 0인 피연산자를 거짓으로 취급한다.

논리연산자는 다음과 같이 행동한다.

- `!expr`: `expr`의 값이 0이라면 1이다.
- `expr1 && expr2`: `expr1`과 `expr2`가 둘 다 0이 아닌 값이면 1이다.
- `expr1 || expr2`: `expr1` 혹은 `expr2`, 혹은 둘 다 0이 아닌 값이면 1이다.

위에 언급하지 않은 경우엔 전부 0을 값으로 갖는다.

`&&`과 `||`은 피연산자를 평가할 때 단락방식으로 평가한다. 다시 말해 왼쪽 피연산자를 우선 평가한 다음 오른쪽 피연산자들 평가한다는 뜻이다. 만약 전체 표현식의 값이 왼쪽 피연산자 하나로 결정날 수 있다면, 오른쪽 피연산자는 평가하지 않는다. 예시로 직접 보자.

```c++
(i != 0) && (j / i > 0)
```

이 표현식의 값을 알려면 우선 왼쪽 피연산자인 `(i != 0)`을 평가해야한다. `i`가 0과 같지 않다면 `(j / i > 0)`을 평가해서 전체 표현식이 참인지 거짓인지 판별해야한다. 하지만 만약 `i`가 0이라면 전체 표현식은 거짓이므로 오른쪽 피연산자인 `(j / i > 0)`을 평가할 필요가 없다. 단락식 평가는 여러모로 유용하다. 만약 단락식 평가가 아니었다면 위의 표현식에서 오른쪽 피연산자에서는 값을 0으로 나누는 에러가 발생했을 것이다.

> **[!!!]**
>
> 논리표현식을 잘못 사용하면 부작용이 발생할 수도 있다. 다행히도 `&&`과 `||`은 단락성을 가지므로 피연산자에서 발생하는 부작용을 피할 수 있다. 다음 표현식을 예로 들겠다.
>
> ```
> i > 0 && ++j > 0
> ```
>
> 표현식을 평가할 때의 부작용으로 `j`는 증가되겠지만, 여기선 부작용이 발생하지 않는다. 만약 `i > 0`이 거짓이라면 `++j > 0`은 평가되지 않기에 **`j`는 증가되지 않는다.** 만약 무조건 증가시키고 싶다면 피연산자의 순서를 바꾸어 `++j > 0 && i > 0`로 표현식을 변경하면 된다. 물론, 아예 `j`를 따로 증가시키는게 더 좋은 방법이다.

**`!` 연산자는 단항 덧셈/뺄셈과 같은 순서**를 갖는다. `&&`과 `||`의 순서는 관계연산자와 동등연산자보다 낮다. `i < j && k == m`은 `(i < j) && (k == m)`을 의미한다. `!` 연산자는 우향결합적이고 `&&`과 `||`은 좌향결합적이다.

### 2 if문

`if`문은 프로그램이 표현식의 값을 사용하여 두 가지 선택지 중 하나를 고르게 만든다. `if`문을 간단하게 표현하면 다음과 같다.

```c
if  (  expression  )  statement
```

여기서 기억해야하는 점은 표현식을 감싸고 있는 괄호는 필수라는 점이다. 괄호는 표현식의 일부분이 아니라 `if`문의 일부분이다. 구어체에선 흔히 if ~ then처럼 말하기에 다른 프로그래밍 언어들도 `then`을 `if`문에 포함시키기도 하는데, C언어에서는 괄호 뒤에 `then`이 오지 않는다.

`if`문이 실행되면 괄호 안의 표현식이 평가된다. 만약 표현식의 값이 0이 아니라면, 즉 참이라면 괄호 뒤의 구문이 실행된다. 다음 예시를 보도록 하자.

```
if (line_num == MAX_LINES)
    line_num = 0;
```

구문 `line_num = 0;`은 조건 `line_num == MAX_LINES`이 0이 아닌 값을 가질 때, 즉 참일 때만 실행된다.

> **[!!!]**
>
> `==`(동등)과 `=`(할당)을 절대로 혼동해서는 안된다.
>
> `if (i == 0) ...` `if (i = 0) ...`
>
> 위 구문은 `i`가 0과 같은지를 판별하지만, 아래 구문은 `i`에 0을 할당한 다음, 그 결과값이 0이 아닌 값인지를 판별한다. 즉, 이 경우 거짓이 반환된다.
>
> `==`과 `=`을 헷갈려하는 것은 C언어로 코딩할 때 자주하는 실수이다. 사람들은 수학시간에 =를 "~와 같다"라는 의미로 사용해 왔고, 실제로 몇몇 프로그래밍 언어에서는 =를 같다라는 의미로 사용한다. 몇몇 컴파일러는 `==`이 와야하는 자리에 `=`이 오면 경고메세지를 내보내기도 한다. **[Q & A]**

어떤 변수가 특정 구간에 포함되는지를 판별할 때 `if`문을 자주 사용한다. 0≤`i`<`n`을 판별한다고 할 때, 프로그래머들은 다음과 같이 주로 코딩한다.

**[관용구]** `if (0 <= i && i < n) ...`

이 반대 조건의 경우, 즉 `i`가 위의 범위 밖임을 판별하려면 다음과 같이 나타낸다.

**[관용구]** `if (i < 0 || i >= n) ...`

`&&` 연산자가 아닌 `||` 연산자가 쓰였다는 부분에 주목할 필요가 있다.

#### 복합문

위에서 다룬 간단한 `if`문의 구조를 다시 살펴보면 뒤에 나오는 구문이 구문"들"이 아니라 구문 하나이다.

```c
if  (  expression  )  statement
```

만약 `if`문이 여러 구문을 제어하게 만들고 싶다면 어떻게 해야할까? 이럴 때 사용하는 구문이 바로 **복합문compound statement**이다. 복합문은 다음과 같은 구조를 갖고 있다.

```c
{  statements  }
```

여러 개의 구문을 중괄호로 감싸면 컴파일러는 이를 하나의 구문으로 취급한다.

복합문이 어떻게 생겼는지 예시로 살펴보자.

```c
{ line_num = 0; page_num++; }
```

사실 이렇게 한 줄에 전부 사용하지는 않는다. 가독성을 위해 복합문을 구문 당 한 줄을 사용해 여러 줄에 걸쳐 사용한다.

```c
{
    line_num = 0;
    page_num++;
}
```

복합문 내에 있는 구문이라고 하더라도 반드시 세미콜론으로 끝나야한다. 다만, 복합문 자체는 세미콜론으로 끝나지 않는다.

복합문이 `if`에 사용할 땐 다음과 같이 사용한다.

```c
if (line_num == MAX_LINES) {
    line_num = 0;
    page_num++;
}
```

복합문은 루프문과 같이 구조상 구문 한 개만 사용해야하지만 실제로는 여러 구문이 필요할 때 자주 사용된다.

#### else 절

`if`문은 `else`문을 포함할 수 있다.

```c
if (  expresssion  ) statement else statement
```

`else` 뒤에 나오는 구문은 괄호 안의 표현식의 값이 0일 때 실행된다.

`else`문 예제 하나를 살펴보자.

```c
if (i > j)
    max = i;
else
    max = j;
```

안쪽 구문은 둘 다 세미콜론으로 끝난다.

`if`문이 `else`문을 포함할 때 가독성의 문제가 발생한다. `else`문을 어디에 위치시켜야 보기 좋은가? 많은 C 프로그래머들은 위의 예시처럼 `if`와 같은 위치에 표기한다. 안쪽 구문들은 `if`나 `else`와 같은 줄에 써도 될만큼 짧지 않은 이상 주로 들여쓴다.

```c
if (i > j) max = i;
else max = j;
```

`if`문 안에 어떤 구문이 와서는 안되는 것과 같은 규칙은 없다. 즉, `if`문 안에는 아무 구문이나 와도 되고, `if`문 안에 `if`문을 넣을 수도 있을 뿐더러 실생활에서 자주 사용한다. 다음 `if`문 예제를 확인해보자. 다음 코드에선 `i`, `j`, `k` 중 가장 큰 값을 찾아내어 `max`에 그 값을 저장한다.

```c
if (i > j)
    if (i > k)
        max = i;
    else
        max = k;
else
    if (j > k)
        max = j;
    else
        max = k;
```

`if`문은 얼마든지 중복시킬 수 있다. `if`문을 중복시킬 때 `else`문을 해당 `if`문과 같은 줄에 위치시키면 위와 같이 가독성이 훨씬 높아진다. 위와 같은 중복이 그래도 보기 불편하면, 중괄호를 사용하면 된다.

```c
if (i > j) {
    if (i > k)
        max = i;
    else
        max = k;
}   else {
    if (j > k)
        max = j;
    else
        max = k;
}
```

굳이 중괄호를 사용하지 않아도 될 때에도 굳이 사용해주는 것은 마치 표현식에서 괄호를 사용하는 것과 같다. 프로그램의 가독성을 늘려줄 뿐만 아니라 컴파일러가 프로그래머의 의도를 잘못 해석하여 에러가 생길 가능성을 줄여준다.

몇몇 프로그래머들은 모든 `if`문(사실 `if`문 뿐만 아니라 모든 반복문도 해당된다)에 최대한 많은 중괄호를 사용해준다. 즉, `if`문의 구문들, `else`문의 구문들을 전부 중괄호로 묶어준다.

```c
if (i > j) {
    if (i > k) {
        max = i;
    }   else {
        max = k;
    }
}   else {
    if (j > k) {
        max = j;
    }   else {
        max = k;
    }
}
```

굳이 중괄호를 사용하는 것은 두 가지 장점이 있다. 우선 `if`문이나 `else`문의 구문에 손쉽게 다른 구문들을 추가할 수 있다. 즉, 프로그램의 수정이 매우 용이하다. 두번째는 `if`문이나 `else`문을 사용할 때 깜빡하고 중괄호를 사용하지 않아 발생하는 에러를 방지할 수 있다.

#### 계단식 if문

조건문을 사용할 때 언제나 조건이 한 개일 수는 없다. 여러가지 조건을 판별해보고, 참인 값이 나오면 거기서 멈추는 경우가 대부분일 것이다. 이럴 때 "계단식"으로 `if`문을 사용하는 것이 좋다. 예를 들어 `n`이 0보다 작은지, 같은지, 큰지를 판별하는데 계단식 `if`문을 사용해보겠다.

```c
if (n < 0)
    printf("n은 0보다 작다\n");
else
    if (n == 0)
        printf("n은 0과 같다\n);
    else
        printf("n은 0보다 크다\n");
```

위의 예시에선 두번째 `if`문처럼 `if`문 안에 포함된 `if`문을 들여썼지만, 실제로는 들여쓰지 않고 `else`와 같은 줄에 `if`문을 작성한다.

```c
if (n < 0)
    printf("n은 0보다 작다\n");
else if (n == 0)
    printf("n은 0과 같다\n);
else
    printf("n은 0보다 크다\n");
```

이런식으로 계단식 `if`문을 구조화하면 다음과 같이 표현할 수 있다.

```c
if (  expression  )
    statement
else if (  expression  )
    statement
...
else if (  expression  )
    statement
else
    statement
```

마지막 두 줄(`else`와 statement)은 필수는 아니다. 이런 방식의 들여쓰기는 조건의 개수가 많아질 때 계단식 `if`문이 과도하게 들여써지는 현상을 방지해준다. 또한 독자로 하여금 본 구문이 계단식으로 조건을 판별하고 있음을 쉽게 보일 수 있다.

계단식 `if`문은 새로운 유형의 구문이 아니라 기존의 것들을 조합해서 활용한 구문이다. 평범한 `if`문 안에 또다른 `if`문과 `else`문이 있었을 뿐이다(또한 그 또다른 `if`문 안에도 마찬가지로 다른 `if`문과 `else`문을 포함할 수 있을 것이고, 이것은 무한대로 적용할 수 있다.).

#### [프로그래밍] 중개 수수료 계산하기

주식을 브로커를 통해 사고 파려면 수수료가 발생한다. 이때 수수료는 거래된 주식의 가치에 따라 증가폭이 달라진다. 브로커가 다음 표와 같이 수수료를 책정한다고 하자.

| 거래 규모             | 수수료율     |
| :-------------------- | :----------- |
| $2,500 미만           | $30 + 1.7%   |
| 2,500−2,500−6,250     | $56 + 0.66%  |
| 6,250−6,250−20,000    | $76 + 0.34%  |
| 20,000−20,000−50,000  | $100 + 0.22% |
| 50,000−50,000−500,000 | $155 + 0.11% |
| $500,000 초과         | $255 + 0.09% |

최소 수수료는 $39이다. 여기서 우리가 작성할 프로그램은 사용자가 거래 규모를 입력하면 이에 따른 수수료를 출력하는 프로그램이다.

Enter value of trade: 30000
Commission: $166.00

이 프로그램의 핵심은 계단식 `if`문을 적절하게 사용하여 거래 규모를 정확한 범위의 조건에 떨어지게 만드는 것이다.

**broker.c**

```c
/* Calculates a broker's commission */

#include <stdio.h>

int main(void)
{
    float commission, value;

    printf("거래값를 입력하시오: ");
    scanf("%f", &value);

    if (value < 2500.00f)
        commission = 30.00f + .017f * value;
    else if (value < 6250.00f)
        commission = 56.00f + .0066f * value;
    else if (value < 20000.00f)
        commission = 76.00f + .0034f * value;
    else if (value < 50000.00f)
        commission = 100.00f + .0022f * value;
    else if (value < 500000.00f)
        commission = 155.00f + .0011f * value;
    else
        commission = 255.00f + .0009f * value;

    if (commission < 39.00f)
        commission = 39.00f;

    printf("수수료: $%.2f\n", commission);

    return 0;
}
```

위의 계단식 `if`문과 달리 아래의 경우처럼 조건을 달리 작성할 수도 있다.

```c
if (value < 2500.00f)
    commission = 30.00f + .017f * value;
else if (value >= 2500.00f && value < 6250.00f) // 변경된 부분
    commission = 56.00f + .0066f * value;
else if (value >= 6250.00f && value < 20000.00f) // 변경된 부분
    commission = 76.00f + .0034f * value;
...
```

프로그램이 동일한 방식으로 작동은 하겠지만, 굳이 위의 조건들을 추가해줄 필요는 없다. 첫번째 `if`는 `value`가 2500보다 작은지를 판별하여 만약 작다면 그에 따른 수수료를 계산할 것이다. 그 다음 두번째 `if`의 조건인 `(value >= 2500.00f && value < 6250.00f)`을 맞닥뜨리게 되는데, `value`는 여기선 (역자. `else`문 때문에)무조건 2500보다 크거나 같아야한다. 어차피 2500보다 크거나 같기 때문에 해당 조건을 판별할 필요가 없다.

#### 누구의 `else`인가?

`if`문을 여러 겹으로 사용할 땐 `else`문을 조심해야한다. 다음 예시로 어떤 점을 조심해야하는지 직접 눈으로 확인해보자.

```c
if (y != 0)
    if (x != 0)
        result = x / y;
else
    printf("에러: y는 0과 같습니다\n");
```

여기서 `else`의 짝은 두 `if` 중 누구일까? 들여쓰기를 안한걸로 봐서는 밖의 `if`와 짝인 것처럼 보인다. 하지만 C언어에선 가장 가까운 `if`와 `else`가 서로 짝지어진다. 위 코드에서 `else`는 밖의 `if`가 아니라 안의 `if`와 짝지어진다. 만약 안의 `if`와 `else`를 짝지어주려면 아래와 같이 코드를 짜야한다.

```c
if (y != 0)
    if (x != 0)
        result = x / y;
    else
        printf("에러: y는 0과 같습니다\n");
```

만약 원래 의도한대로 `else`를 짝지어주려면 아래와 같이 코드를 다시 짜야한다.

```c
if (y != 0) {
    if (x != 0)
        result = x / y;
}   else
        printf("에러: y는 0과 같습니다\n");
```

위의 예제를 통해 배울 수 있는 점은 중괄호의 중요성이다. 애초에 첫번째 예제를 작성하기 이전에 중괄호로 작성하는 버릇을 들였다면 위와 같은 실수를 하지 않게 된다.

#### 조건 표현식

C의 `if`문은 조건의 결과값에 따라 한 개 또는 여러 개의 행동을 할 수 있게 해준다. 여기에 더해 C에선 표현식이 조건의 결과값에 따라 한 개 또는 여러 개의 값을 만들어내는 연산자가 존재한다.

**조건연산자conditional operator**는 두 가지 기호(`?`와 `:`)로 구성되어있으며, 다음과 같이 동시에 사용된다.

```c
expr1 ? expr2 : expr3
```

`expr1`, `expr2`, `expr3`은 임의의 표현식이다. 이 표현식 전체를 **조건표현식conditional expression**이라고 부른다. 조건연산자는 C언어 중에서도 매우 독특한 연산자인데, 무려 세 가지의 피연산자를 필요로한다. 이렇기 때문에 **삼중연산자ternary operator**라고 부른다.

조건표현식 `expr1 ? expr2 : expr3`을 해석하자면 "만약 expr1이면 expr2이고, 그 외의 경우엔 expr3이야"이다. 본 표현식은 다음 순서대로 평가가 진행된다. 우선 `expr1`을 평가한다. 만약 결과값이 0이 아니라면 `expr2`를 평가하고, 그 결과값은 조건표현식 전체의 결과값이 된다. 만약 `expr1`의 값이 0이라면 `expr3`의 값이 조건표현식의 값이 된다.

다음 예제로 조건연산자를 좀 더 이해해보자.

```c
int i, j, k;

i = 1;
j = 2;
k = i > j ? i : j;           /* k의 값은 2이다 */
k = (i >= 0 ? i : 0) + j;    /* k의 값은 3이다 */
```

`k`의 첫번째 할당에 사용된 조건표현식 `i > j ? i : j`은 `k`에 `i`혹은 `j`의 값을 둘의 대소관계에 따라 할당한다. `i`의 값은 1이고 `j`의 값이 2이므로 `i > j`은 거짓이다. 즉, 조건표현식의 값은 2가 되고, 이는 `k`에 할당된다. 두번째 할당에선 `i >= 0`가 참이므로 조건표현식 `(i >= 0 ? i : 0)`의 값은 1이다. 여기서 1과 `j`의 값인 2가 더해여 3이 나오고, 이는 `k`에 할당된다. 참고로 여기에서 사용된 괄호는 필수이다. 조건연산자의 평가순서는 할지금까지 다룬 그 어떤 연산자보다도 낮다.

**조건표현식**은 프로그램을 간결하게 해주지만 가독성을 떨어뜨릴 수 있다. 그렇기 때문에 사용하지 않는 것이 좋지만, 특정 경우에선 사용하는 것이 간편할 수 있다. 대표적인 예시가 `return`문이다.

```c
if (i > j)
    return i;
else
    return j;
```

대부분의 프로그래머들은 위보다는 아래처럼 코드를 작성한다.

```c
return i > j ? i : j;
```

`printf` 함수 또한 조건표현식을 사용함으로써 상당히 간편하게 코드를 짤 수 있다.

```c
if (i > j)
    printf("%d\n", i);
else
    printf("%d\n", j);
```

위와 같이 작성하기 보다는 다음과 같이 간단하게 작성할 수 있다.

```c
printf("%d\n", i > j ? i : j);
```

조건표현식은 특정 매크로정의에서도 자주 사용된다.

#### C89에서의 불 방식의 값

수년간 C언어는 제대로된 불리언형이 없었고, C89 표준도 마찬가지였다. 많은 프로그램은 참과 거짓을 판별하는 값을 갖는 형식이 필요했기에 불리언형이 없는 것은 여간 골치거리가 아니었다. C89에서 이를 해결하기 위한 방법 중 하나는 `int` 변수를 정의해서 여기에 0 또는 1을 할당하는 것이다.

```c
int flag;

flag = 0;
...
flag = 1;
```

물론 이러한 방법이 가능하기는 하지만 가독성에 그렇게 도움되지는 않는다. `flag` 하나만 보고 이게 불리언형만 저장하고 있고, 0과 1이 거짓 혹은 참을 나타내는지 알 수 있겠는가.

좀 더 가독성을 높이기 위한 다른 방법은 `TRUE`와 `FALSE`라는 이름으로 매크로정의를 하는 것이다.

```c
#define TRUE 1
#define FALSE 0
```

이제 `flag`라는 변수가 좀 더 자연스럽게 보일 것이다.

```c
flag = FALSE;
...
flag = TRUE;
```

`flag`가 참인지를 판별하려면 다음과 같이 작성해주면 된다.

```c
if (flag == TRUE) ...
```

혹은 그냥 다음과 같이 간단하게 작성할 수도 있다.

```c
if (flag) ...
```

밑에 형태처럼 작성하는 것이 사실 더 낫다. 더 정확할 뿐만 아니라 `flag` 변수가 0이나 1이 아닌 값을 가져도 작동하기 때문이다.

`flag` 변수가 거짓인지 판별하려면 다음과 같이 작성해주면 된다.

```c
if (flag == FALSE) ...
```

혹은 그냥 다음과 같이 간단하게 작성할 수도 있다.

```c
if (!flag) ...
```

이 방법을 좀 더 확장한다면 타입처럼 사용할 수 있는 매크로를 정의할 수도 있을 것이다.

```c
#define BOOL int
```

`BOOL`을 불리언형의 변수를 선언할 때 `int` 대신 사용할 수 있다.

```c
BOOL flag;
```

이제 드디어 `flag`가 단순히 정수형 변수로 보이지 않고 확실한 불리언형이라는 것으로 읽힌다. (컴파일러는 `flag`를 물론 `int`형 변수로 취급할 것이다) 나중 단원에서 C89에서 형식정의type definition와 열거enumeration라는 좀 더 나은 방법으로 불리언형을 제작하는 방법을 배울 것이다. (역자: 물론 C가 아닌 C++을 배울 여러분은 걸러도 된다)

#### C99에서의 불 방식의 값

C99에선 `_Bool` 형식을 제공하기에 사실상 불리언형이 존재한다. C99에서 불리언형 변수를 정의하려면 다음과 같이 해주면 된다. **[Q & A]**

```c
_Bool flag;
```

`_Bool`은 정수형이다.(정확히 말하면 무부호 정수형이다.) 그렇기 때문에 `_Bool`형 변수는 사실상 `int`형 변수이다. 다만 일반적인 정수형 변수와는 달리 `_Bool`형 변수에는 0 또는 1만 할당될 수 있다. 일반적으로 `_Bool`형 변수에 0이 아닌 값을 저장하게 되면 이는 1로 변환되어 저장된다.

```c
flag = 5; /* flag엔 1이 할당된다 */
```

`_Bool`형 변수로 산술연산을 할 수는 있다(하지 않는 편이 좋다). 또한 `_Bool`형 변수를 출력하는 것 또한 가능하다(0 또는 1이 출력될 것이다). 물론, 당연히 `if`문의 조건에 사용될 수 있다.

```c
if (flag)    /* flag의 값이 1인지 판별한다 */
    ...
```

`_Bool`형 뿐만 아니라 C99에는 ``이라는 이름의 헤더파일을 제공한다. 이 헤더파일을 통해 불리언형 변수를 좀 더 손쉽게 다룰 수 있다. 이 헤더파일에는 `bool`이라는 이름의 매크로가 존재하고, 이는 `_Bool`을 의미한다. 만약 ``를 프로그램에 추가해주었다면 다음과 같이 코드를 작성할 수 있다.

```c
bool flag; /* _Bool flag;와 같은 의미이다 */
```

헤더파일은 또한 `true`와 `false`라는 매크로를 갖고 있고, 이는 각각 1과 0을 의미한다. 즉, 이를 사용하면 다음과 같이 코드를 작성할 수 있다.

```c
flag = false;
...
flag = true;
```

헤더는 매우 간편하기 때문에 앞으로 프로그램에서 불리언형 변수가 필요할 때마다 사용하겠다.

### 3 switch문

프로그래밍을 할 때 우리는 어떤 표현식을 여러 값과 비교하는 코드를 짜야될 때가 있다. 5.2 단원에서 계단식 `if`문을 이용해 이러한 목적에 따른 코딩법을 배웠다. 예를 들자면 숫자 학점에 따른 코멘트 출력 프로그램이 있다.

```c
if (grade == 4)
    printf("훌륭해요!")
else if (grade == 3)
    printf("좋아요!");
else if (grade == 2)
    printf("평균이네요!");
else if (grade == 1)
    printf("좋지 않아요!");
else if (grade == 0)
    printf("좀 더 노력하세요!");
else
    printf("잘못된 학점입니다");
```

C언어에는 이런 방식의 계단식 `if`문 대신 사용할 수 있는 `switch` 구문이 있다. 위의 코드를 `switch`문으로 바꿔보자.

```c
switch (grade) {
    case 4:  printf("훌륭해요!")
             break;
    case 3:  printf("좋아요!");
             break;
    case 2:  printf("평균이네요!");
             break;
    case 1:  printf("좋지 않아요!");
             break;
    case 0:  printf("좀 더 노력하세요!");
             break;
    default: printf("잘못된 학점입니다");
             break;
}
```

이 구문이 실행되면 변수 `grade`의 값이 각 조건에 맞는지 판별을 한다. 만약 값이 4라면 `훌륭해요!`라는 메세지가 출력되고 `break`문에 의해 `switch`문 이후로 프로그램이 넘어간다. 만약 `grade`의 값이 지정된 조건에 해당하지 않다면 `default` 조건으로 넘어가게 되어 `잘못된 학점입니다`가 출력된다.

계단식 `if`문보다 `switch`문이 더 가독성이 좋고 특히 조건이 많을수록 실행속도도 더욱 빠르다.

대부분의 경우 `switch`문은 다음과 같은 구조를 갖는다. **[Q & A]**

```c
switch (  expression  ) {
    case constant-expression  :  statements
    ...
    case constant-expression  :  statements
    default: statements
}
```

`switch`문은 보이기엔 복잡해보인다. 구문을 좀 더 구체적으로 살펴보자.

- **제어식controlling expression**. `switch`라는 단어 다음엔 반드시 괄호로 둘러싸인 정수 표현식이 나와야한다. C에서는 문자를 정수로 취급하므로 `switch`문에 사용할 수 있다. 하지만 고정소수는 사용할 수 없다.
- **조건 부호case label**. 각 조건은 다음 형식으로 부호가 붙여져야한다.

`case constant-expression :` 상수식은 일반 표현식과 똑같으나, 변수나 함수 호출을 포함할 수 없다. `5`는 상수식이고 `5 + 10`은 상수식이지만 `n + 10`은 상수식이 아니다(`n`이 매크로정의된 상수가 아니라면 말이다). 조건부호에서 상수식은 반드시 정수(문자도 포함한다)여야한다.

- **구문statements**. 각 조건부호 다음엔 한 개 이상의 구문이 올 수 있다. 굳이 복합문처럼 중괄호를 써줄 필요가 없다. (이 순간을 즐겨라. 이런식으로 중괄호가 필요없는 순간이 자주 오지 않는다.) 각 조건부호의 구문은 주로 `break`문으로 끝난다.

조건부호 중복은 허용되지 않는다. 조건의 순서는 중요하지 않다. `default`도 반드시 맨 마지막에 나와야하는 것은 아니다.

`case` 다음엔 반드시 한 개의 상수식만 올 수 있지만 여러 개의 조건부호들이 다음 예시처럼 같은 구문을 공유할 수 있다.

```c
switch (grade) {
    case 4:
    case 3:
    case 2:
    case 1:  printf("좋지 않아요!");
             break;
    case 0:  printf("좀 더 노력하세요!");
             break;
    default: printf("잘못된 학점입니다");
             break;
}
```

좀 더 공간을 아끼려고 중복되는 조건부호들을 한 줄에 놓기도 한다.

```c
switch (grade) {
    case 4: case 3: case 2: case 1:
             printf("좋지 않아요!");
             break;
    case 0:  printf("좀 더 노력하세요!");
             break;
    default: printf("잘못된 학점입니다");
             break;
}
```

아쉽게도 다른 프로그래밍 언어처럼 일정 범위를 조건부호로 나타낼 수는 없다.

`switch`문은 반드시 `default` 조건을 필수로 하지 않는다. 만약 `default`가 존재하지 않는데 제어식의 값이 그 어떤 조건부호와도 만족하지 않는다면 프로그램은 단순히 `switch`문 다음 구문으로 넘어간다.

#### break 구문의 역할

이제 `break`문을 좀 더 구체적으로 살펴보도록 하자. 위의 예제에서도 보았듯, `break`문은 말 그대로 `switch`문에서 나오게 만든다. 프로그램 실행이 `switch`문 다음 구문으로 넘어가게 되는 것이다.

`break`문이 필요한 이유는 `switch`문은 "계산된 도약computed jump"이기 때문이다. 제어식이 평가될 때 제어는 `switch`문의 표현식의 값에 해당되는 조건부호로 도약jump하게 된다. 조건부호는 단순히 `switch`문 내에서의 이동지점을 의미한다. 조건의 마지막 구문이 실행되면 제어는 그 다음 조건의 첫번째 구문으로 "넘어간다falls through". 여기서 이 조건의 조건부호는 무시된다. `break`문(혹은 기타 다른 도약문)이 없다면 제어는 계속해서 다음 조건으로 넘어가게 될 것이다. 다음 `switch`문 예제로 직접 살펴보자.

```c
switch (grade) {
    case 4:  printf("훌륭해요!")
    case 3:  printf("좋아요!");
    case 2:  printf("평균이네요!");
    case 1:  printf("좋지 않아요!");
    case 0:  printf("좀 더 노력하세요!");
    default: printf("잘못된 학점입니다");
}
```

만약 `grade`의 값이 3이라면 이 프로그램의 실행결과는 다음과 같을 것이다.

> 좋아요!평균이네요!좋지 않아요!좀 더 노력하세요!잘못된 학점입니다

> **[!!!]**
>
> 깜빡하고 `break`문을 사용하지 않는 것은 흔히 발생하는 실수이다. 물론 코드를 공유하기 위해 일부러 사용하지 않는 경우도 존재하지만, 대부분의 경우는 그냥 깜빡하고 넘어가는 경우이다.

의도적으로 조건이 그대로 넘어가게 하는 건 자주 발생하는 경우가 아니므로 만약 코딩을 할 때 그런 의도가 있다면 주석처리를 해주는 것이 좋다.

```
switch (grade) {
    case 4: case 3: case 2: case 1:
             num_passing++
             /* 그대로 넘어감 */
    case 0:  total_grades++;
             break;
}
```

위처럼 주석이 없다면 누군가가 나중에 이것을 실수라고 해석해 원치 않는 `break`문이 더해질 수 있다.

마지막 조건부호엔 굳이 `break`문을 필요로 하지 않지만 그럼에도 나중에 코드의 수정을 용이하게 하기 위해 넣어주는 것이 좋다. 넣지 않은 채로 코드를 수정했다가는 "`break`문 실종" 문제가 발생할 것이다.

#### [프로그래밍] 날짜를 법률상의 서식으로 출력하기

계약과 같은 법적 서류들은 미국에서 다음과 같은 방식으로 날짜를 표기한다.

```
Dated this __________day of ________, 20__.
```

이런 형식으로 날짜를 출력하는 프로그램을 작성해보자. 사용자가 날짜를 월/일/년 형식으로 입력하면 이를 미국 법적 표기로 변환해보겠다.

```
날짜를 입력해주세요 (mm/dd/yy): 7/19/14
Dated this 19th day of July, 2014.
```

대부분의 문자형식은 `printf`로 해결할 수 있지만 두 가지 문제를 해결해야한다. 첫번째 문제는 날짜의 "번째" 부분을 추가하는 것이고, 두번째는 월을 숫자 대신 문자로 입력하는 부분이다. 다행히도 두 가지 문제는 `switch`문으로 해결할 수 있을 것 같아 보인다. 첫번째에선 번째 문제를 해결하고, 두 번째에선 월의 이름을 출력해주면 될 것이다.

**date.c**

```c
/* 날짜를 미국 법적 형식으로 출력한다 */

#include <stdio.h>

int main(void)
{
    int month, day, year;

    printf("날짜를 입력해주세요 (mm/dd/yy): ");
    scanf("%d /%d /%d", &month, &day, &year);

    printf("Dated this %d", day);
    switch (day) {
        case 1: case 21: case 31:
            printf("st"); break;
        case 2: case 22:
            printf("nd"); break;
        case 3: case 23:
            printf("rd"); break;
        default: printf("th"); break;
    }
    printf(" day of ");

    switch (month) {
        case 1:  printf("January");   break;
        case 2:  printf("February");  break;
        case 3:  printf("March");     break;
        case 4:  printf("April");     break;
        case 5:  printf("May");       break;
        case 6:  printf("June");      break;
        case 7:  printf("July");      break;
        case 8:  printf("August");    break;
        case 9:  printf("September"); break;
        case 10: printf("October");   break;
        case 11: printf("November");  break;
        case 12: printf("December");  break;
    }

    printf(", 20%.2d.\n", year);
    return 0;
}
```

년도 두 자리를 출력할 때 `%.2d`를 사용했다. 만약 %d만을 사용해주었다면 한자리수 년도가 의도한대로 출력되지 않았을 것이다(2005년이 아니라 205로 출력되었을 것이다).

### Q & A

#### 제 컴파일러는 `==` 대신 `=`를 써도 경고 메세지를 출력하지 않던데, 컴파일러가 이런 점을 강제로 경고로 알려주게 만들 수 있나요? [if문]

몇몇 프로그래머들이 사용하는 방법이 있죠.

```c
if (i == 0) ...
```

이렇게 작성 안하고

```c
if (0 == i) ...
```

이렇게 습관적으로 작성해요. 그 다음에 `==` 연산자를 실수로 `=`로 작성했다고 해봅시다.

```c
if (0 = i) ...
```

이러면 0에 값을 할당할 수 없기에 컴파일러가 에러 메세지를 낼거에요. 사실 전 이 방법을 사용하진 않아요. 프로그램이 상당히 비정상적으로 보이거든요. 그리고 조건의 한 피연산자가 왼쪽값이 아닐 때 밖에 쓸 수 있어요.

다행히도 대부분의 컴파일러는 `=` 연산자를 `if`문에서 잘못 사용한 경우를 잡아줘요. 예를 들어 GCC 컴파일러는 `-Wparentheses` 기능 혹은 `-Wall`(모든 경고 메세지 표시) 기능으로 위 경우를 잡아줄 수 있어요. GCC를 사용할 때 만약 의도적으로 `=` 연산자를 써준 경우 괄호를 두 번 해주면 경고 메세지가 뜨지 않게 해줄 수 있어요.

```c
if ((i = j)) ...
```

#### C언어 책들마다 복합문에서 들여쓰기하는 방식이 다르던데, 어떤 방식이 제일 좋은 방식인가요?

The New Hacker's Dictionary에 의하면 크게 네 가지 들여쓰기 및 중괄호 표기법이 있다고 해요.

- **K&R 방식**. 커니건과 리치의 The C Programming Language 책에서 쓰인 방법으로 이 책에서도 사용하는 방법이에요. K&R 방식은 왼쪽 중괄호가 줄의 마지막에 표기되죠.

```c
if (line_num == MAX_LINES) {
    line_num = 0;
    page_num++;
}
```

K&R 방식은 왼쪽 중괄호를 새 줄이 아니라 같은 줄에 놓음으로써 프로그램이 좀 더 압축되어 보이죠. 단점으로는 왼쪽 중괄호의 위치를 쉽게 파악하기 어려울 수 있다는 점이 있어요. (개인적으론 이걸 문제라고 생각하지는 않아요. 들여쓰기를 통해서 생각보다 손쉽게 찾을 수 있답니다.) K&R 방식은 Java에서 흔히 사용되는 방식이에요.

- **올맨Allman 방식**. 에릭 올맨(`sendmail`과 기타 다른 UNIX 기능을 작성한 사람이다)의 이름을 딴 방식으로, 왼쪽 중괄호를 새 줄에 놓는 방식이에요.

```c
if (line_num == MAX_LINES)
{
    line_num = 0;
    page_num++;
}
```

중괄호의 짝을 손쉽게 찾을 수 있다는 장점이 있죠.

- **화이트스미스Whitesmiths 방식**. 화이트스미스 C 컴파일러 때문에 유명해진 방법인데요, 중괄호들도 들여쓰는 방법이죠.

```c
if (line_num == MAX_LINES)
    {
    line_num = 0;
    page_num++;
    }
```

- **그누GNU 방식**. GNU 프로젝트에 사용된 소프트웨어들에서 사용된 방법이에요. 중괄호를 들여쓰고, 그 안의 구문들은 더 들여쓰죠.

```c
if (line_num == MAX_LINES)
    {
        line_num = 0;
        page_num++;
    }
```

어떤 방식을 택하는가는 순전히 취향 차이에요. 어떤 방식이 다른 것보다 더 낫다는 증거는 없어요. 뭘 선택하느냐가 중요한게 아니라, 한 방식을 그대로 유지하는 것이 더욱 더 중요해요.

#### 만약 `i`가 `int`형 변수이고 `f`가 `float`형 변수일 때, 조건식 `(i > 0 ? i : f)`은 무슨 형식인가요?

`int`형과 `float`형 변수가 위의 예시처럼 조건식에서 동시에 사용되면 조건식은 `float`형이에요. 만약 `i > 0`이 참이라면 조건식의 값은 `float`형으로 형변환된 `i`의 값이에요.

#### C99는 왜 불리언형을 그렇게 밖에 이름을 못 지었나요? [if문]

`_Bool`이 그렇게 잘 지은 이름은 아니긴 하죠. `bool`이나 `boolean` 같이 좀 더 흔한 이름이 선택되지 않은 이유는 현존하는 수많은 프로그램들이 이미 정의해서 사용하고 있어 컴파일 에러를 낼 수도 있기 때문이죠. **[C99]**

#### 그렇다고 `_Bool`이 옛날 프로그램이 영향을 안 줄거라는 보장은 어디있죠?

C89 표준에선 밑줄로 시작하고 그 다음에 대문자가 오는 변수 이름들을 추후에 사용하려고 막아놨었거든요.

#### `switch`문이 대부분의 경우 이런 구조를 갖는다고 하셨는데, 그럼 다른 구조들도 있나요? [switch문]

`switch`문은 이 단원에서 다룬 걸로 사실 대부분의 프로그램에서 충분하지만, 이보다 좀 더 광범위하게 사용할 수 있어요. 예를 들어 `switch`문에선 `case`라는 말 없이도 부호를 사용할 수 있고, 이는 여러 재미있는 상황을 연출해낼 수 있죠. 예를 들어 `default`를 실수로 오타를 냈다고 해봅시다.

```c
switch (...) {
    ...
    defualt: ...
}
```

사실 컴파일러는 여기서 defualt를 그냥 평범한 부호로 인식하고 뭐가 잘못됐는지도 모르고 넘어갈 수도 있어요.

#### `switch`문을 들여쓰는 여러 방법들이 있던데, 어떤 방법이 제일 좋나요?

크게 두 가지 방법이 있어요. 하나는 구문을 `case`가 있는 줄에서 시작해서 작성하는거에요.

```c
switch (coin) {
    case 1:  printf("Cent");
             break;
    case 5:  printf("Nickel");
             break;
    case 10: printf("Dime");
             break;
    case 25: printf("Quarter");
             break;
}
```

각 조건은 하나의 행동(위 예시의 경우 `printf` 함수 호출이다)과 `break`문으로 이루어져있어요. 여기서 이 `break`문은 같은 줄에 놓아도 무방해요.

```c
switch (coin) {
    case 1:  printf("Cent");    break;
    case 5:  printf("Nickel");  break;
    case 10: printf("Dime");    break;
    case 25: printf("Quarter"); break;
}
```

두번째 방법은 구문을 조건부호 밑에부터 들여쓰고 작성하는거에요.

```c
switch (coin) {
    case 1:
        printf("Cent");
        break;
    case 5:
        printf("Nickel");
        break;
    case 10:
        printf("Dime");
        break;
    case 25:
        printf("Quarter");
        break;
}
```

이 방법의 변형으로는 각 조건부호를 `switch`와 같은 줄에 놓는 방법이 있어요.

첫번째 방법은 조건이 적고, 각 조건마다 구문이 적을 때 사용하는게 좋아요. 두번째 방법은 조건이 상당히 많고 구문들도 복잡하거나 많을 때 사용하는게 좋아요.