# 4. Expressions

 C 언어의 특징 중 하나는 바로 구문보다 표현식을 엄청 중시한다는 것이다. 여기서 **표현식이란 어떠한 값을 계산하는 식을 말하는 것이다.** 가장 간단한 형식의 표현식은 바로 **변수와 상수**이다. 변수란 프로그램이 실행되었을 때 계산되는 값을 의미하고, 상수는 변하지 않는 값을 의미한다. 복잡한 표현식에는 피연산자에 연산자를 포함시킨다. 이 때 **피연산자는 자기 자신이 곧 표현식**이다. 표현식 `a + (b * c)`에는 `+` 연산자는 피연산자 `a`와 `(b * c)`에 적용되어있고, 이 **두 피연산자는 자기 자신이 곧 표현식**이기도 하다. **연산자는 표현식을 만드는 기본적인 도구**이다, C 언어는 특이하게도 매우 많은 연산자가 있는 언어이다. 우선 C는 대부분의 프로그래밍 언어가 갖는 기초적인 연산자들이 있다.

- **산술연산자(Arithmetic Operators)** - 덧셈, 뺄셈, 곱셈과 나눗셈을 의미한다.
- **관계연산자(Realtional Operators)**- `i`는 `0`보다 크다"와 같은 **비교** 등을 행할 때 사용하는 연산자이다.
- **논리연산자(Logical Operators)** - `i`는 `0`보다 크고 `i`는 `0`보다 작다"와 같은 **조건을 만드는 데 필요한 연산자**이다.

C는 이 세 가지 이외에도 수많은 연산자들이 있다. 연산자가 너무 많아 이 책의 첫 20단원까지 순서대로 다뤄야할 정도이다. 연산자를 완벽하게 익히는 것은 매우 힘들지만, C를 잘 사용하려면 필수이다.

이 단원에선 C의 가장 중요한 연산자인 산술 연산자(4.1 단원), 할당 연산자(4.2 단원), 증감 연산자(4.3 단원)를 다룰 것이다. 4.1 단원에선 연산자들 사이의 순서 법칙과 결합 법칙을 다룰 것이다. 연산자가 여러 개인 표현식에서 순서와 결합은 매우 중요하다. 4.4 단원에선 C 표현식이 어떻게 평가되는지를 배울 것이다. 마지막으로 4.5 단원에선 표현식 구문을 배울 것이다. 이는 표현식을 구문 취급하는 매우 특이한 기능이다.



### 4.1 산술연산자

산술 연산자arithmetic operator란 덧셈, 뺄셈, 곱셈, 나눗셈 등을 하는 연산자이다. 산술 연산자는 C를 포함한 대부분의 프로그래밍 언어에서 가장 많이 사용되는 기능 중 하나이다. 표 4.1에서 C의 산술 연산자를 다루고 있다.

| 단항 연산자      | 이항 연산자 |
| :--------------- | :---------- |
| +  양수임을 강조 | + 덧셈      |
| - 음수 표현      | - 뺄셈      |
|                  | * 곱셈      |
|                  | / 나눗셈    |
|                  | % 나머지    |

**[표 4.1]**

덧셈류와 곱셈류 연산자들은 두 개의 피연산자를 필요로 하기 때문에 이항binary이라고 불린다. 단항unary 연산자는 한 개의 피연산자를 필요로 한다.

```c
i = +1; /* + 는 여기서 단항 연산자로 쓰임 */
j = -1; /* - 는 여기서 단항 연산자로 쓰임 */
```

단항 `+` 연산자는 사실 아무것도 하지 않으며, 사실 K&R C에서도 존재하지 않는다. 이 표현은 그냥 어떤 상수가 **양수임을 강조**하기 위해 사용한다.

이항 연산자는 좀 더 친숙하게 다가올 것이다. 아마 위의 표에서 제일 익숙하지 않은 연산자는 나머지 연산자인 `%` 연산자일 것이다. `i % j`의 값은 `i`를 `j`로 나눴을 때의 나머지이다. 예를 들어 `10 % 3`의 값은 `1`이고 `12 % 4`의 값은 `0`일 것이다.

**[Q&A]** 표 4.1에서 나오는 이항 연산자 중 `%`를 제외하면 정수와 실수형 피연산자를 둘 다 허용하고, 섞어서 사용하는 것 또한 허용한다. 만약 `int`와 `float`형 피연산자가 동시에 사용되었다면 결과는 `float`형으로 나올 것이다. 그렇기 때문에 `9 + 2.5f`의 결과값은 `11.5`이고 `6.7f / 2`의 결과값은 `3.35`이다.

**`/` 연산자와 `%` 연산자는 특수하게 다루어주어야 한다.**

- `/` 연산자는 예상하지 못한 결과를 생성할 수도 있다. 만약 피연산자가 둘 다 정수라면, `/` 연산자는 소수점 부분을 삭제함으로서 결과값을 줄여 정수로 만든다. 즉, `1 / 2`의 값은 `0.5`가 아니라 `0`이 나온다.
- `%` 연산자는 **피연산자가 정수**여야한다. 만약 피연산자가 정수가 아니라면 컴파일되지 않는다.
- `/`이나 `%`를 사용할 때 **`0`을 우항 피연산자**로 사용하는 경우 예상하지 못한 결과가 나올 수 있다.
- **[Q&A]** `/`이나 `%`이 음수 피연산자와 함께 사용하게 되면 결과를 표현해주기가 매우 힘들다. C89 표준에 의하면 두 개의 피연산자 중 하나라도 음수면 나눗셈의 결과값은 반올림 되거나 반내림 될 수 있다고 되어있다. 예를 들면 `-9 / 7`의 값이 `-1`이거나 `-2`가 될 수 있다. 만약 `i`나 `j`가 음수라면 C89에서 `i % j`는 사용하는 방법에 따라 다르다. 예를 들어 `-9 % 7`은 `-2`거나 `5`가 될 수 있다. **[C99]** C99에선 나눗셈의 결과가 언제나 `0`과 가장 가까운 값을 갖는다. 즉 `-9 / 7`의 값은 `-1`이고, `i % j`의 경우 결과값의 부호는 `i`를 따라간다. 즉 `-9 % 7`은 `-2`이다.

> **[시행정의행동]** 시행정의implementation-defined라는 말을 앞으로 많이 듣게 될 것이기에, 이 즈음에서 한 번 다뤄보도록 하겠다. C 표준은 의도적으로 언어의 일부분을 확실하지 않게 남겨두고, "시행implemenation"이라는 것, 즉 소프트웨어가 어떠한 특정 플랫폼에서 컴파일하고, 링크하고, 실행해야할 프로그램을 통해 **그 확실하지 않은 부분을 채운다**. 결과적으로 프로그램의 실행 결과는 시행에 따라 달라질 것이다. C89에서 음수 피연산자를 사용했을 때의 `/`이나 `%`의 결과가 시행으로 정의되는 행동의 예이다.
>
> 언어의 일부를 구체적으로 설명해주지 않는 것은 매우 이상하고 심지어는 위험해보이는 행동이지만, 이는 C의 철학을 보여준다. C 언어의 중요한 목표 중 하나는 효율성이고, 효율성이란 하드웨어에 따라 방법을 맞춰주는 것을 의미하기도 하다. 어떤 CPU는 `-9`가 `7`로 나눠질 때 `-1`를 결과값으로 내보내고, 어떤 CPU는 `-2`로 내보낸다. C89 규격은 그저 인생의 진리를 그대로 보여주고 있을 뿐이다.
>
> 되도록이면 이러한 시행정의행동을 기피하는 것이 좋다. 만약 피할 수 없다면, 적어도 매뉴얼을 잘 살펴보라. C 표준은 시행정의행동을 서류화하고 싶어한다.

#### 연산자 순서 및 결합 법칙

한 표현식이 한 개 이상의 연산자를 갖고 있는 경우, 이를 단번에 해석하기란 어려울 수 있다. `i + j * k`라는 구문이 "`i`랑 `j` 더하고, 그 값을 `k`랑 곱하라"는 뜻인지, "`j`랑 `k` 곱하고 거기에 `i`를 더해라"는 뜻인지 어떻게 알 수 있는가? 가장 손쉬운 해결방법은 괄호를 사용하는 것이다. `(i + j) * k`라고 적거나 `i + (j * k)`라고 적어주는 것이다. C 언어는 표현식을 괄호로 묶는 것을 일반적인 규칙으로 허용한다.

만약 괄호를 쓰지 않는다면 어떻게 해야될까? 컴파일러는 `i + j * k`를 `(i + j) * k`로 해석할까 아니면 `i + (j * k)`로 해석할까? 다른 언어들과 마찬가지로 C는 연산자순서 규칙을 정해놓아 이러한 모호함을 해결한다. 산술연산자는 다음과 같은 상대적 순서가 존재한다.

> `순서 높음`

 `+` `-` (단항) 

`*` `/` `%` (이항)

 `+` `-` (이항)

> `순서 낮음`

`+`와 `-`처럼 같은 줄에 있는 연산자들은 동일한 순서이다.

한 표현식에 두 개 이상의 연산자가 존재하는 경우 컴파일러는 높은 순서 연산자부터 시작해서 표현식을 괄호로 계층화해서 해석한다. 다음 예시를 보라.

`i + j * k` 는 `i + (j * k)` 와 같다.

`-i * -j` 는 `(-i) * (-j)` 와 같다. 

`+i + j / k` 는 `(+i) + (j / k)` 와 같다.

연산자 순서 규칙으로는 사실 충분하지 않다. 만약 동일 순서의 연산자들이 여러개가 한 표현식에 존재한다면 어떤식으로 표현식을 처리해야하는가? 이런 상황에서는 연산자의 결합을 사용하게 된다. 왼쪽에서 오른쪽으로 결합한다면 좌향결합적이라고 부른다. 이항산술연산자는 전부 좌향결합적이다. 즉,

`i - j - k` 는 `(i - j) - k` 와 같다. 

`i * j / k` 는 `(i * j) / k` 와 같다.

반대로 오른쪽부터 왼쪽으로 결합한다면 우향결합적이라고 한다. **단항산술연산자가 우향결합**적이다. 즉,

`- + i` 는 `-(+i)`와 동일하다.

순서와 결합 법칙은 물론 많은 언어에서 중요한 개념이지만, 특히나 C 언어에서는 더더욱 중요하다. 단, C 언어엔 50 가지 이상의 연산자가 있어 이에 대한 순서와 결합 법칙을 외우는 프로그래머는 매우 드물다. 차라리 확실하지 않으면 검색을 해서 순서 및 결합 법칙 도표를 참고하거나 괄호를 사용하자.

#### [프로그래밍] 세계상품코드(UPC) 검사 기호 계산하기

몇년간 미국과 캐나다에 제품을 판매하는 제조업자들은 각 제품에 바코드를 찍기 시작했다. 이 코드는 세계상품코드(UPC)라고도 알려져있는데, 제품과 제조업자에 대한 정보를 담고있다. 각 바코드는 12자리의 숫자이며 주로 바코드 선 아래에 적혀있다. 예를 들어 Stouffer's French Bread 페페로니 피자 패키지의 바코드는 다음과 같이 생겼다.

[바코드 사진]

바코드에 적혀있는 숫자인

> 0 13800 15173 5

는 바코드 선 밑에 적혀있다. 첫번째 자리는 제품의 유형을 나타낸다. 대부분의 경우 0 혹은 7이며, 무게를 재야하는 제품의 경우 2, 약이나 건강 관련 제품은 3, 쿠폰은 5이다. 첫 5개의 숫자들은 제조업자를 의미한다. 13800은 네슬리 미국 냉동식품지사를 의미한다. 두번째 5개의 숫자들은 제품을 의미하고, 이는 패키지 사이즈도 포함한다. 마지막 숫자는 "확인자릿수"로, 앞의 11개의 숫자가 제대로 적혀있는지 확인하는 수이다. 만약 UPC가 제대로 스캔이 되지 않았다면 첫 11 개의 숫자들이 마지막 확인자릿수와 무관할 수 있어 상점의 바코드 스캐너는 전체 코드를 인식하지 않을 수 있다.

확인자릿수를 계산하는 방법은 다음과 같다.

1. 홀수번째 숫자를 더한다
2. 짝수번째 숫자를 더한다 (마지막 12번째는 제외)
3. 첫번째 합을 3만큼 곱하고 두번째 합과 더한다
4. 전체 합에서 1을 뺀다
5. 결과값을 10으로 나눴을 때의 나머지를 구한다
6. 9에서 이 나머지를 뺀다

Stouffer's를 이용해 실제 값을 구해보자. 첫번째 합은 0 + 3 + 0 + 1 + 1 + 3 = 8이고, 두번째 합은 1 + 8 + 0 + 5 + 7 = 21이다. 첫번째 합을 3만큼 곱하고 두번째 합과 더하면 45가 나온다. 여기에 1을 빼면 44가 된다. 10으로 나눈 나머지는 4이다. 이 나머지를 9에 빼면 답은 5가 나온다. 아래는 다른 UPC의 예시이다. 만약 직접 확인자릿수를 계산해보고 싶다면 해보라.

Kif Creamy 땅콩버터(18 oz.): 0 51500 24128 ? Ocean Spray 크랜베리젤리소스(8 oz): 0 31200 01005 ?

정답은 8과 6이다.

이제 아무 UPC의 확인자릿수를 계산해주는 프로그램을 작성해보자. 우선 사용자로 하여금 11자리의 숫자를 입력하도록 하고, 이에 해당하는 확인자릿수를 출력해준다. 혼동을 피하기 위해 사용자는 첫번째 숫자, 두번째 5자리 숫자, 세번째 5자리 숫자를 따로따로 세 가지의 값을 입력하게 만든다. 이 프로그램이 다음과 같이 생겼다고 해보자.

> 첫번째 (한자리수) 숫자를 입력해주세요: 첫번째 (한자리수) 숫자를 입력해주세요: 0
> 첫번째 다섯자리 숫자를 입력해주세요: 13800
> 두번째 다섯자리 숫자를 입력해주세요: 15173
> 확인자릿수: 5

두 다섯자리 숫자를 정말로 다섯자리 숫자로 인식하는 것보다는 다섯개의 서로 다른 숫자의 모임으로 인식하도록 하겠다. 숫자를 한 자리 숫자들로 인식하는 것이 사실 더 편하고 다섯자리 숫자는 몇몇 오래된 컴파일러에겐 저장하기에 너무 클 수 있기 때문(정수형이 32,767이 최대일 수도 있다)에 이렇게 해주는 것이 더 좋다. 한 자리만 읽기 위해선 `scanf`와 `%1d` 변환규격을 사용하겠다.

`upc.c`

```c
/* UPC의 확인자릿수를 계산함 */

#include <stdio.h>

int main(void)
{
    int d, i1, i2, i3, i4, i5, j1, j2, j3, j4, j5, 
        first_sum, second_sum, total;

    printf("첫번째 (한자리수) 숫자를 입력해주세요: ");
    scanf("%1d", &d);
    printf("첫번째 다섯자리 숫자를 입력해주세요: ");
    scanf("%1d%1d%1d%1d%1d", &i1, &i2, &i3, &i4, &i5);
    printf("두번째 다섯자리 숫자를 입력해주세요: ");
    scanf(%1d%1d%1d%1d%1d", &j1, &j2, &j3, &j4, &j5);

    first_sum = d + i2 + i4 + j1 + j3 + j5;
    second_sum = i1 + i3 + j2 + j4;
    total = 3 * first_sum + second_sum;

    printf("확인자릿수: %d\n", 9 - ((total - 1) % 10));

    return 0;
}
```

표현식 `9 - ((total - 1) % 10)`을 `9 - (total - 1) % 10`으로 적을 수 있음에도 굳이 괄호를 추가해주었다. 이렇듯 괄호는 가독성을 높여준다.

### 4.2 할당연산자

표현식의 값이 계산된 다음엔 그 값을 변수에 저장해서 나중에 사용해야한다. C 언어에서 **단순할당simple assignment**을 해주는 `=` 연산자가 여기에 사용된다. 이미 변수에 저장된 값을 바꾸는 데에는 복합할당연산자를 사용하면 된다.

#### 단순할당

할당 `v = e`는 표현식 `e`를 처리하고, 그 값을 복사하여 `v`에 저장한다는 의미이다. 아래 예시가 말해주듯 `e`는 상수, 변수, 혹은 복잡한 표현식이 될 수 있다.

```c
i = 5;            /* i의 값은 5이다  */
j = i;            /* j의 값은 5이다  */
k = 10 * i + j;   /* k의 값은 55이다 */
```

만약 `v`와 `e`가 같은 형이 아니라면 할당이 되는 순간 `e`의 값은 `v`의 형에 알맞게 변환한다.

```c
int i;
float f;

i = 72.99f;    /* i의 값은 72이다    */
f = 136;       /* f의 값은 136.0이다 */
```

형변환은 나중에 좀 더 구체적으로 다루겠다.

대부분의 프로그래밍 언어에서 할당은 *구문statement*이다. C 언어에선 이와 달리 할당은 `+`와 같이 연산이다. 즉, 값 두 개를 더하면 그 합이라는 결과가 나오듯 할당도 결과를 만들어 낸다. 할당 `v = e`의 값은 할당 이후의 `v`의 값이다. 즉, `i = 72.99f`의 값은 72.99가 아닌 72이다.

> **부작용**
>
> 보통 연산자를 사용할 때 연산자가 피연산자를 바꾼다고 생각하지는 않는다. 수학에서의 연산이 그러하지 않는가. `i + j`는 `i`나 `j`의 값을 변화시키지 않는다. 그저 `i`와 `j`의 값을 더할 뿐이다.
>
> 대부분의 C언어 연산자들은 피연산자의 값을 변화시키지 않으나, 변화시키는 연산자들도 있다. 이러한 연산자들은 단순히 연산만 하는 것이 아니기 때문에 **부작용side effect**이 있다고 이야기한다. 단순할당연산자가 우리가 첫번째로 만난 부작용이 있는 연산자이다. 단순할당연산자는 왼쪽에 있는 피연산자의 값을 변화시킨다. 표현식 `i = 0`은 0이라는 결과값을 생성하고, 부작용에 일환으로 0을 `i`에 저장한다.

#### 왼쪽값

대부분의 C 연산자들은 피연산자가 변수, 상수 혹은 다른 연산자를 포함하고 있는 표현식일 수 있다. 할당연산자는 허나 **왼쪽 값lvalue**라는 것이 좌측 피연산자로서 반드시 존재해야한다. **[Q&A]** 왼쪽값은 컴퓨터 메모리에 저장되는 객체를 의미한다. 즉, 상수도 아니고, 계산의 결과값도 아니다. 변수는 왼쪽값이지만 `10`이나 `2 * i`와 같은 표현식은 왼쪽값이 아니다. 당장 우리가 아는 선에선 변수만이 왼쪽값이다. 변수 이외의 왼쪽값은 추후 단원에서 다룬다.

할당연산자가 좌피연산자로 왼쪽값을 필요로 하기 때문에 왼쪽값이 아닌 표현식을 할당연산자의 좌피연산자로 사용할 수 없다.

```c
12 = i;       /*** 틀림 ***/
i + j = 0;    /*** 틀림 ***/
-i  = j;      /*** 틀림 ***/
```

컴파일러는 이와 같은 에러를 발견하여 "invalid lvalue in assignment"와 같은 에러 메세지를 출력할 것이다.

#### 복합할당

한 변수를 그 변수를 이용하여 새로운 값을 변수에 할당하기 위해 사용되는 할당은 C에서 자주 사용되는 할당이다. 다음 구문을 보자. `i`의 값에 2를 더하고 싶다고 하자.

```c
i = i + 2;
```

C의 **복합할당compound assignment** 연산자는 위와 같은 코드를 줄여준다. `+=` 연산자를 통해 위의 코드를 간단하게 다음과 같이 쓸 수 있다.

```
i += 2;    /* i = i + 2 와 같다 */
```

`+=` 연산자는 우피연산자의 값을 왼쪽에 있는 변수에 더해준다.

복합할당연산자는 총 아홉개이며, 아래와 같은 연산자들이 존재한다.

`-=`,  `*=`, `/=`, `%=`

이 이외의 복합할당연산자는 추후 단원에서 다루도록 하겠다. 다른 복합할당연산자들도 위의 예시와 동일한 성격으로 작동한다.

- `v += e` `e`에 `v`를 더하고 그 값을 `v`에 저장한다.
- `v -= e` `v`에서 `e`를 빼고 그 값을 `v`에 저장한다.
- `v *= e` `v`를 `e`만큼 곱하고 그 값을 `v`에 저장한다.
- `v /= e` `v`를 `e`로 나누고 그 값을 `v`에 저장한다.
- `v %= e` `v`를 `e`로 나누었을 때의 나머지를 `v`에 저장한다.

`v += e`와 `v = v + e`는 엄연히 다른 구문이다. 두 구문이 같지 않은 이유는 우선 연산순서 문제가 있다. `i *= j + k`는 `i = i * j + k`가 아니다. 이 뿐만 아니라 `v` 자체에 부작용이 있어 `v += e`와 `v = v + e`가 서로 다른 경우가 있다. 이는 다른 복합할당연산자에도 해당하는 주의점이다. **[Q&A]**

> **[!!!]**
>
> 복합할당연산자를 사용할 때 연산자를 구성하는 두 연산자를 서로 혼동하지 않도록 하자. 두 문자를 바꾸면 컴파일러한테는 상관 없지만 의도한 의미를 잃게 된다. 예를 들어 `i += j`라고 적어야하는데 `i =+ j`라고 적었다고 가정해보자. 프로그램은 정상적으로 컴파일은 될 것이지만 후자 표현식은 `i = (+j)`와 같은 의미이므로 사실상 `i`에 `j`의 값을 할당하는 것이다.

복합할당연산자는 `=` 연산자와 같은 순서를 가진다. 또한 우향결합적이다. 즉, 구문

```
i += j += k;
```

은 다음과 같다.

```
i += (j += k);
```



### 4.3 증감연산자

변수에 가해지는 가장 흔한 두 가지 연산은 1을 더하는 "증가"과 반대로 1을 빼는 "감소" 연산이다. 물론 이러한 연산을 다음과 같이 행할 수 있다.

```
i = i + 1;
j = j - 1;
```

복합할당연산자를 활용하여 코드를 좀 더 압축할 수 있다.

```
i += 1;
j -= 1;
```

C 언어에서는 이러한 증감을 더 간단하게 표현할 수 있게 해준다. 바로 **증가increment**연산자 `++`와 **감소decrement**연산자 `--`를 통해서이다. **[Q&A]**

한 눈에 증감연산자는 매우 간단하다는 것을 알 수 있다. `++`는 피연산자에 1을 더하고 `--`는 1 을 뺀다. 불행하게도 증감연산자는 그 단순함에 비해 사용하기 까다롭다. 한 가지 복잡함이 발생하는 이유는 `++`와 `--`이 `++i`나 `--j`처럼 **전위prefix**연산자로 쓰이거나 `i++`나 `j--`처럼 **후위postfix**연산자로 사용될 수 있다는 것이다. 알맞은 버전을 찾아야 프로그램의 정확성이 보장된다.

또다른 문제는 할당연산자처럼 `++`와 `--`는 부작용이 있다. 즉 피연산자의 값을 바꾼다. "우선증가"인 표현식 `++i`를 해석해보면 `i + 1`을 `i`로 넘기는데, 부작용에 의해 `i`의 값이 증가된다.

```
i = 1;
printf("i의 값은 %d\n", ++i);    /* "i의 값은 2"를 출력한다. */
printf("i의 값은 %d\n", i);      /* "i의 값은 2"를 출력한다. */
```

"이후증가" 표현식인 `i++`은 결과값 `i`를 내보내지만 이후에 `i`는 증가된다.

```
i = 1;
printf("i의 값은 %d\n", i++);    /* "i의 값은 1"를 출력한다. */
printf("i의 값은 %d\n", i);      /* "i의 값은 2"를 출력한다. */
```

첫번째 `printf`은 `i`가 증가되기 이전 본래 값을 출력했다. 두번째 `printf`은 새 값을 출력했다. 위의 예시들이 보여주듯 `++i`는 "당장 증가해"라는 뜻이고, `i++`는 "지금은 원래 값 쓰고 나중에 증가해"라는 뜻이다. 그렇다면 나중에가 언제일까? C 표준은 정확한 시간을 명시해놓고 있지 않다. 그렇기 때문에 `i`는 다음 구문이 실행되기 이전에 증가된다고 생각하는 것이 안전하다. **[Q&A]**

`--` 연산자는 비슷한 속성을 갖고 있다.

```
i = 1;
printf("i의 값은 %d\n", --i);    /* "i의 값은 0"를 출력한다. */
printf("i의 값은 %d\n", i);      /* "i의 값은 0"를 출력한다. */
i = 1;
printf("i의 값은 %d\n", i--);    /* "i의 값은 1"를 출력한다. */
printf("i의 값은 %d\n", i);      /* "i의 값은 0"를 출력한다. */
```

`++`나 `--`이 같은 표현식에서 여러 번 사용한 결과는 대부분 이해하기가 어렵다. 다음 구문을 예시로 들어보자.

> i = 1;
> j = 2;
> k = ++i + j++;

이 구문이 실행된 이후 `i`, `j`와 `k`의 값은 얼마일까? `i`는 쓰이기 이전에 증가 됐고 `j`는 사용된 다음에 증가되었으므로 다음과 같다.

> i = 1 + 1;
> k = i + j;
> j = j + 1;

즉 `i`, `j`와 `k`의 값은 순서대로 2, 3, 4이다. 반대로 다음 구문을 실행한다고 해보자.

> i = 1;
> j = 2;
> k = i++ + j++;

다음 구문에 의하면 `i`, `j`, `k`는 순서대로 2, 3, 3이다.

연산자의 순서를 확인해보자면 `++`와 `--`의 **후위연산자는 단항연산자보다 더 순서가 삐르며** **좌향결합적**이다. **전위연산자는 단항연산자와 같은 순서를 가지며 우향결합적**이다.

### 4 표현식 평가

| 순서 | 이름                 | 기호                                                  | 결합방향 |
| :--- | :------------------- | :---------------------------------------------------- | :------- |
| 1    | 증감(후위)           | `++`<br />`--`                                        | 좌향     |
| 2    | 증감(전위), 단항음양 | `++`<br />`--`<br />`+`,<br />`-`                     | 우향     |
| 3    | 곱셈                 | `*`,<br />`/`<br />`%`                                | 좌향     |
| 4    | 덧셈                 | `+`<br /> `-`                                         | 좌향     |
| 5    | 할당                 | `=`<br />`*=`<br />`/=`<br />`%=`<br />`+=`<br />`-=` | 우향     |

[표 4.2] 일부 C 연산자 표

[표 4.2]는 현재까지 다룬 연산자들을 전부 다루고 있다. 부록 A에서 모든 연산자를 다루는 표를 확인해볼 수 있다. 첫번째 열은 연산자 평가 순서를 의미한다. 마지막 열은 각 연산자의 결합 방향을 의미한다.

[표 4.2] 혹은 부록 A의 표를 통하여 연산자를 다양하게 사용해볼 수 있다. 이제 아래의 예시를 한 번 보도록 하자. 아래와 같이 복잡한 표현식을 실행해본다고 하자.

```c
a = b += c++ - d + --e / -f
```

이 표현식은 괄호가 없어 가독성이 상당히 떨어진다. [표 4.2]를 이용하여 이 표현식에 괄호를 붙여보도록 하겠다. 우선 순위가 높은 것부터 시작해서 괄호로 연산자와 피연산자를 묶어주어 마치 하나의 피연산자로 처리하겠다. 이 과정을 표현식이 완벽하게 처리될 때까지 반복하겠다.

본 예시에서 가장 우선 순위를 띠는 연산자는 후위 `++` 연산자이다. 괄호를 추가해주자.

```c
a = b += (c++) - d + --e / -f
```

다음은 전위 `--` 연산자와 단항음수연산자이다.

```c
a = b += (c++) - d + (--e) / (-f)
```

다른 음수 기호는 왼쪽에 피연산자가 있어 단항음수연산자가 아닌 뺄셈연산자임을 인식해야한다.

다음은 `/` 연산자이다.

```c
a = b += (c++) - d + ((--e) / (-f))
```

이 표현식엔 4 순서 연산자 뺄셈과 덧셈 두 개를 포함하고 있다. 두 연산자가 같은 순서를 갖고 한 피연산자를 공유하고 있다면, 결합성에 유의해야한다. 우리의 예제에선 `-`와 `+` 둘 다 `d`를 공유하고 있으므로 결합방향을 고려해야한다. `-`와 `+` 연산자는 왼쪽에서 오른쪽으로 결합을 하므로 괄호는 뺄셈 먼저, 그 뒤에 덧셈을 처리한다.

```
a = b += (((c++) - d) + ((--e) / (-f)))
```

마지막으로 `=`와 `+=`를 처리해주자. 두 연산자는 서로 `b`를 공유하고 있으므로 결합방향을 확인해주자. 할당연산자는 오른쪽에서 왼쪽으로 괄호로 묶으므로 `+=`로 먼저 묶고 다음에 `=`로 묶는다.

```
(a = (b += (((c++) - d) + ((--e) / (-f)))))
```

이제 표현식이 완벽하게 괄호로 묶였다.

#### 값을 표현할 때의 부분식의 순서

C 언어에선 연산자 순서 및 결합법칙을 이용하여 표현식을 부분식으로 나눌 수 있다. 이 부분식은 괄호의 위치를 이용하여 생성할 수 있다. 모순적이게도 이 법칙이 언제나 표현식의 값을 결정하지 않는다. 이는 부분식이 어떤 순서로 평가되는지에 따라 달라질 수 있다.

C는 부분식이 어떤 순서로 평가되는지 정의하지 않는다. (이는 논리연산자 and, or, 조건 및 쉼표연산자를 제외한다) 즉 표현식 `(a + b) * (c - d)`의 식에선 `(a + b)`가 먼저 평가되는지 `(c - d)`가 먼저 평가되는지 모른다.

대부분의 표현식은 부분식이 평가되는 순서와 상관없이 같은 값을 갖는다. 허나 부분식이 피연산자를 수정하는 경우 이는 달라질 수 있다. 다음 예시로 확인해보자.

```
a = 5;
c = (b = a + 2) - (a = 1);
```

두번째 구문의 실행은 정의되지 않는다. C 표준을 뒤져봐도 이에 대한 해답은 나오지 않는다. 대부분의 컴파일러의 경우 `c`의 값은 6이거나 2일 것이다. 만약 부분식 `(b = a + 2)`를 먼저 평가했다면 `b`는 7이고 `c`는 6이다. 하지만 `(a = 1)`를 먼저 평가했다면 `b`는 3이고 `c`는 2이다.

> **[!!!]**
>
> 표현식 내에서 변수의 값에 접근하고 수정하는 과정이 일어나는 표현식은 지양하는 것이 좋다. 표현식 `(b = a + 2) - (a = 1)`에서 `(a + 2)`를 처리해주기 위해 `a`의 값에 접근하고 이 뿐만 아니라 `a`에 1을 할당해주어 `a`의 값을 바꾸기가지 한다. 몇몇 컴파일러는 위와 같은 표현식을 받으면 "`a`에 대한 작업이 정의되지 않았을 수도 있다"라는 경고 메세지를 생성해낼 수도 있다.

이러한 문제를 방지하기 위해 부분식에선 할당연산자를 지양하는 것이 좋다. 할당을 한 줄에서 진행하지 않고 여러 줄에 걸쳐 진행하는 것이 좋다. 위의 코드는 다음과 같이 다시 짤 수 있다.

```c
a = 5;
b = a + 2;
a = 1;
c = b - a;
```

본 표현식이 실행되면 `c`의 값은 언제나 6일 것이다.

할당연산자 이외에 피연산자의 값을 수정하는 연산자는 증감연산자다. 이 연산자를 사용할 땐 표현식의 평가가 어떤 특정 순서를 따르지 않는다는 사실을 명심해야한다. 다음 예시에선 `j`의 값이 두 가지가 나올 수 있다.

```c
i = 2;
j = i * i++;
```

`j`의 값이 4라고 생각하기 십상이지만, 구문이 실행될 때의 절차는 정의되지 않았으므로 `j`에 6이 할당될 수도 있다. 6이 나오는 절차는 다음과 같다. (1) 두번째 피연산자인 `i`의 본래 값을 선택하고 `i`를 증가한다. (2) 첫번째 피연산자인 새로운 `i`의 값이 선택되고 본래 `i`값과 곱해진다. (3) 본래 값과 새 값이 곱해지고 결과는 6이 나온다. 변수를 "선택한다Fetching"는 것은 메모리로부터 변수의 값을 갖고 오는 것을 의미한다. 나중에 변수에 가해진 변화는 선택된 값에 영향을 주지 않는다. 여기서 선택된 값은 보통 **레지스터register**라고 불리는 CPU 내의 특수한 공간에 보관된다.

> **정의되지 않은 행동 / 불능행동**
>
> C 표준에 의하면 `c = (b = a + 2) - (a = 1);`와 `j = i * i++;`와 같은 표현식은 **불능행동undefined behavior**을 초래한다고 한다. 여기서 불능행동은 4.1절에서 다뤘던 시행정의행동과는 다르다. 프로그램이 불능행동의 세계로 떠나게 된다면 거기서 벌어질 일들은 예측할 수 없다. 프로그램이 컴파일러마다 서로 다른 결과값을 내놓을 것이다. 헌데 이것만 일어나는 것도 아니다. 애초에 컴파일 자체가 안되거나, 컴파일은 되는데 실행이 안될 수도 있고, 실행이 되더라도 오류로 프로그램이 중단되거나, 이상하게 행동하거나, 의미없는 값만 내보낼 수도 있다. 다시말해 불능행동은 마치 역병처럼 피해야하는 것이다.

### 5 표현문

C에선 모든 표현식은 구문으로 사용될 수 있다는 특이한 규칙이 있다. 즉, 무슨 형식이든, 무슨 값을 처리하든 모든 표현식에 세미콜론`;`을 추가함으로써 구문으로 만들어줄 수 있다는 것이다. 예를 들어 표현식 `++i`를 구문으로 다음과 같이 바꿔줄 수 있다.

```c
++i;
```

이 구문이 실행되면 `i`는 증가되고, 증가된 새로운 `i`의 값이 마치 다음 표현식에 사용되려는 듯이 선택된다. 허나 `++i`는 더 큰 표현식의 부분식이 아니기 때문에 선택된 값은 버려지고 다음 구문이 실행될 것이다. 물론 바뀐 `i`의 값은 그대로 유지될 것이다. **[Q&A]**

`++i`의 선택된 값이 무시되었기 때문에 표현식이 부작용이 있지 않는 한 굳이 표현식을 구문처럼 사용할 필요성이 없다. 다음 세 가지 예시를 살펴보자. 첫번째 예제에선 `i`에 1을 저장해주었다. 그 뒤 `i`의 새로운 값인 1이 선택되지만 아무데도 사용되지 않는다.

```c
i = 1;
```

두번째 예제에선 `i`의 값이 선택되지만 사용되지 않는다. 하지만 `i`는 그 다음에 감소된다.

```c
i--;
```

세번째 예제에선 표현식 `i * j - 1`의 값이 계산되고, 그 이후에 버려진다.

```c
i * j - 1;
```

`i`와 `j`는 바뀌지 않았기 때문에 이 구문은 아무 영향이 없으므로 아무 의미가 없는 구문이다.

> **[!!!]**
>
> 코딩하다가 손가락 잘못 놀리면 "아무 의미 없는" 표현문expression statement이 만들어진다. 예를 들어
>
> ```c
> i = j;
> ```
>
> 라고 작성하지 않고 실수로
>
> ```c
> i + j;
> ```
>
> 라고 실수로 작성할 수도 있다. 이러한 실수는 생각보다 자주 발생한다. `=`와 `+`가 같은 키보드 키이기 때문에 발생하는 실수다. 몇몇 컴파일러는 무의미한 표현문을 감지할 수 있다. "무의미한 구문statement with no effect"이라고 적힌 에러를 발생시킨다.

### Q & A

#### C 언어는 지수연산자가 없던데 그러면 제곱연산을 할 수 있죠?

정수를 작은 양의 정수만큼 제곱하는 건 쉬워요. 그만큼 곱해주면 되거든요. 예를 들어 `i` 세제곱을 하려면 `i * i * i`를 하면 돼요. 근데 만약 정수가 아닌 숫자만큼 제곱을 할거면 `pow`라는 함수가 필요할거예요.

#### `%` 연산자를 고정소수 피연산자에도 적용하고 싶은데 컴파일이 안되네요. 어떻게 해야하죠? [산술연산자]

`%` 연산자는 정수 피연산자를 필요로 해요. 차라리 `fmod`를 써보는 건 어때요?

#### `/`와 `%` 연산자를 음수연산자랑 같이 사용하는 규칙이 왜 그리 복잡한가요? [산술연산자]

사실 그렇게 복잡하지는 않아요. C89나 C99 둘 다 목표는 `(a / b) * b + a % b`의 값이 언제나 `a`와 같도록 하는거에요. 그리고 두 표준 모두 `a / b`가 정상representable이면 위의 상황은 언제나 성립해요. 문제는 `a / b`랑 `a % b`가 만약 둘 중 하나라도 음수면 위의 항등식을 만족시키는데 두 가지 방법이 있다는 거예요. C89에서 `-9 / 7`는 `-1` 이거나 `-2`이고 `-9 % 7`는 `-2`이거나 `5`이었잖아요? 첫번째 경우 `(-9 / 7) * 7 + -9 % 7`의 값은 -1 × 7 + -2 = -9이고, 두번째 경우엔 `(-9 / 7) * 7 + -9 % 7`가 -2 × 7 + 5 = -9라는 값이 나와요. **[C99]** C99이 나왔을 즈음엔 대부분의 CPU가 위와 같은 상황일 땐 값을 0과 가까운 값으로 선택하게 설계되었어요. 그러므로 C99엔 오로지 한 가지 결과만 나오죠.

#### C가 왼쪽값이 있다면, 오른쪽값도 있나요? [왼쪽값]

암요. 왼쪽값은 할당의 왼쪽에서 나타날 수 있는 표현식을 의미하고, 오른쪽값은 반대로 오른쪽에서 나타날 수 있는 표현식이에요. 즉, 오른쪽값은 변수, 상수, 혹은 좀 더 복잡한 표현식이 될 수 있겠죠? 이 책에서는 C 표준대로 오른쪽값이 아니라 표현식이라는 용어를 사용할 거예요.

#### `v`가 부작용이 있으면 `v += e`가 `v = v + e`와 동일하지 않다고 했는데, 이게 무슨 뜻인가요? [복합할당]

`v += e`를 평가할 때엔 `v`가 딱 한 번 평가가 돼요. 반면에 `v = v + e`에선 `v`를 두 번 평가해야되죠. `v`를 평가할 때 발생하는 모든 부작용은 후자의 경우에 두 번 발생하겠죠? 다음 예시를 볼까요?

```c
a[i++] += 2;
```

`+=` 대신에 `=`를 사용한다면 다음과 같이 코드를 짤 수 있을겁니다.

```c
a[i++] = a[i++] + 2;
```

`i`의 값은 구문에서변형이 되면서 동시에 구문에서 사용되고 있어요. 즉, 구문을 실행한 효과는 정의되지 않았어요. `i`의 값이 두 번 증가될 거라고 예상할 수는 있겠지만, 확실히 무슨 일이 일어날지는 모르는거예요.

#### C가 굳이 `++`와 `--` 연산자를 제공하는 이유가 뭐죠? 다른 증감연산보다 더 빠른가요? 아니면 그냥 편의인가요? [증감연산자]

C의 증감연산자는 켄 톰슨의 B 언어로부터 이식된 거예요. 톰슨이 이러한 연산자를 만든 이유는 B 컴파일러가 `i = i + 1`보다 `++i`에 대해 좀 더 구체적인 번역이 가능해서예요. 이 연산자들은 C에 그대로 이식이 되었죠. 사실 많은 C 관련 관용구들도 여기서 많이 생겼어요. 요즘 컴파일러에서 사실 `++`나 `--`를 쓴다고 해서 컴파일된 프로그램이 더 빨라지거나 용량을 적게 만들어주지는 않아요. 아직도 이 연산자를 사용하는 이유는 사실 사용하기 편해서죠.

#### `++`랑 `--`는 `float` 변수에도 적용되나요?

그럼요. 증감연산자는 정수 뿐만 아니라 고정소수에도 적용돼요. 하지만 실생활에선 `float` 변수를 증감하는 건 그렇게 자주 사용하지는 않아요.

#### `++`와 `--`를 후위로 사용할 때 정확하게 언제 증감이 적용되는거죠? [증감연산자]

엄청 훌륭한 질문이네요! 근데 답하기는 사실 어려운 질문이기도 해요. C 표준에 의하면 C 언어에는 "순서지점sequence point"이라는 개념이 있는데요, 피연산자에 저장된 값을 바꾸는 건 이전 순서 지점이랑 그 다음 순서 지점 중간에 이뤄진다고 해요. C에는 수많은 순서지점들이 있는데요, 한 예로는 표현문의 끝 지점을 들 수 있어요. **표현문이 끝날 때**가 되면 반드시 그 구문에 있는 증감연산은 전부 실행이 되었어야 합니다. 이게 실행이 안되면 그 다음 구문이 실행이 안돼요.

나중에 우리가 다룰 몇가지 연산자들(논리곱, 논리합, 조건, 쉼표) 또한 순서지점을 갖고 있어요. 함수호출도 마찬가지로 갖고 있어요. 함수호출을 할 때 입력변수argument가 완벽하게 평가되지 않는 한 함수호출은 실행되지 않아요. 만약 **입력변수가 `++`나 `--` 같은 연산자가 있는 표현식이라면 증감연산이 실행되기 전까지 함수호출은 실행되지 않아요.**

#### 표현문의 값이 버려진다는 게 정확히 무슨 뜻인가요? [표현문]

정의에 의하면 표현식은 값을 나타낸다고 해요. 만약 `i`가 5라는 값을 갖고 있다고 합시다. 그러면 `i + 1`를 평가하면 6이라는 값을 생성해낼거예요. 그럼 이 `i + 1` 뒤에 세미콜론을 넣어서 구문으로 만들어 볼게요.

```c
i + 1;
```

이 구문이 실행이 되면 `i + 1`의 값이 계산이 될거예요. 근데 계산한 이 값을 어디에 저장하지도, 어딘가에 사용하지도 않았으니까 그 값은 버려지겠죠.

#### 그럼 `i = 1;`와 같은 구문은요? 얘네들도 값이 버려지는건가요?

C에선 `=`도 연산자라는 것을 까먹으면 안돼요. 즉, 연산자이기 때문에 다른 연산자들이 그러듯, 값을 생성해내요. 예시로 직접 보죠.

```c
i = 1;
```

위 할당에 의하면 `i`에 1을 저장하겠죠? 여기서 전체 구문의 값은 1이 되고, 이 값은 버려지게되죠. 표현식의 값을 버리는 건 크게 문제되는 부분이 아니예요. 애초에 저 구문을 적는 이유는 `i`의 값을 수정하려고 작성한거지, 구문의 값을 어디 써먹으려고 작성한건 아니잖아요?

