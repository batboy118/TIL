# 4. Expressions

 C 언어의 특징 중 하나는 바로 구문보다 표현식을 엄청 중시한다는 것이다. 여기서 **표현식이란 어떠한 값을 계산하는 식을 말하는 것이다.** 가장 간단한 형식의 표현식은 바로 **변수와 상수**이다. 변수란 프로그램이 실행되었을 때 계산되는 값을 의미하고, 상수는 변하지 않는 값을 의미한다. 복잡한 표현식에는 피연산자에 연산자를 포함시킨다. 이 때 **피연산자는 자기 자신이 곧 표현식**이다. 표현식 `a + (b * c)`에는 `+` 연산자는 피연산자 `a`와 `(b * c)`에 적용되어있고, 이 **두 피연산자는 자기 자신이 곧 표현식**이기도 하다. **연산자는 표현식을 만드는 기본적인 도구**이다, C 언어는 특이하게도 매우 많은 연산자가 있는 언어이다. 우선 C는 대부분의 프로그래밍 언어가 갖는 기초적인 연산자들이 있다.

- **산술연산자(Arithmetic Operators)** - 덧셈, 뺄셈, 곱셈과 나눗셈을 의미한다.
- **관계연산자(Realtional Operators)**- `i`는 `0`보다 크다"와 같은 **비교** 등을 행할 때 사용하는 연산자이다.
- **논리연산자(Logical Operators)** - "`i`는 `0`보다 크고 `i`는 `0`보다 작다"와 같은 **조건을 만드는 데 필요한 연산자**이다.

C는 이 세 가지 이외에도 수많은 연산자들이 있다. 연산자가 너무 많아 이 책의 첫 20단원까지 순서대로 다뤄야할 정도이다. 연산자를 완벽하게 익히는 것은 매우 힘들지만, C를 잘 사용하려면 필수이다.

이 단원에선 C의 가장 중요한 연산자인 산술 연산자(4.1 단원), 할당 연산자(4.2 단원), 증감 연산자(4.3 단원)를 다룰 것이다. 4.1 단원에선 연산자들 사이의 순서 법칙과 결합 법칙을 다룰 것이다. 연산자가 여러 개인 표현식에서 순서와 결합은 매우 중요하다. 4.4 단원에선 C 표현식이 어떻게 평가되는지를 배울 것이다. 마지막으로 4.5 단원에선 표현식 구문을 배울 것이다. 이는 표현식을 구문 취급하는 매우 특이한 기능이다.



### 4.1 산술연산자

산술 연산자arithmetic operator란 덧셈, 뺄셈, 곱셈, 나눗셈 등을 하는 연산자이다. 산술 연산자는 C를 포함한 대부분의 프로그래밍 언어에서 가장 많이 사용되는 기능 중 하나이다. 표 4.1에서 C의 산술 연산자를 다루고 있다.

| 단항 연산자      | 이항 연산자 |
| :--------------- | :---------- |
| +  양수임을 강조 | + 덧셈      |
| - 음수 표현      | - 뺄셈      |
|                  | * 곱셈      |
|                  | / 나눗셈    |
|                  | % 나머지    |

**[표 4.1]**

덧셈류와 곱셈류 연산자들은 두 개의 피연산자를 필요로 하기 때문에 이항binary이라고 불린다. 단항unary 연산자는 한 개의 피연산자를 필요로 한다.

```c
i = +1; /* + 는 여기서 단항 연산자로 쓰임 */
j = -1; /* - 는 여기서 단항 연산자로 쓰임 */
```

단항 `+` 연산자는 사실 아무것도 하지 않으며, 사실 K&R C에서도 존재하지 않는다. 이 표현은 그냥 어떤 상수가 **양수임을 강조**하기 위해 사용한다.

이항 연산자는 좀 더 친숙하게 다가올 것이다. 아마 위의 표에서 제일 익숙하지 않은 연산자는 나머지 연산자인 `%` 연산자일 것이다. `i % j`의 값은 `i`를 `j`로 나눴을 때의 나머지이다. 예를 들어 `10 % 3`의 값은 `1`이고 `12 % 4`의 값은 `0`일 것이다.

**[Q&A]** 표 4.1에서 나오는 이항 연산자 중 `%`를 제외하면 정수와 실수형 피연산자를 둘 다 허용하고, 섞어서 사용하는 것 또한 허용한다. 만약 `int`와 `float`형 피연산자가 동시에 사용되었다면 결과는 `float`형으로 나올 것이다. 그렇기 때문에 `9 + 2.5f`의 결과값은 `11.5`이고 `6.7f / 2`의 결과값은 `3.35`이다.

`/` 연산자와 `%` 연산자는 특수하게 다루어주어야 한다.

- `/` 연산자는 예상하지 못한 결과를 생성할 수도 있다. 만약 피연산자가 둘 다 정수라면, `/` 연산자는 소수점 부분을 삭제함으로서 결과값을 줄여 정수로 만든다. 즉, `1 / 2`의 값은 `0.5`가 아니라 `0`이 나온다.
- `%` 연산자는 피연산자가 정수여야한다. 만약 피연산자가 정수가 아니라면 컴파일되지 않는다.
- `/`이나 `%`를 사용할 때 `0`을 우항 피연산자로 사용하는 경우 예상하지 못한 결과가 나올 수 있다.
- **[Q&A]** `/`이나 `%`이 음수 피연산자와 함께 사용하게 되면 결과를 표현해주기가 매우 힘들다. C89 표준에 의하면 두 개의 피연산자 중 하나라도 음수면 나눗셈의 결과값은 반올림 되거나 반내림 될 수 있다고 되어있다. 예를 들면 `-9 / 7`의 값이 `-1`이거나 `-2`가 될 수 있다. 만약 `i`나 `j`가 음수라면 C89에서 `i % j`는 사용하는 방법에 따라 다르다. 예를 들어 `-9 % 7`은 `-2`거나 `5`가 될 수 있다. **[C99]** C99에선 나눗셈의 결과가 언제나 `0`과 가장 가까운 값을 갖는다. 즉 `-9 / 7`의 값은 `-1`이고, `i % j`의 경우 결과값의 부호는 `i`를 따라간다. 즉 `-9 % 7`은 `-2`이다.

> **[시행정의행동]** 시행정의implementation-defined라는 말을 앞으로 많이 듣게 될 것이기에, 이 즈음에서 한 번 다뤄보도록 하겠다. C 표준은 의도적으로 언어의 일부분을 확실하지 않게 남겨두고, "시행implemenation"이라는 것, 즉 소프트웨어가 어떠한 특정 플랫폼에서 컴파일하고, 링크하고, 실행해야할 프로그램을 통해 그 확실하지 않은 부분을 채운다. 결과적으로 프로그램의 실행 결과는 시행에 따라 달라질 것이다. C89에서 음수 피연산자를 사용했을 때의 `/`이나 `%`의 결과가 시행으로 정의되는 행동의 예이다.
>
> 언어의 일부를 구체적으로 설명해주지 않는 것은 매우 이상하고 심지어는 위험해보이는 행동이지만, 이는 C의 철학을 보여준다. C 언어의 중요한 목표 중 하나는 효율성이고, 효율성이란 하드웨어에 따라 방법을 맞춰주는 것을 의미하기도 하다. 어떤 CPU는 `-9`가 `7`로 나눠질 때 `-1`를 결과값으로 내보내고, 어떤 CPU는 `-2`로 내보낸다. C89 규격은 그저 인생의 진리를 그대로 보여주고 있을 뿐이다.
>
> 되도록이면 이러한 시행정의행동을 기피하는 것이 좋다. 만약 피할 수 없다면, 적어도 매뉴얼을 잘 살펴보라. C 표준은 시행정의행동을 서류화하고 싶어한다.

#### 연산자 순서 및 결합 법칙

한 표현식이 한 개 이상의 연산자를 갖고 있는 경우, 이를 단번에 해석하기란 어려울 수 있다. `i + j * k`라는 구문이 "`i`랑 `j` 더하고, 그 값을 `k`랑 곱하라"는 뜻인지, "`j`랑 `k` 곱하고 거기에 `i`를 더해라"는 뜻인지 어떻게 알 수 있는가? 가장 손쉬운 해결방법은 괄호를 사용하는 것이다. `(i + j) * k`라고 적거나 `i + (j * k)`라고 적어주는 것이다. C 언어는 표현식을 괄호로 묶는 것을 일반적인 규칙으로 허용한다.

만약 괄호를 쓰지 않는다면 어떻게 해야될까? 컴파일러는 `i + j * k`를 `(i + j) * k`로 해석할까 아니면 `i + (j * k)`로 해석할까? 다른 언어들과 마찬가지로 C는 연산자순서 규칙을 정해놓아 이러한 모호함을 해결한다. 산술연산자는 다음과 같은 상대적 순서가 존재한다.

순서 높음: `+` `-` (단항) `*` `/` `%` 순서 낮음: `+` `-` (이항)

`+`와 `-`처럼 같은 줄에 있는 연산자들은 동일한 순서이다.

한 표현식에 두 개 이상의 연산자가 존재하는 경우 컴파일러는 높은 순서 연산자부터 시작해서 표현식을 괄호로 계층화해서 해석한다. 다음 예시를 보라.

`i + j * k` 는 `i + (j * k)` 와 같다. `-i * -j` 는 `(-i) * (-j)` 와 같다. `+i + j / k` 는 `(+i) + (j / k)` 와 같다.

연산자 순서 규칙으로는 사실 충분하지 않다. 만약 동일 순서의 연산자들이 여러개가 한 표현식에 존재한다면 어떤식으로 표현식을 처리해야하는가? 이런 상황에서는 연산자의 결합을 사용하게 된다. 왼쪽에서 오른쪽으로 결합한다면 좌향결합적이라고 부른다. 이항산술연산자는 전부 좌향결합적이다. 즉,

`i - j - k` 는 `(i - j) - k` 와 같다. `i * j / k` 는 `(i * j) / k` 와 같다.

반대로 오른쪽부터 왼쪽으로 결합한다면 우향결합적이라고 한다. 단항산술연산자가 우향결합적이다. 즉,

`- + i` 는 `-(+i)`와 동일하다.

순서와 결합 법칙은 물론 많은 언어에서 중요한 개념이지만, 특히나 C 언어에서는 더더욱 중요하다. 단, C 언어엔 50 가지 이상의 연산자가 있어 이에 대한 순서와 결합 법칙을 외우는 프로그래머는 매우 드물다. 차라리 확실하지 않으면 검색을 해서 순서 및 결합 법칙 도표를 참고하거나 괄호를 사용하자.

#### [프로그래밍] 세계상품코드(UPC) 검사 기호 계산하기

몇년간 미국과 캐나다에 제품을 판매하는 제조업자들은 각 제품에 바코드를 찍기 시작했다. 이 코드는 세계상품코드(UPC)라고도 알려져있는데, 제품과 제조업자에 대한 정보를 담고있다. 각 바코드는 12자리의 숫자이며 주로 바코드 선 아래에 적혀있다. 예를 들어 Stouffer's French Bread 페페로니 피자 패키지의 바코드는 다음과 같이 생겼다.

[바코드 사진]

바코드에 적혀있는 숫자인

```
0 13800 15173 5
```

는 바코드 선 밑에 적혀있다. 첫번째 자리는 제품의 유형을 나타낸다. 대부분의 경우 0 혹은 7이며, 무게를 재야하는 제품의 경우 2, 약이나 건강 관련 제품은 3, 쿠폰은 5이다. 첫 5개의 숫자들은 제조업자를 의미한다. 13800은 네슬리 미국 냉동식품지사를 의미한다. 두번째 5개의 숫자들은 제품을 의미하고, 이는 패키지 사이즈도 포함한다. 마지막 숫자는 "확인자릿수"로, 앞의 11개의 숫자가 제대로 적혀있는지 확인하는 수이다. 만약 UPC가 제대로 스캔이 되지 않았다면 첫 11 개의 숫자들이 마지막 확인자릿수와 무관할 수 있어 상점의 바코드 스캐너는 전체 코드를 인식하지 않을 수 있다.

확인자릿수를 계산하는 방법은 다음과 같다.

1. 홀수번째 숫자를 더한다
2. 짝수번째 숫자를 더한다 (마지막 12번째는 제외)
3. 첫번째 합을 3만큼 곱하고 두번째 합과 더한다
4. 전체 합에서 1을 뺀다
5. 결과값을 10으로 나눴을 때의 나머지를 구한다
6. 9에서 이 나머지를 뺀다

Stouffer's를 이용해 실제 값을 구해보자. 첫번째 합은 0 + 3 + 0 + 1 + 1 + 3 = 8이고, 두번째 합은 1 + 8 + 0 + 5 + 7 = 21이다. 첫번째 합을 3만큼 곱하고 두번째 합과 더하면 45가 나온다. 여기에 1을 빼면 44가 된다. 10으로 나눈 나머지는 4이다. 이 나머지를 9에 빼면 답은 5가 나온다. 아래는 다른 UPC의 예시이다. 만약 직접 확인자릿수를 계산해보고 싶다면 해보라.

Kif Creamy 땅콩버터(18 oz.): 0 51500 24128 ? Ocean Spray 크랜베리젤리소스(8 oz): 0 31200 01005 ?

정답은 8과 6이다.

이제 아무 UPC의 확인자릿수를 계산해주는 프로그램을 작성해보자. 우선 사용자로 하여금 11자리의 숫자를 입력하도록 하고, 이에 해당하는 확인자릿수를 출력해준다. 혼동을 피하기 위해 사용자는 첫번째 숫자, 두번째 5자리 숫자, 세번째 5자리 숫자를 따로따로 세 가지의 값을 입력하게 만든다. 이 프로그램이 다음과 같이 생겼다고 해보자.

```
첫번째 (한자리수) 숫자를 입력해주세요: 첫번째 (한자리수) 숫자를 입력해주세요: 0
첫번째 다섯자리 숫자를 입력해주세요: 13800
두번째 다섯자리 숫자를 입력해주세요: 15173
확인자릿수: 5
```

두 다섯자리 숫자를 정말로 다섯자리 숫자로 인식하는 것보다는 다섯개의 서로 다른 숫자의 모임으로 인식하도록 하겠다. 숫자를 한 자리 숫자들로 인식하는 것이 사실 더 편하고 다섯자리 숫자는 몇몇 오래된 컴파일러에겐 저장하기에 너무 클 수 있기 때문(정수형이 32,767이 최대일 수도 있다)에 이렇게 해주는 것이 더 좋다. 한 자리만 읽기 위해선 `scanf`와 `%1d` 변환규격을 사용하겠다.

`upc.c`

```
/* UPC의 확인자릿수를 계산함 */

#include <stdio.h>

int main(void)
{
    int d, i1, i2, i3, i4, i5, j1, j2, j3, j4, j5, 
        first_sum, second_sum, total;

    printf("첫번째 (한자리수) 숫자를 입력해주세요: ");
    scanf("%1d", &d);
    printf("첫번째 다섯자리 숫자를 입력해주세요: ");
    scanf("%1d%1d%1d%1d%1d", &i1, &i2, &i3, &i4, &i5);
    printf("두번째 다섯자리 숫자를 입력해주세요: ");
    scanf(%1d%1d%1d%1d%1d", &j1, &j2, &j3, &j4, &j5);

    first_sum = d + i2 + i4 + j1 + j3 + j5;
    second_sum = i1 + i3 + j2 + j4;
    total = 3 * first_sum + second_sum;

    printf("확인자릿수: %d\n", 9 - ((total - 1) % 10));

    return 0;
}
```

표현식 `9 - ((total - 1) % 10)`을 `9 - (total - 1) % 10`으로 적을 수 있음에도 굳이 괄호를 추가해주었다. 이렇듯 괄호는 가독성을 높여준다.