# 2. C Fundamentals

이 단원에선 전처리 지시자preprocessing directive, 함수function, 변수variable, 구문statement 등 간단한 프로그램을 짜기 위해 배워야할 여러 가지 기본적인 내용을 공부한다. 

2.1에선 간단한 프로그램을 통해 이것을 어떻게 `컴파일`을 하고 `링크`하는지 공부할 것이다. 2.2에선 `프로그램을 일반화`하는 방법을 배울 것이고, 2.3에선 `주석`이라 불리는 코드를 설명하는 글귀를 다는 방법을 배울 것이다. 2.4에선 `변수`에 대해서 공부할 것이다. 여기서 변수란 프로그램을 실행했을 때 바뀔 수도 있는 데이터를 저장하는 것이다. 2.5에선 `scanf` 함수를 통해 데이터를 읽고 변수에 저장하는 것을 배울 것이다. 2.6에선 프로그램을 실행해도 바뀌지 않는 데이터인 `상수`에는 이름을 붙이는 법을 배울 것이다. 2.7에선 `식별자`라고 불리는 이름을 만드는 데 필요한 규칙을 배울 것이며, 마지막 소단원인 2.8에선 프로그램의 `레이아웃을 만들 때의 규칙`들을 배울 것이다.




### 2.1 간단한 프로그래밍

#### 아래의 문장을 출력하는 프로그램

> To C, or not to C: that is the question.

이 프로그램의 이름을 `pun.c` 라고 하고, 이 프로그램은 실행될 때 위와 같은 메세지를 전송할 것이다.

```C
//[pun.c]
#include <stdio.h>

int main(void)
{ 
    printf("To C, or not to C: that is the Question.\n"); 
    return 0;
}
```

 `#include`은 C의 표준 입출력 라이브러리에 대한 정보를 첨가include하기 위해 필요한 줄이다. 프로그램에서 사실상 실행되는 코드는 `main`에 존재하고, 말 그대로 대표main 프로그램을 의미한다. `main` 안에 유일한 명령어는 원하는 자료를 출력해주는 `printf`라는 함수이다. `printf`는 표준 입출력 라이브러리에 내장된 함수로, 데이터를 깔끔하게 출력해준다. 어록 뒤에 있는 `\n`는 다음 줄로 넘긴다는 의미이다. 즉, `\n` 다음에 뭔가 더 덧붙인다면, 어록 밑에 덧붙인 데이터가 출력될 것이다. 다음 줄인 ` return 0;`은 프로그램이 종료될 때 운영체제에 0이라는 값을 넘긴다, 혹은 리턴return한다는 것을 의미한다. 

#### 컴파일과 링크

 생각보다 방금 짠 `pun.c` 프로그램은 매우 짧고 간결하지만, 이걸 실제로 실행하는건 생각보다 가벼운 일이 아니다. 우선, `pun.c`의 이름을 갖고 있고, 위의 프로그램의 코드 내용을 갖고 있는 파일을 제작해야 된다. 이 작업은 아무 텍스트 에디터로 할 수 있다. 사실 파일의 이름은 상관이 없지만, 대부분의 컴파일러들은 뒤에 `.c` 확장자명이 있어야 컴파일이 가능하다. 

이제 다음으로 할 일은 이제 이 프로그램을 컴퓨터가 실행할 수 있는 형태로 만들어야된다. C 언어의 경우 보통 다음과 같은 세 가지 과정이 필요하다.

- **전처리Preprocessing.**  : 프로그램은 우선 `전처리기preprocessor`에 보내지는데, 전처리기는 #으로 시작하는 `지시어directive`로 알려진 줄들의 지시를 먼저 따른다. 전처리기는 마치 에디터와 같다고 볼 수 있다. 프로그램에 무언가를 추가하고, 수정을 할 수 있기 때문이다.
- **컴파일Compiling.** : 수정된 프로그램은 이제 `컴파일러compiler`로 보내지는데, 여기서 코드는 기계어 명령문(`목적코드object code`)으로 번역이 된다. 번역을 했지만, 그래도 아직은 프로그램을 실행할 순 없다.
- **링킹Linking. ** : 마지막 단계에선 `링커linke`r가 컴파일에 의해 생성된 목적코드를 프로그램을 완벽하게 실행하기 위해 필요한 추가적인 코드와 합친다. 이 추가적인 코드는 보통 프로그램에 사용되는 라이브러리 내부의 명렁문을 의미한다. 위의 코드를 예시로 들면 `printf`가 되겠다.

 다행히도 이 과정은 전부 자동적으로 처리가 되기 때문에 부담 가질 필요는 없다. 사실 전처리 과정도 컴파일러에 보통 추가되어있어서 사실 전처리가 진행되고 있다는 사실조차 모를 수도 있다.   컴파일과 링크를 하기 위한 명령들은 컴파일러에 따라, 그리고 운영체제에 따라 다르다. UNIX에선 C 컴파일러가 보통 `cc`라고 불리는데, 그렇기 때문에 `pun.c`를 컴파일하기 위해선 터미널이나 커맨드라인창에 다음과 같은 명령문을 입력해야 한다. **`% cc pun.c`**

UNIX에서 %란 프롬프트를 의미한다. 이건 사용자가 입력해야하는 건 아니다. `cc`를 이용하면 링킹은 자동적으로 이뤄진다. 굳이 링크를 위한 또다른 명령문이 필요하지 않다.

 컴파일과 링킹이 끝나면, `cc`는 실행가능한 프로그램을 보통 기본 설정에 따라 `a.out`라는 이름으로 만들어낸다. `cc`에는 다양한 옵션들이 있는데, 그 중에 `-o`라는 옵션은 실행가능한 프로그램을 포함하는 파일의 이름을 바꿀 수 있게 해준다. 예를 들어 위에 `pun.c` 프로그램을 `pun`라는 이름으로 생성하고 싶다면 다음과 같은 명령문을 입력하면 된다.  **`% cc -o pun pun.c`** 

> **GCC 컴파일러**
>
> GCC 컴파일러는 가장 유명한 C 컴파일러 중 하나이다. 이 컴파일러는 리눅스에 기본 제공되는 컴파일러이지만, 다른 환경에서도 사용할 수 있다. 이 컴파일러를 사용하는 것은 마치 UNIX의 `cc` 컴파일러를 사용하는 것과 비슷하다. 아까 `pun.c` 프로그램을 컴파일 했을 때와 같은 방식으로 컴파일하기 위해선 다음과 같이 해주면 된다.
>
> **`% gcc -o pun pun.c`**
>
> **[Q&A]** 이 단원의 Q&A에서 GCC에 대해 좀 더 구체적으로 다루고 있다. 

**통합개발환경**

지금까진 운영체제가 기본적으로 제공하는 특별한 창에 명령문을 입력하여 커맨드 라인 컴파일러를 사용한다는 가정을 했다. 이 방법 말고 사용할 수 있는 방법은 **통합개발환경(Integrated Development Environment. IDE)**을 사용하는 것이다. IDE란 개발 환경에서 벗어나지 않은 상태에서 수정하고, 컴파일하고, 링크하고 실행하는 것 뿐만 아니라 심지어는 디버깅까지 해주는 소프트웨어 패키지이다. IDE의 구성 요소들은 다 같이 작동하도록 설계되어있다. 예를 들어 컴파일러가 어떠한 프로그램에서 에러를 찾아낸다면, 데이터로 하여금 에러가 발생한 특정 줄에 표시를 줄 수 있을 것이다. IDE에는 여러가지 종류가 있기에 굳이 이 책에서 언급하지는 않도록 한다. 물론 본인이 사용하고 있는 플랫폼에 가장 알맞는 IDE가 무엇인지 확인하는 것을 추천한다.

### 2.2 프로그램의 일반적인 형태

 `pun.c`을 통해 어떻게 하면 이 프로그램을 일반화할 수 있는지 알아보도록하자. 간단한 C 프로그램은 다음과 같은 구조를 가진다. 

```C
directives

int main(void)
{
  statements
}
```

이 템플릿을 포함해 이 책에서 보게 될 여러 템플릿들을 보게 된다면, 이탤릭체로 된 글자들은 프로그래머가 직접 작성해야할 코드들을 의미하고, 나머지 글자들은 글자 하나 하나 똑같이 유지된다는 것을 알 수 있다.

`main` 함수의 중괄호들이 어떻게 시작하고 끝나는 지에 주목해보라. C가 중괄호 {와 }를 사용하는 방법은 다른 언어들이 `begin`과 `end`를 사용하는 방식과 같다. 즉, C는 축약과 특수 기호들을 자주 사용하고 있다는 것을 알 수 있다. **[Q&A]** 이는 C 언어가 간결하거나 덜 암호같다고 평가 받는 이유 중 하나다.

가장 간단한 C 프로그램조차 위의 템플릿에 보이는 세 가지 부분에 의존한다. 지시자directives, 함수function, 그리고 구문statement이다. 지시자란 어떤 프로그램을 컴파일하기 전에 그 프로그램을 수정하는 명령문을 수정하는 것이다. 함수란 `main` 함수처럼 이름이 있는 블록 형태로 이루어진 실행 가능한 코드다. 구문이란 프로그램이 실행될 때 실행되어야할 명령문들이다. 이제 이 세 가지 개념에 대해서 구체적으로 알아보도록 하자.

#### 지시자

C 프로그램이 컴파일 되기전에, 전처리기에 의해 처음 수정된다. 전처리기를 위한 명령문들을 지시자(Directive)라고 한다. 지시자는 `#`으로 시작해야 한고 뒤에 `;`은 사용하지 않는다. 많이 쓰는 지시자 중 `#include<라이브러리.h>`지시자가 있는데 라이브러리의 정보를 컴파일 하기 이전에 프로그램에 포함하도록 해준다.  `#include<stdio.h>`에서 `stido.h` 와 같이 `.h`로 되어있는 파일은 헤더리거 불린다. `stido.h` 는 표준 입출력 라이프러리이다. C는 다른언어들과 달리 입출력에 대한 기본 내장 함수가 없기 때문에 라이브러리를 include 해줘야 한다.

#### 함수

수학과는 다르게 C에서 사용하는 함수의 개념은 좀 더 광범위하다. C에서 함수는 이름이 주어진 여러 개의 구문을 포함한 집합을 의미한다. 함수는 값을 연산해낼수도 있고, 연산하지 않을 수도 있다. 만약 어떠한 연산의 결과를 반환하고 싶은 경우 `return`이라는 구문을 통해 그 함수가 어떤 값을 "반환return"하는지 명시해준다. 예를 들자면 입력값에 1을 더하는 함수가 존재한다면 다음과 같은 구문을 짜야할 것이다. 

```c
return x + 1;
```

만약 함수가 두 개의 입력값을 받아 각각의 제곱의 차를 구하는 함수라면 다음과 같이 구문을 짤 것이다.

```c
return y * y - z * z;
```

여러 함수를 사용자가 작성하여 사용할 수 있지만, 그 중 `main`함수는 필수 함수이다. `main`함수는 프로그림이 시작할 때 자동으로 실행되는 함수 이기 때에 `main`함수 없이는 프로그램이 동작하지 않는다. `main`함수의 이름은 반드시 main이어야 한다. 

그렇다면 `main`함수는 반환값을 가지는 함수인가? 답은 그렇다. main함수는 OS에 상태코드를 리턴해준다. 

`pun.c` 프로그램을 다시 살펴보면,

```c
#include<stdio.h>
int main(void)
{
	printf("To C, or not to C: that is the question.\n");
	return 0;
}
```

`main`앞에  `int`가 나오는데, 이것은 main 함수가 int형(정수) 값을 반환하는 것을 의미한다. 괄호 안에 `void`는 main 함수가 입력갑을 요구하지 않을 때 사용한다.(void 생략 가능)

`return 0;`는 두 가지 효과를 갖는데, 첫번째로는 `main` 함수를 종료시키고(프로그램 또한 중단) 두번째로는 0이라는 값을 반환한다. `main` 함수의 반환값에 대해선 나중 단원에서 다루도록 하고, **[Q&A]** 지금은 `main` 함수를 사용한다면 언제나 0이라는 값을 반환하도록 프로그래밍하도록 하자. 이는 **일반적인 프로그램 종료를 의미**한다.

 `return` 구문이 `main` 함수 마지막에 없더라도 프로그램은 종료될 것이다. **[Q&A]** 하지만 대부분의 컴파일러들은 `main` 함수는 정수값을 반환 받았어야 하는데 그러지 못했기 때문에 에러 메세지를 송출할 것이다. 

#### 구문

`구문statement`이란 프로그램이 실행될 때 실행되어야 하는 명령들이다. `pun.c` 프로그램에선 두 가지 구문만을 사용한 것을 알 수 있다. 하나는 `return` 구문이고 다른 하나는 함수 `호출function call`이다. 함수를 호출call한다는 것은, 어떤 함수가 그 임무를 수행하게 만드는 것을 의미한다. `pun.c` 프로그램을 통해서 구체적으로 알아보도록 하자. 이 프로그램에선 `printf 함수`를 호출해내서 화면에 문자열을 출력시킨다.

```c
printf("To C, or not to C: that is the question.\n");
```

C에선 각 구문은 반드시 `세미콜론(;)`으로 끝나야 한다. 물론 복합문compound statement처럼 세미콜론이 필요 없는 유일한 예외가 있긴 하지만, 이건 나중에 다룰 내용이다. 세미콜론은 컴파일러로 하여금 구문이 어디서 끝나는지를 알려주는 역할을 한다. 줄 별로 구분하지 않는 이유는 구문 자체는 여러 줄이 될 수 있기 때문에 어디서 끝나는지 명확하지 않을 수 있기 때문이다. 지시자는 이와 반대로 한 줄짜리이기 때문에 굳이 세미콜론을 사용하지 않아도 되기 때문에 세미콜론을 사용하지 않는다

#### 문자열 출력하기

`printf` 함수는 강력한 함수이다. 아직까지 이 책에 `printf`를 통해 `문자열 리터럴string literal`만 출력했다. 문자열 리터럴이란 여러 문자의 연속체를 의미한다. 여기서 이 연속체는 큰따옴표 안에 존재하고, `printf` 함수는 이 따옴표 안에 있는 정보만 출력한다.

`printf` 함수는 다음 줄로 넘어가라고 지시하지 않는 한 다음 줄로 넘어가지 않는다. 그렇기 때문에 다음 줄로 넘어가라고 지시할 땐 `\n`를 추가해줘야만 한다. 이 때 `\n`란 `줄 내림 문자`, 혹은 `개행 문자new-line character`이라고 부른다. 개행 문자를 추가해 줌으로써 현재 출력하던 줄을 끝내고 다음 줄로 넘어갈 수 있게 만들어줄 수 있는 것이다. 이 개행 문자가 어떻게 작동하는지는 다음 예제를 통해 직접 확인해보도록 한다.

```c
printf("To C, or not to C: that is the question.\n");
```

이 구문을 두 개로 나눠보도록 하자.

```c
printf("To C, or not to C: ");
printf("that is the question.\n");
```

첫번째 `printf` 함수는 `To C, or not to C:`를 출력을 할 것이고, 두번째 `printf` 함수는 `that is the question.`을 출력한 다음 다음줄로 넘어갈 것이다. 사실상 첫번째 예제나 두번째 예제나 순수하게 결과만 살펴본다면 같을 것이다.

개행 문자는 한 문자열 리터럴에서 여러번 등장할 수 있다. 만약 다음과 같은 메세지를 출력하고 싶다고 하자.

>  Brevity **is** the soul of wit. 
>
> --Shakespeare 

이것을 출력하려면 다음과 같이 코드를 작성할 수 있다.

```c
printf(Brevity is the soul of wit.\n --Shakespeare);
```

### 2.3 주석(comment)

프로그램에 대한 설명을 하기 위해 주석을 사용한다. `/*`와 `*/` 사이에 있는 문자는 주석 처리되며, 컴파일러에서 컴파일 시 무시가 된다.

으로 나타내준다. 즉 다음과 같이 작성해주면 된다.

```c
/* 이것은 주석입니다 */
/* This is a comment */
```

거의 대부분의 프로그램들은 주석으로 도배되어있을 것이다. 비슷한 느낌으로 `pun.c`을 주석으로 도배해보도록 하자.

```c
/* 제목: pun.c */
/* 목적: bad fun 출력 */
/* 작성자: K. N. King */
/* Name: pun.c */
/* Purpose: Prints a bad pun */
/* Author: K. N. King */
#include<stdio.h>
int main(void)
{
printf("To C, or not to C: that is the question.\n");
return 0;
}
```

주석이 한 줄 이상이 될 수도 있다. 그럴 땐 단순히 `/*`와 `*/`를 길게 사용하면 된다. 컴파일러는 `/*`가 먼저 나온다면, `*/`이 다음으로 나오지 않는 이상 `/*` 이후에 적혀있는 모든 문자들을 무시한다.

```c
/* Name: pun.c
```

하지만 사실 이렇게 주석을 작성하는 것을 추천하지는 않는다. 이렇게 작성하게 되면 어디부터 어디까지가 주석인지 확실하지 않기 때문이다. 그렇기 때문에 다음과 같이 작성하는 것을 추천한다.

```c
/* Name: pun.c
Purpose: Prints a bad pun
Author: K. N. King
*/
```

이것보다 더 좋은 방법은, 주석에 일종의 박스를 두르는 방법이 있다.

```c
/********************************************************************************
* Name: pun.c *
* Purpose: Prints a bad pun *
* Author: K. N. King *
********************************************************************************/
```

프로그래머들은 보통 좀 더 간단한 방식의 박스를 사용한다.

```c
/*
* Name: pun.c
* Purpose: Prints a bad pun
* Author: K. N. King
*/
```

짧은 주석은 프로그램의 코드가 존재하는 줄에 같이 존재할 수 있다.

```c
int main(void) /* 메인 프로그램의 시작 */
int main(void) /* Beginning of main program */
```

이러한 주석을 보통 "날개 주석winged comment"라고 부른다. **[!!!]** 주석을 깜빡하고 제대로 닫아주지 않는 경우 컴파일러는 주석이 열린 부분부터는 무시하므로 프로그램의 일부분을 무시할 수 있다. 다음 예제를 보자.

```c
printf("My "); /* 주석 깜빡하고 닫지 않기...
printf("cat ");
printf("has "); /* 여기서 주석이 끝날 것 */
printf("fleas");
printf("My "); /* forgot to close this comment...
printf("cat ");
printf("has "); /* so it ends here */
printf("fleas");
```

첫번째 주석을 제대로 닫아주지 않았기 때문에 컴파일러는 중간에 있는 두 구문을 무시하고, 출력 결과는 다음과 같을 것이다. 

> My fleas

**[C99]** C99를 사용하는 경우, `//`을 앞에 적어주어 주석 처리를 해줄 수 있다.

```cassandra
// 이것은 주석입니다
// This is a comment
```

이런 방식의 주석은 보통 한 줄이 끝나게 되면 덩달아 끝나게 된다. 만약 여러줄에 걸쳐서 주석 처리를 하고 싶다면, 위의 방식을 사용하거나, 여러 줄에 걸쳐 계속해서 `//`를 사용하면 된다.

```c
// Name: pun.c
// Purpose: Prints a bad pun
// Author: K. N. King
```

이 방식으로 주석 처리를 할 때엔 여러 가지 장점들이 있다. 우선 이 방식으로 주석 처리를 하면 한 줄 자체가 주석 처리가 되기 때문에 첫번째 방식처럼 닫지 않는다고 해서 프로그램의 일부가 주석처리 되지 않는다. 또다른 장점은 위의 예시에서 보았듯 여러줄로 이뤄진 주석이라면, 각 줄 마다 `//`를 써주기 때문에 좀 더 보기 좋아졌다는 것이다.

### 2.4변수와 할당

대부분의 프로그램들은 출련전에 몇 가지의 연산을 수행하기 때문에 일시적으로 연산을 할 때 필요한 데이터를을 저장을 해야한다. 이때 저장 위치를 `변수variable`라고 부른다. 

#### Type

모든 변수들은 반드리 `유형Type`을 가진다. 즉 어떠한 데이터를 저장할 것인지를 정해주어야 한다. C언어에는 여러가지 변수 유형이 있지만, `int`와 `float`을 먼저 살펴보곘다. 적절한 변수를 선택하는 것은 변수가 어떻게 저장되고 그 변수가 어떤 연산을 수행할 수 있는지 영향을 미치기 때문에 매우 중요하다. 숫자 변수의 유형은 변수가 저장할 수 있는 최소값과 최대값을 정의하고, 부동 소수점 표시가 가능한지 여부 또한 정의한다.

정수 integer의 줄임말인 변수 `int`형은 정수(0,1,302.-332)를 저장할 수 있다. 하지만, 값의 범위는 정해져 있다. `int`의 최대값은 보통 `2,147,483,647`이다.

 **[Q&A]** `부동 소수점floating-point`의 줄임말인 변수 `float`형은 `int` 변수보다 더 큰 숫자를 저장할 수 있을 뿐더러 `379.125`와 같이 소수 형태로 저장할 수 있다. 허나 `float` 변수는 몇 가지 단점이 있다. **`float`을 이용한 연산은 `int`를 이용한 연산보다 더욱 느릴 수 있기 때문이고, 특히 `float` 변수의 값은 정확한 값이 아니라 근사값**이기 때문이다. 예를 들어 `float` 변수에 `0.1`을 저장한다면, 나중에 이 변수가 `0.1`이 아닌 `0.099999999999987`을 값으로 갖고 있을 것이다. 이는 반올림할 때 발생하는 오류이기 때문이다. 

#### 선언(Declare)

만약 `height`과 `profit`라는 변수를 선언해야한다면 다음과 같이 선언해야한다.

```c
int height;
float profit;
```

첫번째 선언에선 `height`을 `int`형 변수로 선언했으므로, `height`은 정수값을 저장할 수 있을 것이다. 두번째 선언에선 `profit`이 `float`형 변수로 선언해주었다.

만약 여러 변수들이 같은 유형을 갖고 있다면, 동시에 선언해줄 수 있다.

```c
int height, lenght, width, volume;
float profit, loss;
```

각 선언이 세미콜론(`;`)으로 끝맺음 된다는 것을 알 수 있다.

이 책에서 처음 작성했던 예제 프로그램에선 `main` 함수에 아무런 선언을 해주지 않았다. 만약 `main`이 선언문을 포함한다면, 반드시 구문 전에 선언해주어야한다.**(C99부터는 아님)**

```c
int main(void)
{
*declarations*
*statements*
}
```

9 단원에서 좀 더 다뤄보도록 하겠지만, 대부분의 함수들이나 블록(내부에 선언문이 박혀있는 구문)들은 위와 같은 구조를 따른다. **좀 더 코드를 깔끔하게 짜기 위해선 선언문과 구문 사이에 한 칸을 뛰어 놓는 것이 좋다.**

 **[C99]** C99에선 선언이 굳이 구문 직전에 오지 않아도 된다. 예를 들어 `main` 함수 내부에서 선언 먼저하고, 구문하고, 또 다른 선언하고 이런식으로 작성할 수 있다는 것이다. 좀 구식 컴파일러와의 호환성을 위해선 위의 방식의 규칙을 지키는 것이 좋긴 하다. 허나 보통 C++이나 Java에선 프로그램을 작성할 때 변수가 필요한 순간 직전에 변수를 선언해주는 것이 보편화 되어있다. 그렇기 때문에 C99으로 프로그래밍을 공부하고 있다면, 이와 같이 버릇을 들이는 것이 좋다. 

####  할당 (assignment)

 변수는 할당assignment을 함으로써 값을 가질 수 있다. 다음 구문을 보도록 하자.

```c
height = 8;
length = 12;
width = 10;
```

다음 구문은 각 변수 `height`, `length`와 `width`에 값 8, 12, 10을 각각 할당하는데, 여기서 할당하는 숫자들을 `상수constant`라고 부른다. 변수에 값을 할당하거나, 변수를 사용하기전엔 **우선 먼저 선언**이 되어야한다. 고로 다음과 같이 작성해주도록 한다.

```c
int height;
height = 8;
```

허나 다음과 같이 작성하면 에러가 날 것이다.

```c
height = 8; /*** WRONG ***/
int height;
```

`float`형 변수에 할당된 변수는 보통 소수점을 포함한다. 만약 `profit`이 `float`형 변수라면, 다음과 같이 할당할 수 있다.

```c
profit = 2150.48;
```

**[Q&A]** 보통 `float`형 변수에 할당된 소수점을 갖는 상수에는 끝에 `f`(`float`의 앞 글자)를 붙인다.

```c
profit = 2150.48f;
```

만약 `f`를 추가해주지 않는다면 컴파일할 때 컴파일러가 에러를 낼 수도 있다.

`int`형 변수는 보통 `int`형 값을 할당받고, `float`형 변수는 보통 `float`형 값을 할당받는다. `int`형 변수에 `float`형 값을 할당하고, `float`형 변수에 `int`형 값을 할당하는 식의 유형을 섞는 행위는 가능은 하지만, 매우 불안정하다. 이와 관련된 내용은 4.2 단원에서 좀 더 다룰 것이다.

변수에 값이 할당된 이상 다른 새로운 변수의 값을 만드는데 사용될 수 있다.

```c
height = 8;
length = 12;
width = 10;
volume = height * lenght * width; /* volume is now 960 */
```

 C에서 `*`는 곱셈연산자를 의미하기에, 마지막 구문은 `height`, `length`, `width`에 각각 저장된 값을 모두 곱하여 `volume` 변수에 저장한다. 일반적으로 할당할 때의 우변은 상수, 변수와 연산자로 이루어진  `표현식expression`이 될 수 있다. 

#### 변수의 값 출력하기

변수가 현재 갖고 있는 값은 `printf`를 이용해서 출력할 수 있다. 다음과 같은 글귀를 출력한다고 해보자.

> Height: h

여기서 `h`는 `height` 변수가 현재 갖는 값이라고 하자. 그렇다면 다음과 같이 `printf`를 이용하면 된다.

```c
printf("Height: %d\n", height);
```

`%d`의 역할은 출력될 때 `height`의 값을 대신하는 것이다. `\n`이 `%d` 바로 다음에 적혀있으니, `printf`는 `height`의 값을 출력한 다음 다음 줄로 넘어갈 것이다.

`%d`은 오로지 `int`형 변수만 대신할 수 있다. `float`형 변수는 `%f`를 이용해서 대신할 수 있다. `%f`는 **기본적으로 소수점 이하 여섯자리까지 출력**한다. `%f`로 하여금 소수점 이하 `p` 자리까지 출력하게 하려면 **`%`와 `f` 사이에 `.p`**를 적어주면 된다. 예를 들어 다음 줄을 출력해보도록 하자.

> Profit: $2150.48

이를 출력하기 위해서 `printf`를 다음과 같이 호출해주도록 한다.

```c
print("Profit: $%.2f\n", profit);
```

`printf`가 출력할 수 있는 변수의 개수엔 제한이 없다. 만약 `height`과 `lenght` 변수를 동시에 출력하고 싶다면 다음과 같이 `printf`를 호출해주면 된다.

```c
print(Height: %d Length: %d\n", height, length);
```

#### [프로그래밍] 박스의 용적 중량을 연산하기 1

운송회사들이 제일 싫어하는 박스가 크면서 가벼운 박스이다. 이러한 박스는 트럭이나 항공기의 귀중한 공간을 갉아먹기 때문이다. 실제로 이러한 박스에 대해 추가적인 요금을 물기도 한다. 이 때 이 요금은 무게가 아닌 부피를 기준으로 책정한다. 미국에선 보통 부피를 166(가능한 인치 당 입방인치)를 나누는 방식이 있다. 이러한 방식으로 계산된 값을 보통 용적dimensional, 혹은 체적volumentric 중량이라고 부른다. 이러한 용적 중량이 박스의 실제 무게를 초과한다면 운송비는 그 박스의 용적 중량에 따라 계산된다. 166으로 나누는 것은 국제 운송 기준이고, 미국 국내 운송이면 보통 194로 나눈다.

당신이 운송회사에 취직을 했다고 가정해보자. 당신의 업무는 박스의 용적 중량을 계산하는 프로그램을 짜는 것이다. 당신은 C에 방금 입문한 사람이니, 우선 12"×10"×8"이라는 구체적인 길이가 주어진 박스의 용적 중량을 계산하는 프로그램을 짜는 것으로 시작했다고 치자. C에서 나눗셈을 하는 연산자는 `/` 이다. 고로 용적 중량을 계산하는 방법은 다음과 같을 것이다.

```c
weight = volume / 166;
```

`weight`와 `volume`은 각각 박스의 무게와 부피를 의미하는 정수 변수라고 하자. 사실 이런 식으로 짠 공식이 정확한 답은 아니다. C에서 어떤 정수가 다른 정수에 의해 나뉘게 되면 그 결과값은 불완전한 값을 갖게 된다. `weight`은 정수형 변수이기 때문에 소수점 이하의 값은 없어지게 된다. 12"×10"×8"인 박스의 중량은 960 입방인치이므로 이것을 166으로 나누게 되면 구체적인 값인 5.783이 아닌 5이 결과값으로 나올 것이다. 허나 운송회사가 원하는 결과는 반내림이 아니라, 반올림이다. 이를 해결할 수 있는 방법은 **부피에 165를 더해준 상태에서 166으로 나누는 것이다.**

```c
weight = (volume + 165) / 166;
```

부피가 만약 166이라면 용적 중량은 331/166, 혹은 1이 될 것이고, 부피가 167이라면 이는 332/166, 혹은 2가 될 것이다. 이러한 방법으로 연산을 하여 프로그램을 작성해보도록 하자.

**dweight.c**

```c
/* Computes the dimensional weight of a 12" x 10" x 8" box */
#include<stdio.h>
int main(void)
{
int height, length, width, volume, weight;
height = 8;
length = 12;
width = 10;
volume = height * length * width;
weight = (volume + 165) / 166;
printf("Dimensions: %dx%dx%d\n", length, width, height);
printf("Volume (cubic inches): %d\n", volume);
printf("Dimensional weight (pounds): %d\n", weight);
return 0;
}
```

이 프로그램의 결과는 다음과 같다.

> Dimensions: 12x10x8
>
> Volume (cubic inches): 960
>
> Dimensional weight (pounds): 6

#### 초기화(Initialization)

어떤 변수들은 프로그램이 실행될 때 자동으로 0을 값으로 갖지만, 대부분은 아니다. 기본 설정값이 없는 변수는 값을 할당하지 않는 이상 초기화initialization되지 않았다고 한다. **[!!!]**

초기화되지 않은 변수의 값을 예를 들어 printf를 이용해 변수를 출력하려고 하거나 표현식에서 사용하는 식으로 접근한다면 `2568`, `-30981`와 같이 예상하지 못한 결과값이 나올 수 있다. **어떤 컴파일러들은 심한 경우에 아예 프로그램이 중단**되는 경우가 생긴다.

변수에 초기값을 부여하는 방법은 당연히 할당을 하는 것이다. 허나 좀 더 간단한 방법이 있다. **변수의 초기값을 선언할 때 할당**해주는 것이다. 다음 예시처럼 `height`의 선언과 초기값 할당을 동시에 해줄 수 있다.

```c
int height = 8;
```

C 언어 용어로 `8`이라는 값을 초기값initializer라고 부른다.

같은 방식으로 여러 변수에 각기 여러 값을 할당해줄 수 있다.

```c
int height = 8, length = 12, width = 10;
```

각 변수는 반드시 자신만의 초기값가 필요하다. 위의 세 변수가 전부 `10`을 초기값로 갖는다고 해서 전부 아래와 같이 할당하면 마지막에 있는 `width` 변수만 초기값이 할당되고 나머지 변수들은 선언만 되고 초기화되지 않는다.

```c
int height, length, width = 10;
```

#### 표현식 출력하기

`printf`는 변수에 저장된 값만을 출력하는 기능만이 있는 것은 아니다. `printf`는 사실 모든 표현식을 출력할 수 있다. 이러한 특징을 이용한다면 프로그램에서 변수를 줄여 프로그램을 간단하게 만들 수 있다. 다음 예제를 확인해보자.

```c
volume = height * length * width;
printf("%d\n", volume);
```

이 예제는 사실 아래와 같이 표현할 수 있다.

```c
printf("%d\n", height * length * width);
```

이렇듯 `printf`은 표현식을 출력할 수 있다. 이러한 면은 C의 일반적인 원칙을 단적으로 드러낸다. 어떠한 특정 값이 필요하다면, 같은 값을 갖는 표현식은 그것을 대체할 수 있다.

### 2.5 입력값 읽기

`dweight.c` 프로그램은 특정 한 가지 유형의 박스의 용적 중량만을 계산하기 때문에 실무에서 사용할 수 없다. 프로그램을 좀 더 실무에 사용가능하도록 만드려면 사용자가 박스의 세변의 길이를 입력하고 이에 따라 용적 중량을 계산하게 만들어야 할 것이다.

입력값을 받기 위해선 C 라이브러리에 있는 `printf`의 반대의 의미인 `scanf` 함수를 사용해야한다. `scanf`와 `printf`에 사용된 `f`는 **형식화formatted의 약자**이다. `scanf`와 `printf` 각각 데이터를 입력받거나 출력할 때 형식 문자열format string이 필요하다. `printf`가 데이터를 출력할 때 어떻게 출력해야하는지 알려줘야 하듯, `scanf` 또한 입력받는 데이터의 형식을 정해주어야 한다.

만약 `int`형 변수를 입력받고 싶다면 다음과 같이 `scanf` 함수를 사용해야한다.

```c
scanf("%d", &i); /* 정수를 받아 i에 저장한다. */
scanf("%d", &i); /* reads an integer; stores into i */
```

`scanf`가 정수값을 받기 위해선 문자열 `%d`가 필요하다. 여기서 받은 값은 `int`형 변수인 `i`에 저장된다. **현재로선 `&`의 기능을 설명하기엔 이르다.** 우선은 이 기호가 반드시는 아니지만 주로 `scanf`를 사용할 때 사용한다는 것만을 알고 넘어가라.

`float`형 변수를 입력받고 싶다면 `scanf` 함수를 다른 방식으로 호출해야한다.

```c
scanf("%f", &x); /* 소수를 받아 x에 저장한다. */
scanf("%f", &x); /* reads an float value; stores into i */
```

`scanf`가 정수값을 받기 위해선 문자열 `%f`가 필요하다. 즉, `x`는 `float`형 변수가 될 것이고, 여기서 받은 값은 `x`에 저장될 것이다. `x`는 소수점을 포함할 수도, 아닐 수도 있을 것이다.

#### [프로그래밍] 박스의 용적 중량을 연산하기 2

이제 사용자가 박스의 세변의 길이를 입력할 수 있게 본 프로그램을 좀 더 구체적으로 작성해보도록 하자. 아래 코드를 보면 `scanf`엔 `printf`가 선행된다는 것을 알 수 있다. 이러한 방식을 통해 사용자는 언제 값을 입력하고, 어떤 값을 입력해야하는지 알 수 있을 것이다.

**dweight2.c**

```c
/* Computes the dimensional weight of a
box from input provided by the user */
#include<stdio.h>
int main(void)
{
int height, length, width, volume, weight;
printf("Enter height of box: ");
scanf("%d", &height);
printf("Enter length of box: ");
scanf("%d", &length);
printf("Enter width of box: ");
scanf("%d", &width);
volume = height * length * width;
weight = (volume + 165) / 166;
printf("Volume (cubic inches): %d\n", volume);
printf("Dimensional weight (pounds): %d\n", weight);
return 0;
}
```

이 프로그램의 결과값은 다음과 같은 모습을 갖고 있다. 유저가 입력한 부분은 밑줄 처리가 되어있다.

> Enter height of box: 8
>
> Enter length of box: 12
>
> Enter width of box: 10
>
> Volume (cubic inches): 960
>
> Dimensional weight (pounds): 6

사용자로 하여금 입력을 하게 만드는 질문을 하는 메시지(프롬프트prompt)는 프롬프트와 대답이 같은 줄이 있는 것이 좋기 때문에 통상적으로 개행 문자로 끝나서는 안된다.

`dweight2.c` 프로그램은이 갖는 한 가지 단점이 있다. 사용자가 숫자가 아닌 다른 값을 입력하면 에러가 발생한다. 이러한 점에 대한 해결방법은 3.2단원에서 구체적으로 다룰 것이다.

### 2.6 상수 이름 정의하기

프로그램이 상수를 포함하고 있다면, 상수에 이름을 지어주는 것이 좋다. `dweight.c` 과 `dweight2.c` 프로그램은 `166`라는 상수를 중간에 사용해주고 있는데, 이렇게 단순히 숫자로만 표현하면 읽는 사람으로 하여금 이게 무슨 의미인지 이해가 안 될 수 있다. 그렇기 때문에 C 언어의 기능 중 하나인 `매크로 정의macro definition`을 사용하여 상수에 이름을 붙여줄 수 있다.

```c
#define INCHES_PER_POUND 166
```

`#define`은 `#include`와 같은 `전처리 지시자`이기 때문에 마지막에 세미콜론(`;`)이 들어가지 않는다. 프로그램이 컴파일 될 때 전처리자는 각 매크로를 지정된 값으로 대체한다. 다음 구문을 확인해보라.

```c
weight = (volume + INCHES_PER_POUND - 1) / INCHES_PER_POUND;
```

이 구문은 아래 구문과 같다.

```c
weight = (volume + 166 - 1) / 166;
```

매크로의 값은 `표현식`이 될 수 있다.

```c
#define RECIPROCAL_OF_PI (1.0f / 3.14159f)
```

Reciprocal은 역수라는 의미이다. 만약 연산자가 표현식에 존재한다면 괄호를 통해 열고 닫아줘야한다.

매크로의 이름에 **오로지 대문자만 사용하는 것은 필수는 아니다. 대부분 C 언어 프로그래머들이 암묵적으로 지키는 전통**과도 같다. C 언어를 처음 배우는 독자들도 이 전통에 따를 것을 권장한다.

#### [프로그래밍] 섭씨를 화씨로 변환하기

아래 프롬프트를 통해 이 프로그램은 유저가 화씨 온도를 입력하게 되면 섭씨 온도로 변환하여 출력해주는 것을 알 수 있다. 이 프로그램의 출력은 다음과 같은 모습을 하고 있을 것이다. 위의 예제에서와 마찬가지로 사용자가 입력한 값은 밑줄이 쳐져있다.

> Enter Fahrenheit temperature: 212
>
> Celsius equivalent: 100.0

이 프로그램에선 온도가 정수값이 아니어도 되게 짤 것이다. 그렇기 때문에 위의 결과에서 섭씨 온도 값이 `100`이 아닌 `100.0`으로 출력되는 것이다. 우선 프로그램이 어떻게 생겼는지 알아보도록 하자.

**celsius.c**

```c
/* Converts a Fahrenheit temperature to Celsius */
#include<stdio.h>
#define FREEZING_PT 32.0f
#define SCALE_FACTOR (5.0f / 9.0f)
int main(void)
{
    float fahrenheit, celsius;
    printf("Enter Fahrenheit temperature: ");
    scanf("%f", &fahrenheit);
    celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;
    printf("Celsius equivalent: %.1f\n", celsius);
    return 0;
}
```

다음 구문

```c
celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;
```

는 화씨 온도를 섭씨로 변환해준다. `FREEZING_PT`는 `32.0f`이고, `SCALE_FACTOR`는 `(5.0f / 9.0f)`이므로 컴파일러는 이 구문을 사실상 다음과 같은 구문으로 본다.

```c
celsius = (fahrenheit - 32.0f) * (5.0f / 9.0f);
```

C는 두 정수를 나누면 소수점 아래를 잘라 간략하게 나타내버리기 때문에 `SCALE_FACTOR`를 `(5 / 9)`로 한다면 **결과값이 0이 되버리기 때문에 (5.0f / 9.0f)로 정의**한다. 언제나 이 점에 집중해야한다.

`printf` 함수 호출은 섭씨 온도를 출력한다.

```c
printf("Celsius equivalent: %.1f\n", celsius);
```

`celsius`를 소수점 이하 한자리만 표현하기 위해 `%.1f`를 사용했다.

### 2.7 식별자(identifier)

프로그램을 작성하면서 변수, 함수, 매크로 등에 이름을 정해주어야 한다. 이러한 이름들을 `식별자identifier`라고 부른다. C에선 식별자를 정의할 때 문자, 숫자나 `_`와 같은 밑줄 표시를 사용할 수 있다. 단, 이름을 숫자로 시작할 수는 없다. [C99] C99에선 식별자에 특정 유니버설 문자 이름universal character name을 포함할 수 있다.

다음은 식별자로 가능한 경우들이다.

`times10` `get_next_char` `_done`

다음은 불가능한 경우들이다.

`10times` `get-next-char`

`10times`은 이름이 문자나 밑줄 표시가 아닌 숫자로 시작하고 있고, `get-next-char`은 밑줄 표시가 아니라 뺄셈 기호를 사용하고 있다.

C는 `대・소문자`를 구별한다(case-sensitive). 식별자 내에 대문자와 소문자는 엄연히 다른 문자인 것이다. 아래에 있는 식별자들은 전부 다 다른 식별자들이다.

`job` `joB` `jOb` `jOB` `Job` `JoB` `JOb` `JOB`

이 여덟 개의 식별자들을 모두 각기 다른 용도로 사용할 수 있다. (물론 실제로 그런다면 매우 혼란스러울 것이다!) 실용적인 프로그래머들은 변수들끼리 연관이 있지 않는 이상 전부 구분이 가능하게 식별자를 작성한다.

C는 대소문자를 구분하기에 많은 프로그래머들은 매크로를 제외하고는 식별자를 오로지 소문자로만 작성하고, 가독성을 위해 밑줄 표시를 사용하기도 한다.

**C스타일** : `symbol_table` `current_page` `name_and_address`

어떤 프로그래머들은 밑줄 표시를 사용하지 않고 대문자를 이용해 식별자를 작성한다.

**Java, C++스타일 **:`symbolTable` `currentPage` `nameAndAddress`

가끔 첫번째 글자를 대문자로 적어주기도 한다. 전자가 C에선 좀 더 흔하지만, 후자가 Java와 C#, 더 나아가서는 C++의 영향에 의해 더욱 더 유명해지고 있다. 다른 방법들 또한 있겠으나, 적어도 식별자가 다시 프로그램에서 등장할 때마다 각각 같은 방식으로 대문자 처리를 해주는 것이 좋다.

**[Q&A]** C에선 식별자가 몇 글자까지 되는지에 대한 한계는 없으니 좀 더 구체적인 식별자를 사용하는 것에 대해 거부감을 느끼지 말라. 실제로 `current_page가` `cp`보단 이해하기 훨씬 좋다.

#### 키워드

**[C99]** C 컴파일러에선 아래 [표 2.1]에 명시된 일부 키워드keyword들을 특별히 인식하기 때문에 이들을 **식별자로 사용할 수 없다**. C99에는 다섯가지가 더 추가되었다.( † C99에서 추가된 키워드)

| `auto`     | `enum`     | `restrict` | `unsigned`    |
| :--------- | :--------- | :--------- | :------------ |
| `break`    | `hextern`  | `return`   | `void`        |
| `case`     | `float`    | `short`    | `volatile`    |
| `char`     | `for`      | `signed`   | `while`       |
| `const`    | `goto`     | `sizeof`   | `_Bool`†      |
| `continue` | `if`       | `static`   | `_Complex`†   |
| `default`  | `inline`†  | `struct`   | `_Imaginary`† |
| `do`       | `int`      | `switch`   |               |
| `double`   | `long`     | `typedef`  |               |
| `less`     | `register` | `union`    |               |

[표 2.1] 키워드

당연히 C는 대소문자를 구분하기 때문에 키워드들은 [표 2.1]에 명시된 대로 전부 소문자로 작성해야한다. 표준 라이브러리에 있는 `printf`과 같은 함수의 이름 또한 마찬가지로 전부 다 소문자로 이뤄져있다. 전부 작성해서 컴파일러가 이러한 함수나 키워드들을 인식하지 못하는 불상사를 미리 예방하도록 하자.

> **[!!!]** 식별자엔 위에서 다룬 것 외의 또다른 제한이 있기도 하다. 몇몇 컴파일러들은 `asm`과 같은 특정 식별자들 추가적인 키워드로 인식한다. 당연히 표준 라이브러리에 포함된 식별자 또한 제한된다. 이러한 이름을 실수를 해서 사용하는 경우 컴파일을 하거나 링크를 할 때 에러가 발생할 것이다. 식별자가 밑줄 표시로 시작하는 경우도 제한된다.

### 2.8 C 프로그램의 레이아웃

C 프로그램을 일종의 `토큰token`의 연속이라고 이해할 수 있다. 토큰이란 **의미를 구성하는 최소 단위**이다. 식별자나 키워드가 토큰이 일종이다. +와 -와 같은 연산자나 쉼표나 세미콜론과 같은 구두점이나 문자열 리터럴 등 또한 마찬가지로 토큰의 일종이다. 다음 구문을 보자.

```c
printf("Height: %d\n", height);
```

위의 구문은 총 **일곱 개의 토큰**으로 이뤄져있다.

```c
printf  (  "Height: %d\n"  ,    height  )  ;
 ①      ②        ③          ④     ⑤     ⑥   ⑦
```

①번과 ⑤번 토큰은 식별자들이고 ③번 토큰은 스트링 리터럴이며, 나머지 토큰들은 전부 구두점들이다. 토큰 사이에 줄을 띄우는 것은 보통 그렇게 중요하진 않다. 극단적인 경우 두 토큰이 합쳐져서 새로운 토큰을 만들어내지 않는 한 줄 띄움 없이 전부 붙어있을 수도 있다. 예를 들어 2.6 단원에서 작성했던 `celsius.c` 프로그램에선 `int`와 `main` 사이, `float`와 `fahrenheit` 사이 등을 제외하고는 존재하는 대부분의 스페이스를 제거할 수 있다.

```c
/* Converts a Fahrenheit temperature to Celsius */
#include<stdio.h>
#define FREEZING_PT 32.0f
#define SCALE_FACTOR (5.0f / 9.0f)
int main(void){float fahrenheit, celsius;printf(
"Enter Fahrenheit temperature: ");scanf("%f", &fahrenheit);
celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;
printf("Celsius equivalent: %.1f\n", celsius);return 0;}
```

사실 만약 이 페이지가 더 넓었더라면 `main` 함수 전체를 한 줄에 작성할 수도 있다. 물론 프로그램 전체를 한 줄에 할 수는 없다. 전처리 지시자들은 따로 한 줄에 존재해야하기 때문이다.

프로그램을 이런 식으로 압축하는 것은 매우 지양해야할 행동이다. 사실 프로그램에 빈 공간이나 줄을 띄우는 것은 프로그램의 가독성을 매우 높여준다. 다행히도 C를 작성할 때엔 스페이스, 탭과 개행등을 통해 토큰 사이에 얼마든지 넓은 공간을 만들어낼 수 있다. 이러한 규칙은 프로그램의 레이아웃에 몇 가지 중요한 영향을 미친다.

구문은 여러 줄로 나뉠 수 있다. 다음 구문의 경우 매우 길기 때문에 한 줄에 우겨넣을 수 없다.

```c
printf("Dimensional weight (pounds): %d\n", (volume + INCHES_PER_POUND - 1) / INCHES_PER_POUND);
```

토큰 사이의 스페이스는 가독성을 높혀준다. 이러한 이유로 각 연산자마다 줄을 띄워준다.

```c
volume = height * length * width;
```

쉼표 이후에도 줄을 띄워주도록 하자. 몇몇 프로그래머들은 더 나아가서 괄호나 다른 구두점 사이에도 줄을 띄우기도 한다.

들여 쓰기는 함수 등을 찾기 쉽게 해준다. **[Q&A]** 예를 들어 선언문들이나 구문들이 `main` 함수 안에 제대로 있다는 것을 나타내주기 위해선 들여 쓰기를 해주면 좋다.

빈 줄은 프로그램을 논리의 흐름을 덩어리로 구분하게 해주어 독자로 하여금 프로그램의 구조를 쉽게 파악할 수 있게 해준다. 빈 줄 없는 프로그램은 마치 목차 없는 책을 읽는 것과 같다.

2.6 단원의 `celsius.c` 프로그램에선 위와 같은 조언들을 아주 잘 준수하고 있다. 이 프로그램의 `main` 함수를 한 번 보도록 하자.

```c
int main(void)
{
    float fahrenheit, celsius;
    printf("Enter Fahrenheit temperature: ");
    scanf("%f", &fahrenheit);
    celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;
    printf("Celsius equivalent: %.1f\n", celsius);
    return 0;
}
```

우선 `=`, `-`, `*`와 같이 연산자들 사이에 줄을 띄움으로써 가독성은 물론이고 연산 또한 좀 더 돋보이게 만들어주었음을 알 수 있다. 선언과 구문들을 들여 쓰기함으로써 이들이 `main` 함수에 속한다는 것을 쉽게 알 수 있다. 마지막으로 알 수 있는 것은 `main` 함수가 빈 줄에 의해 다섯 덩어리로 나뉜다는 것이다.

> `fahrenheit`과 `celsius` 변수의 선언
>
> 화씨 온도 입력 받기
>
> celsius의 값 계산하기
>
> 섭씨 온도 출력하기
>
> 운영체제에 값 반환하기

프로그램 레이아웃에 대해 논할 때 필자는 `main()` 밑에 `{` 토큰을 두었고, `}` 또한 따로 한 줄에 배치를 해두었다. `}`을 다른 줄에 배치하는 것은 함수의 말단에 구문을 추가하거나 삭제할 수 있게 만들어주며, `{`와 같은 세로 줄에 있음으로써 `main`이 어디서 끝나는지도 명확하게 알아볼 수 있게 해준다.

마지막으로 조언을 하자면, 토큰 사이에 충분히 공간을 만들 수는 있겠지만 토큰 내에 공간을 만들게 되면 프로그램의 의미가 바뀌거나 에러가 발생하게 된다. 다음 예시를 보라.

```c
fl oat fahrenheit, celsius; /*** WRONG ***/
```

위와 같이 작성하거나

```c
fl
oat fahrenheit, celsius; /*** WRONG ***/
```

다음과 같이 작성을 하게 된다면 프로그램을 컴파일할 때 에러가 발생할 것이다. 스트링 리터럴 내부에 스페이스를 넣게 되면 의미는 변할지라도 에러는 발생하진 않는다. 다만 문자열 내부에 개행을 하는 것, 즉 두 줄 이상짜리 문자열 등은 불가하다.

```c
printf("To C, or not to C:
that is the question.\n"); /*** WRONG ***/
```

문자열을 여러 줄에 걸쳐서 작성하는 방법은 나중 단원에서 배울 것이다.

### Q & A

#### GCC의 약자는 뭔가요? [GCC 컴파일러]

GCC는 원래 "GNU C Compiler"의 약자였는데, 현재는 "GNU Compiler Collection"의 약자입니다. 이름이 바뀐 이유는 현재 GCC는 C 뿐만 아니라 Ada, C, C++, Fortran, Java와 Objective-C와 같은 다양한 언어를 컴파일하기 때문이죠.

#### 알겠어요. 그렇다면 GNU는 또 뭔가요?

GNU는 "GNU's Not Unix!"(GNU는 유닉스가 아닙니다!)의 약자입니다. (GNU는 거뉴라고 발음함) GNU는 리처드 M. 스톨맨이 세운 Free Software Foundation의 프로젝트로, 사용권이 있어 사용하려면 돈을 내야했던 UNIX 소프트웨어에 일종의 저항을 하기 위해 만들었습니다. Free Software Foundation은 공식 홈페이지에 따르면 사용자들은 모두 무료로 소프트웨어를 실행하고, 복사하고, 배포하고, 공부하고, 바꾸고, 개선해야한다고 믿는다고 합니다. GNU 프로젝트에선 UNIX 소프트웨어 주로 사용하던 프로젝트들을 전부 처음부터 다시 새로 짜서 돈을 받지 않고 대중에게 공개했습니다.

GCC와 기타 GNU 소프트웨어들은 Linux 운영체제에 매우 중요합니다. Linux는 운영체제의 커널kernel일 뿐입니다. 커널이라는 것은 프로그램 순서 계획을 담당하고 간단한 입출력 서비스를 담당하는 것입니다. GNU 소프트웨어는 사실상 운영체제를 완전체로 만들어주는 역할을 합니다.

GNU 프로젝트에 좀 더 관심이 생겼다면, www.gnu.org에 직접 방문을 해보세요.

#### 그래서 GCC가 뭐가 중요합니까?

GCC가 중요한 데엔 여러가지 이유가 있습니다. 우선 무료이고, 여러가지 언어를 컴파일할 수 있다는 장점이 있죠. 여러 운영체제에서 돌아가며 자주 사용하는 것을 포함해서 기타 다양한 CPU에 알맞는 코드를 작성해내죠. GCC는 대부분의 UNIX 기반 운영체제, 예를 들어 Linux, BSD, Mac OS X 등에서 주로 사용하는 컴파일러입니다. 또한 상용적인 목적으로 사용할 수 있죠. GCC에 대한 더 많은 정보는 gcc.gnu.org에서 확인하실 수 있습니다.

#### GCC가 프로그램에서 에러를 잘 찾아내나요?

GCC엔 얼마나 철저하게 프로그램을 확인하는지를 제어하는 다양한 커맨드라인 설정들이 있습니다. 이러한 설정을 사용한다면 GCC는 프로그램에서 에러를 발생할 가능성이 있는 곳을 꽤 잘 찾아냅니다. 다음이 몇 가지 자주 사용하는 설정들입니다.

- **`-Wall`** 컴파일러로 하여금 발생할 것 같은 에러를 찾아내면 경고 메시지를 출력하게 한다. (구체적인 경고문을 보고 싶다면 `-W`를 사용할 수 있다. `-Wall`이란 모든 `-W`이라는 의미이다. ) 효과를 제대로 보려면 `-O`와 결합해서 사용하는 것이 좋다.
- **`-W`** `-Wall`에 의해 생성된 경고 메시지보다 좀 더 구체적인 추가 경고 메시지를 출력한다.
- **`-pedantic`** C의 규격에서 필요로 하는 모든 경고문을 출력한다. 규격이 아닌 기능을 사용하는 모든 프로그램을 배제한다.
- **`-ansi`** C의 규격이 아닌 GCC의 기능들을 끄고 보통 사용 불가능한 몇 가지 C 규격인 기능들을 사용 가능하게 만든다.
- **`-std=c89`**
- **`-std=c99`** 컴파일러가 프로그램을 확인할 때 어떤 버전의 C를 사용할지 결정한다. 위의 설정은 주로 아래와 같이 섞어서 사용한다.

```
% gcc -O -Wall -W -pedantic -ansi -std=99 -o pun pun.c
```

#### C가 도대체 어디가 간결하다는거죠? C가 `{`나 `}`말고 차라리 `begin`과 `end`를 사용하고, `int`말고 integer를, 뭐 이런 식으로 사용하는게 더 가독성이 있을 것 같은데요? [2.2 간단한 프로그램의 일반적인 형태]

전설에 따르면 C 언어의 간결함은 당시 언어가 개발되던 벨 랩의 환경에 의한거라고 합니다. C의 첫 컴파일러는 최초의 미니 컴퓨터였던 DEC PDP-11에서 돌아갔습니다. 프로그래머들은 컴퓨터에 연결된 타자기였던 텔레타입teletype을 사용하여 프로그램을 작성하고 기타 명단 등을 작성했습니다. 텔레타입은 당시 초당 최대 10자 밖에 작성하지 못했습니다. 그렇기에 당연히 최대한 글자를 줄이는 것이 이들에게 도움이 됐겠죠?

#### 어떤 C 언어 교재에선 `main` 함수가 `return 0`이 아니라 `exit(0)`으로 끝나던데요, 같은 의미인가요? [함수]

**`main` 함수내에서라면 이 두 구문은 같은 의미**입니다. 둘 다 프로그램을 끝내고 운영체제에 `0`이라는 값을 반환하죠. 둘 중 무엇을 쓸지는 취향 차이입니다.

#### 프로그램이 실행될 때 `main` 함수가 `return` 구문을 사용하지 않은 채로 끝난다면 무슨 일이 일어나나요?

`return` 구문은 반드시 써야하는 건 아닙니다. 없더라도 프로그램은 종료될 것입니다. **[C99]** C89에선 운영체제에 반환되는 값이 정의되지 않지만, C99는 `main` 함수가 우리가 지금까지 다룬 예제에서처럼 만약 `int`를 반환하라고 선언된다면, 기본적으로 운영체제에 `0`을 반환합니다. 그렇지 않다면 프로그램은 특정하지 않은 값을 반환합니다.

#### 컴파일러가 주석을 전체를 지우나요, 아니면 그냥 빈칸으로 대체하나요?

오래된 C 컴파일러들은 주석을 전부 다 지웠었습니다. 다음과 같이 작성할 수도 있었죠.

```
a/**/b = 0;
```

다음 구문을 아래와 같이 해석했습니다.

```
ab = 0;
```

**C 규격에 따르면 컴파일러는 반드시 주석의 각 문자를 스페이스로 대체**합니다. 그래서 위와 같은 꼼수는 통하지 않죠. 만약 위와 같이 작성하면 아래와 같이 잘못된 구문이 탄생합니다.

```
a b = 0;
```

#### 프로그램에 주석 처리를 제대로 안해준 주석이 있는지 어떻게 아나요?

만약 운이 좋다면 컴파일러가 이를 인식하고 컴파일을 안하고 에러를 낼 것입니다. 만약 컴파일이 된다면, 여러가지 방법을 사용해볼 수 있습니다. 디버거를 이용해 한 줄 한 줄 분석해보면 어디서 주석 처리가 제대로 안되었는지 확인할 수 있습니다. 어떤 IDE들은 주석을 다른 일반 코드에 비해 잘 보이게 눈에 잘 띄는 색으로 출력하기도 합니다. 만약 이러한 환경에서 개발을 하고 있다면 쉽게 닫지 않은 주석을 찾을 수 있죠. `lint`와 같은 프로그램 또한 도움이 될 겁니다.

#### 한 주석을 다른 주석 내부에 처리해줄 수 있나요?

최초로 나온 주석(`/*...*/`)으로는 불가능합니다. 예를 들어 다음과 같는 사용할 수는 없습니다.

```
/*
/*** WRONG ***/
*/
```

두번째 줄의 `*/`는 첫번째 줄의 `/*`과 짝 지어지기 때문에 컴파일러는 세번째 줄의 `*/`를 에러 처리합니다.

C가 갖고 있는 이러한 주석을 주석 내부에 처리하지 못하는 문제는 가끔 문제를 일으킵니다. 예를 들어 우리가 짧은 주석이 많으면서 코드가 긴 프로그램을 짠다고 가정해봅시다. 코드를 작성하다가, 예를 들어 코드를 테스트하기 위해서 중간에 명령문 일부를 주석 처리를 해줘서 작동하지 않게 만드려고 할 때가 있을 것입니다. 허나 이것은 옛날 방식으로 주석 처리를 해줄 수 없습니다. **[C99]** C99에서 나온 주석 처리 방식(`//`)은 반대로 옛날 방식의 주석 내부에서 사용할 수 있습니다. 이는 이 새로운 방식의 주석 처리가 갖는 또다른 장점입니다.

나중에 다루겠지만 사실 이런 방식보다 좀 더 깔끔하게 명령문을 작동하지 않게 만드는 방법이 있습니다.

#### `float`의 이름의 유래가 뭔가요? [유형]

`float`은 부동 소수점floating-point의 약자로, 소수점이 존재하는 숫자를 저장할 때 사용하는 겁니다. float 값은 주로 분수fraction(혹은 가수mantissa)와 지수exponent 두 부분으로 나뉘어서 저장됩니다. 12.0은 1.5×2^3 라고 저장될 수 있습니다. 1.5는 분수고 3이 지수죠. 몇몇 프로그래밍 언어는 이러한 유형을 `float` 대신 `real`이라고 부릅니다.

#### 부동 소수점 상수에 끝에 왜 f를 붙여주나요? [유형]

완벽한 대답을 얻고 싶다면 7단원을 참고해보세요. 간단하게 답변드리자면, 소수점을 포함하지만 **`f`가 붙지 않은 상수는 `double` 유형**이 될 수 있습니다. 이는 배정밀도double precision의 약자이지요. `double` 값은 `float` 값보다 더 정확하게 저장되어있습니다. 또한 `double` 값은 `float` 값보다 더 클 수도 있죠. 그렇기 때문에 `float` 변수에 값을 할당할 때 끝에 `f`를 붙여주는 겁니다. 만약 `f`가 없다면 `float` 변수에 할당된 값이 변수가 저장할 수 있는 최대값보다 클 수도 있기 때문에 에러가 발생할 수 있죠.

#### 정말로 식별자의 이름 길이엔 한계가 없나요? [2.7 식별자]

한계가 없으면서 있습니다. C89 표준에 의하면 식별자는 임의적으로 마음대로 길게 해도 된다고 합니다. 하지만 컴파일러들은 31번째 글자까지는 외우는데 그 이후는 안 외워도 됩니다. **[C99]** C99의 경우는 63 글자입니다. 그렇기에 서로 다른 두 이름이 31번째 글자까지는 전부 같다면, 컴파일러는 이 둘을 같은 이름으로 인식할 수 있습니다.

좀 더 일이 복잡해질 수도 있는데요, 외부 링크가 있는 식별자에는 또 특별한 법칙이 적용받습니다. 대부분의 함수 이름들은 이러한 경우에 포함되죠. 이러한 이름들은 링커가 꼭 나중에 확인을 해야하는데요, 좀 오래된 링커들은 오로지 짧은 이름만을 인식합니다. C89의 경우 여섯번째까지만 인식을 하죠. 심지어는 대소문자 구분을 안할 수도 있습니다. 그래서 `abcdefg`랑 `ABCDEFG`를 같다고 인식할 수 있습니다. **[C99]** C99의 경우 31번째까지 인식하고 대소문자 구분을 합니다.

대부분의 컴파일러나 링커는 생각보다 그렇게 엄하게 규격을 따르지 않으므로 이러한 규칙이 실생활에는 그렇게 큰 영향을 미치지 않을 것입니다. 식별자가 너무 길지 않을까를 고민하기보다 식별자가 너무 짧지 않나를 고민하세요.

#### 들여 쓰기를 할 때 줄을 몇 칸 띄워야하나요? [2.8 프로그램의 레이아웃]

흠, 좀 대답하기 어려운 질문이군요. 적게 띄우자니 이게 들여 쓰기인지 제대로 확인이 안되고, 너무 많이 띄우자니 한 줄, 혹은 한 페이지 전체에 적을 수 있는 양이 적어지네요. 대부분의 C 프로그래머들은 8칸, 혹은 탭 한 번으로 들여 쓰기를 하는데, 이건 좀 너무 많다고 생각합니다. 연구 결과 최적의 개수는 세 칸 띄우기라고 하는데요, 대부분의 프로그래머들은 사실 2배수가 아닌 숫자들을 불편해합니다. 저는 개인적으론 세 칸이나 네 칸을 선호하는데, 전 이 책에선 책 내에 잘 알맞기 위해 두 칸만을 띄웠습니다.