# 5. Selection Statements

 C는 그 수많은 연산자들에 비해 구문은 매우 적다. 지금까지 다룬 구문은 딱 두 가지다. `return`문과 표현문이다. C의 구문은 크게 세 가지로 나뉘는데, 그 기준은 그 구문이 구문들을 실행할 때의 순서에 어떤 영향을 미치는가이다.

- **선택문selection statements**. `if`문과 `switch`문은 프로그램이 여러 방법 중 특정한 방법을 실행시킨다.
- **반복문iteration statements**. `while`문, `do`문, 그리고 `for`문은 반복(루프)를 가능케 해준다.
- **도약문jump statements**. `break`문, `continue`문, 그리고 `goto`문은 프로그램이 조건없이 특정한 지점으로 가게 만든다. `return`문 또한 이 유형에 속한다.

이것 외에는 `복합문`과 `null문`이 있다. 복합문이란 여러 개의 구문을 하나의 구문으로 만들어주는 구문이다. null문이란 아무 행동을 하지 않는 구문이다.

본 단원에서는 선택문과 복합문을 다룬다. 6단원에서 반복문과 도약문, 그리고 null문을 다룬다. `if`문을 다루기 이전 우선 `if`가 검사할 수 있는 조건인 논리표현식을 배울 것이다. 5.1단원에서 논리표현식을 구성하는 관계연산자(`<`, `<=`, `>`, `>=`), 동등연산자(`==` , `!=`), 그리고 논리연산자(`&&`, `||`, `!`)를 다룬다. 5.2단원에선 `if`문과 복합문을 다루고, 표현식 내에서 조건을 검사하게 만들어주는 조건연산자(`?:`)를 다룬다. 5.3단원에선 `switch`문을 다룬다.

### 5.1 논리표현식

`if`처럼 C언어의 몇가지 구문들은 표현식의 값이 "참"인지 "거짓"인지 반드시 확인해야한다. 예를 들어 만약 `if`문이 `i < j`와 같은 표현식을 평가해야한다고 하자. 이 표현식의 값이 참이라면 `i`가 `j`보다 값이 작다는 것을 의미한다. 많은 프로그래밍 언어에선 `i < j`와 같은 표현식은 "불리언"이나 "논리"라는 특수한 타입을 띨 것이다. 이러한 타입은 참과 거짓을 유일한 값으로 갖는다. C에서는 이와는 다르게 `i < j`와 같은 비교식의 결과값은 1 혹은 0인 정수다. 1이면 참을 의미하고, 0은 거짓을 의미한다. 이 기본을 바탕으로 논리식을 구성하는 연산자들을 살펴보도록 하자.

#### 관계 연산자

C에서 사용되는 **관계연산자relational operator**(표 5.1)는 수학에서 사용되는 <, >, ≤, ≥와 기본적으로 동일하지만, 표현식에서 사용되었을 때 결과값으로 0 또는 1이 나온다. `10 < 11`의 값은 1이고, `11 < 10`의 값은 0이다.

| 기호 | 의미                           |
| :--- | :----------------------------- |
| `<`  | (왼쪽이 오른쪽보다) 작다; 미만 |
| `>`  | 크다; 초과                     |
| `<=` | 작거나 같다; 이하              |
| `>=` | 크거나 같다; 이상              |

표 5.1: 관계 연산자

관계연산자는 정수와 고정소수를 비교하는데 사용할 수 있으며, 둘을 섞어서 사용해도 된다. 즉, `1 < 2.5`의 값은 1이고, `5.6 < 4`의 값은 0이다.

관계연산자의 평가순서는 산술연산자보다 낮다. 그렇기 때문에 `i + j < k - 1`은 `(i + j) < (k - 1)`과도 같다. 관계연산자는 좌향결합적이다.

> **[!!!]**
>
> C언에서 `i < j < k`와 같은 표현식은 구문상 문제될 것은 없다. 다만 실제로 평가했을 때 우리가 의도했던 의미와는 다른 결과가 나온다. **`<` 연산자가 좌향결합적**이기 때문에 위의 표현식은 다음과 같다.
>
> ```
> (i < j) < k
> ```
>
> 즉, 이 표현식은 우선 `i`가 `j`보다 작은지 평가한다. 그렇게 되면 이 표현식은 `k`가 0 또는 1보다 큰지를 평가하는 식이 된다. 그렇기 때문에 `j`가 `i`보다 크고 `k`보다는 작다는 것을 위와 같이 표현해줄 수 없다. (추후에 배울 개념을 사용한다면, 올바른 식은 `i < j && j < k`이다.)

#### 동등 연산자

관계연산자는 `<`, `>`와 같이 다른 프로그래밍 언어에서 흔히 사용하는 기호를 그대로 사용한다. 허나 **동등연산자equality operator**는 좀 특수한 기호(표 5.2)를 사용한다. "같다"를 의미하는 연산자는 우리가 흔히 사용하는 `=` 기호를 하나로 사용할 수 없다. `=` 기호 하나를 사용하는 연산자는 할당연산자이기 때문에 동등연산은 한 개가 아니라 두 개 붙여서 사용한다. "같지 않음"을 나타내는 연산자는 `!`와 `=`를 붙여서 사용한다.

| 기호 | 의미                   |
| :--- | :--------------------- |
| `==` | (왼쪽이 오른쪽과) 같다 |
| `!=` | 같지 않다              |

표 5.2: 동등 연산자

관계연산자처럼 동등연산자들도 좌향결합적이며 결과값으로 0 또는 1을 낸다. 다만, 동등연산자는 관계연산자보다 평가순서가 낮다. 즉, 표현식

```
i < j == j < k
```

은 다음과 같다.

```
(i < j) == (j < k)
```

`i < j`와 `j < k` 둘이 동시에 참이거나 거짓이라면 위의 표현식은 참이다.

몇몇 똑똑한 프로그래머들은 관계연산자와 동등연산자가 정수값을 반환한다는 점에서 착안해서 다양한 표현식을 만들어낸다. 예를 들어 표현식 `(i >= j) + (i == j)`은 `i`가 `j`보다 작거나, 크거나, 같느냐에 따라 순서대로 0, 1이거나 2를 값으로 갖는다. 이런 복잡한 코드는 일반적으로 좋은 생각은 아닐 뿐더러 프로그램의 가독성을 떨어뜨린다.

#### 논리 연산자

수많은 복잡한 논리식들은 아이러니하게도 가장 간단한 연산자 중 하나인 **논리연산자logical operator**에 의해 탄생된다. 논리연산자(표 5.3)은 and, or, 그리고 not으로 구성된다. `!` 연산자는 단항이고, `&&`와 `||` 연산자는 이항이다.

| 기호 | 의미   |
| :--- | :----- |
| `!`  | 부정   |
| `&&` | 논리곱 |
| `||` | 논리합 |

표 5.3: 논리 연산자

논리연산자는 결과값으로 0 또는 1을 반환한다. 피연산자들은 주로 0이나 1의 값을 갖지만, 필수는 아니다. 논리연산자는 0이 아닌 피연산자를 참으로, 0인 피연산자를 거짓으로 취급한다.

논리연산자는 다음과 같이 행동한다.

- `!expr`: `expr`의 값이 0이라면 1이다.
- `expr1 && expr2`: `expr1`과 `expr2`가 둘 다 0이 아닌 값이면 1이다.
- `expr1 || expr2`: `expr1` 혹은 `expr2`, 혹은 둘 다 0이 아닌 값이면 1이다.

위에 언급하지 않은 경우엔 전부 0을 값으로 갖는다.

`&&`과 `||`은 피연산자를 평가할 때 단락방식으로 평가한다. 다시 말해 왼쪽 피연산자를 우선 평가한 다음 오른쪽 피연산자들 평가한다는 뜻이다. 만약 전체 표현식의 값이 왼쪽 피연산자 하나로 결정날 수 있다면, 오른쪽 피연산자는 평가하지 않는다. 예시로 직접 보자.

```c++
(i != 0) && (j / i > 0)
```

이 표현식의 값을 알려면 우선 왼쪽 피연산자인 `(i != 0)`을 평가해야한다. `i`가 0과 같지 않다면 `(j / i > 0)`을 평가해서 전체 표현식이 참인지 거짓인지 판별해야한다. 하지만 만약 `i`가 0이라면 전체 표현식은 거짓이므로 오른쪽 피연산자인 `(j / i > 0)`을 평가할 필요가 없다. 단락식 평가는 여러모로 유용하다. 만약 단락식 평가가 아니었다면 위의 표현식에서 오른쪽 피연산자에서는 값을 0으로 나누는 에러가 발생했을 것이다.

> **[!!!]**
>
> 논리표현식을 잘못 사용하면 부작용이 발생할 수도 있다. 다행히도 `&&`과 `||`은 단락성을 가지므로 피연산자에서 발생하는 부작용을 피할 수 있다. 다음 표현식을 예로 들겠다.
>
> ```
> i > 0 && ++j > 0
> ```
>
> 표현식을 평가할 때의 부작용으로 `j`는 증가되겠지만, 여기선 부작용이 발생하지 않는다. 만약 `i > 0`이 거짓이라면 `++j > 0`은 평가되지 않기에 **`j`는 증가되지 않는다.** 만약 무조건 증가시키고 싶다면 피연산자의 순서를 바꾸어 `++j > 0 && i > 0`로 표현식을 변경하면 된다. 물론, 아예 `j`를 따로 증가시키는게 더 좋은 방법이다.

**`!` 연산자는 단항 덧셈/뺄셈과 같은 순서**를 갖는다. `&&`과 `||`의 순서는 관계연산자와 동등연산자보다 낮다. `i < j && k == m`은 `(i < j) && (k == m)`을 의미한다. `!` 연산자는 우향결합적이고 `&&`과 `||`은 좌향결합적이다.

### 2 if문

`if`문은 프로그램이 표현식의 값을 사용하여 두 가지 선택지 중 하나를 고르게 만든다. `if`문을 간단하게 표현하면 다음과 같다.

```c
if  (  expression  )  statement
```

여기서 기억해야하는 점은 표현식을 감싸고 있는 괄호는 필수라는 점이다. 괄호는 표현식의 일부분이 아니라 `if`문의 일부분이다. 구어체에선 흔히 if ~ then처럼 말하기에 다른 프로그래밍 언어들도 `then`을 `if`문에 포함시키기도 하는데, C언어에서는 괄호 뒤에 `then`이 오지 않는다.

`if`문이 실행되면 괄호 안의 표현식이 평가된다. 만약 표현식의 값이 0이 아니라면, 즉 참이라면 괄호 뒤의 구문이 실행된다. 다음 예시를 보도록 하자.

```
if (line_num == MAX_LINES)
    line_num = 0;
```

구문 `line_num = 0;`은 조건 `line_num == MAX_LINES`이 0이 아닌 값을 가질 때, 즉 참일 때만 실행된다.

> **[!!!]**
>
> `==`(동등)과 `=`(할당)을 절대로 혼동해서는 안된다.
>
> `if (i == 0) ...` `if (i = 0) ...`
>
> 위 구문은 `i`가 0과 같은지를 판별하지만, 아래 구문은 `i`에 0을 할당한 다음, 그 결과값이 0이 아닌 값인지를 판별한다. 즉, 이 경우 거짓이 반환된다.
>
> `==`과 `=`을 헷갈려하는 것은 C언어로 코딩할 때 자주하는 실수이다. 사람들은 수학시간에 =를 "~와 같다"라는 의미로 사용해 왔고, 실제로 몇몇 프로그래밍 언어에서는 =를 같다라는 의미로 사용한다. 몇몇 컴파일러는 `==`이 와야하는 자리에 `=`이 오면 경고메세지를 내보내기도 한다. **[Q & A]**

어떤 변수가 특정 구간에 포함되는지를 판별할 때 `if`문을 자주 사용한다. 0≤`i`<`n`을 판별한다고 할 때, 프로그래머들은 다음과 같이 주로 코딩한다.

**[관용구]** `if (0 <= i && i < n) ...`

이 반대 조건의 경우, 즉 `i`가 위의 범위 밖임을 판별하려면 다음과 같이 나타낸다.

**[관용구]** `if (i < 0 || i >= n) ...`

`&&` 연산자가 아닌 `||` 연산자가 쓰였다는 부분에 주목할 필요가 있다.

#### 복합문

위에서 다룬 간단한 `if`문의 구조를 다시 살펴보면 뒤에 나오는 구문이 구문"들"이 아니라 구문 하나이다.

```c
if  (  expression  )  statement
```

만약 `if`문이 여러 구문을 제어하게 만들고 싶다면 어떻게 해야할까? 이럴 때 사용하는 구문이 바로 **복합문compound statement**이다. 복합문은 다음과 같은 구조를 갖고 있다.

```c
{  statements  }
```

여러 개의 구문을 중괄호로 감싸면 컴파일러는 이를 하나의 구문으로 취급한다.

복합문이 어떻게 생겼는지 예시로 살펴보자.

```c
{ line_num = 0; page_num++; }
```

사실 이렇게 한 줄에 전부 사용하지는 않는다. 가독성을 위해 복합문을 구문 당 한 줄을 사용해 여러 줄에 걸쳐 사용한다.

```c
{
    line_num = 0;
    page_num++;
}
```

복합문 내에 있는 구문이라고 하더라도 반드시 세미콜론으로 끝나야한다. 다만, 복합문 자체는 세미콜론으로 끝나지 않는다.

복합문이 `if`에 사용할 땐 다음과 같이 사용한다.

```c
if (line_num == MAX_LINES) {
    line_num = 0;
    page_num++;
}
```

복합문은 루프문과 같이 구조상 구문 한 개만 사용해야하지만 실제로는 여러 구문이 필요할 때 자주 사용된다.

#### else 절

`if`문은 `else`문을 포함할 수 있다.

```c
if (  expresssion  ) statement else statement
```

`else` 뒤에 나오는 구문은 괄호 안의 표현식의 값이 0일 때 실행된다.

`else`문 예제 하나를 살펴보자.

```c
if (i > j)
    max = i;
else
    max = j;
```

안쪽 구문은 둘 다 세미콜론으로 끝난다.

`if`문이 `else`문을 포함할 때 가독성의 문제가 발생한다. `else`문을 어디에 위치시켜야 보기 좋은가? 많은 C 프로그래머들은 위의 예시처럼 `if`와 같은 위치에 표기한다. 안쪽 구문들은 `if`나 `else`와 같은 줄에 써도 될만큼 짧지 않은 이상 주로 들여쓴다.

```c
if (i > j) max = i;
else max = j;
```

`if`문 안에 어떤 구문이 와서는 안되는 것과 같은 규칙은 없다. 즉, `if`문 안에는 아무 구문이나 와도 되고, `if`문 안에 `if`문을 넣을 수도 있을 뿐더러 실생활에서 자주 사용한다. 다음 `if`문 예제를 확인해보자. 다음 코드에선 `i`, `j`, `k` 중 가장 큰 값을 찾아내어 `max`에 그 값을 저장한다.

```c
if (i > j)
    if (i > k)
        max = i;
    else
        max = k;
else
    if (j > k)
        max = j;
    else
        max = k;
```

`if`문은 얼마든지 중복시킬 수 있다. `if`문을 중복시킬 때 `else`문을 해당 `if`문과 같은 줄에 위치시키면 위와 같이 가독성이 훨씬 높아진다. 위와 같은 중복이 그래도 보기 불편하면, 중괄호를 사용하면 된다.

```c
if (i > j) {
    if (i > k)
        max = i;
    else
        max = k;
}   else {
    if (j > k)
        max = j;
    else
        max = k;
}
```

굳이 중괄호를 사용하지 않아도 될 때에도 굳이 사용해주는 것은 마치 표현식에서 괄호를 사용하는 것과 같다. 프로그램의 가독성을 늘려줄 뿐만 아니라 컴파일러가 프로그래머의 의도를 잘못 해석하여 에러가 생길 가능성을 줄여준다.

몇몇 프로그래머들은 모든 `if`문(사실 `if`문 뿐만 아니라 모든 반복문도 해당된다)에 최대한 많은 중괄호를 사용해준다. 즉, `if`문의 구문들, `else`문의 구문들을 전부 중괄호로 묶어준다.

```c
if (i > j) {
    if (i > k) {
        max = i;
    }   else {
        max = k;
    }
}   else {
    if (j > k) {
        max = j;
    }   else {
        max = k;
    }
}
```

굳이 중괄호를 사용하는 것은 두 가지 장점이 있다. 우선 `if`문이나 `else`문의 구문에 손쉽게 다른 구문들을 추가할 수 있다. 즉, 프로그램의 수정이 매우 용이하다. 두번째는 `if`문이나 `else`문을 사용할 때 깜빡하고 중괄호를 사용하지 않아 발생하는 에러를 방지할 수 있다.

#### 계단식 if문

조건문을 사용할 때 언제나 조건이 한 개일 수는 없다. 여러가지 조건을 판별해보고, 참인 값이 나오면 거기서 멈추는 경우가 대부분일 것이다. 이럴 때 "계단식"으로 `if`문을 사용하는 것이 좋다. 예를 들어 `n`이 0보다 작은지, 같은지, 큰지를 판별하는데 계단식 `if`문을 사용해보겠다.

```c
if (n < 0)
    printf("n은 0보다 작다\n");
else
    if (n == 0)
        printf("n은 0과 같다\n);
    else
        printf("n은 0보다 크다\n");
```

위의 예시에선 두번째 `if`문처럼 `if`문 안에 포함된 `if`문을 들여썼지만, 실제로는 들여쓰지 않고 `else`와 같은 줄에 `if`문을 작성한다.

```c
if (n < 0)
    printf("n은 0보다 작다\n");
else if (n == 0)
    printf("n은 0과 같다\n);
else
    printf("n은 0보다 크다\n");
```

이런식으로 계단식 `if`문을 구조화하면 다음과 같이 표현할 수 있다.

```c
if (  expression  )
    statement
else if (  expression  )
    statement
...
else if (  expression  )
    statement
else
    statement
```

마지막 두 줄(`else`와 statement)은 필수는 아니다. 이런 방식의 들여쓰기는 조건의 개수가 많아질 때 계단식 `if`문이 과도하게 들여써지는 현상을 방지해준다. 또한 독자로 하여금 본 구문이 계단식으로 조건을 판별하고 있음을 쉽게 보일 수 있다.

계단식 `if`문은 새로운 유형의 구문이 아니라 기존의 것들을 조합해서 활용한 구문이다. 평범한 `if`문 안에 또다른 `if`문과 `else`문이 있었을 뿐이다(또한 그 또다른 `if`문 안에도 마찬가지로 다른 `if`문과 `else`문을 포함할 수 있을 것이고, 이것은 무한대로 적용할 수 있다.).

#### [프로그래밍] 중개 수수료 계산하기

주식을 브로커를 통해 사고 파려면 수수료가 발생한다. 이때 수수료는 거래된 주식의 가치에 따라 증가폭이 달라진다. 브로커가 다음 표와 같이 수수료를 책정한다고 하자.

| 거래 규모             | 수수료율     |
| :-------------------- | :----------- |
| $2,500 미만           | $30 + 1.7%   |
| 2,500−2,500−6,250     | $56 + 0.66%  |
| 6,250−6,250−20,000    | $76 + 0.34%  |
| 20,000−20,000−50,000  | $100 + 0.22% |
| 50,000−50,000−500,000 | $155 + 0.11% |
| $500,000 초과         | $255 + 0.09% |

최소 수수료는 $39이다. 여기서 우리가 작성할 프로그램은 사용자가 거래 규모를 입력하면 이에 따른 수수료를 출력하는 프로그램이다.

Enter value of trade: 30000
Commission: $166.00

이 프로그램의 핵심은 계단식 `if`문을 적절하게 사용하여 거래 규모를 정확한 범위의 조건에 떨어지게 만드는 것이다.

**broker.c**

```c
/* Calculates a broker's commission */

#include <stdio.h>

int main(void)
{
    float commission, value;

    printf("거래값를 입력하시오: ");
    scanf("%f", &value);

    if (value < 2500.00f)
        commission = 30.00f + .017f * value;
    else if (value < 6250.00f)
        commission = 56.00f + .0066f * value;
    else if (value < 20000.00f)
        commission = 76.00f + .0034f * value;
    else if (value < 50000.00f)
        commission = 100.00f + .0022f * value;
    else if (value < 500000.00f)
        commission = 155.00f + .0011f * value;
    else
        commission = 255.00f + .0009f * value;

    if (commission < 39.00f)
        commission = 39.00f;

    printf("수수료: $%.2f\n", commission);

    return 0;
}
```

위의 계단식 `if`문과 달리 아래의 경우처럼 조건을 달리 작성할 수도 있다.

```c
if (value < 2500.00f)
    commission = 30.00f + .017f * value;
else if (value >= 2500.00f && value < 6250.00f) // 변경된 부분
    commission = 56.00f + .0066f * value;
else if (value >= 6250.00f && value < 20000.00f) // 변경된 부분
    commission = 76.00f + .0034f * value;
...
```

프로그램이 동일한 방식으로 작동은 하겠지만, 굳이 위의 조건들을 추가해줄 필요는 없다. 첫번째 `if`는 `value`가 2500보다 작은지를 판별하여 만약 작다면 그에 따른 수수료를 계산할 것이다. 그 다음 두번째 `if`의 조건인 `(value >= 2500.00f && value < 6250.00f)`을 맞닥뜨리게 되는데, `value`는 여기선 (역자. `else`문 때문에)무조건 2500보다 크거나 같아야한다. 어차피 2500보다 크거나 같기 때문에 해당 조건을 판별할 필요가 없다.

#### 누구의 `else`인가?

`if`문을 여러 겹으로 사용할 땐 `else`문을 조심해야한다. 다음 예시로 어떤 점을 조심해야하는지 직접 눈으로 확인해보자.

```c
if (y != 0)
    if (x != 0)
        result = x / y;
else
    printf("에러: y는 0과 같습니다\n");
```

여기서 `else`의 짝은 두 `if` 중 누구일까? 들여쓰기를 안한걸로 봐서는 밖의 `if`와 짝인 것처럼 보인다. 하지만 C언어에선 가장 가까운 `if`와 `else`가 서로 짝지어진다. 위 코드에서 `else`는 밖의 `if`가 아니라 안의 `if`와 짝지어진다. 만약 안의 `if`와 `else`를 짝지어주려면 아래와 같이 코드를 짜야한다.

```c
if (y != 0)
    if (x != 0)
        result = x / y;
    else
        printf("에러: y는 0과 같습니다\n");
```

만약 원래 의도한대로 `else`를 짝지어주려면 아래와 같이 코드를 다시 짜야한다.

```c
if (y != 0) {
    if (x != 0)
        result = x / y;
}   else
        printf("에러: y는 0과 같습니다\n");
```

위의 예제를 통해 배울 수 있는 점은 중괄호의 중요성이다. 애초에 첫번째 예제를 작성하기 이전에 중괄호로 작성하는 버릇을 들였다면 위와 같은 실수를 하지 않게 된다.

#### 조건 표현식

C의 `if`문은 조건의 결과값에 따라 한 개 또는 여러 개의 행동을 할 수 있게 해준다. 여기에 더해 C에선 표현식이 조건의 결과값에 따라 한 개 또는 여러 개의 값을 만들어내는 연산자가 존재한다.

**조건연산자conditional operator**는 두 가지 기호(`?`와 `:`)로 구성되어있으며, 다음과 같이 동시에 사용된다.

```c
expr1 ? expr2 : expr3
```

`expr1`, `expr2`, `expr3`은 임의의 표현식이다. 이 표현식 전체를 **조건표현식conditional expression**이라고 부른다. 조건연산자는 C언어 중에서도 매우 독특한 연산자인데, 무려 세 가지의 피연산자를 필요로한다. 이렇기 때문에 **삼중연산자ternary operator**라고 부른다.

조건표현식 `expr1 ? expr2 : expr3`을 해석하자면 "만약 expr1이면 expr2이고, 그 외의 경우엔 expr3이야"이다. 본 표현식은 다음 순서대로 평가가 진행된다. 우선 `expr1`을 평가한다. 만약 결과값이 0이 아니라면 `expr2`를 평가하고, 그 결과값은 조건표현식 전체의 결과값이 된다. 만약 `expr1`의 값이 0이라면 `expr3`의 값이 조건표현식의 값이 된다.

다음 예제로 조건연산자를 좀 더 이해해보자.

```c
int i, j, k;

i = 1;
j = 2;
k = i > j ? i : j;           /* k의 값은 2이다 */
k = (i >= 0 ? i : 0) + j;    /* k의 값은 3이다 */
```

`k`의 첫번째 할당에 사용된 조건표현식 `i > j ? i : j`은 `k`에 `i`혹은 `j`의 값을 둘의 대소관계에 따라 할당한다. `i`의 값은 1이고 `j`의 값이 2이므로 `i > j`은 거짓이다. 즉, 조건표현식의 값은 2가 되고, 이는 `k`에 할당된다. 두번째 할당에선 `i >= 0`가 참이므로 조건표현식 `(i >= 0 ? i : 0)`의 값은 1이다. 여기서 1과 `j`의 값인 2가 더해여 3이 나오고, 이는 `k`에 할당된다. 참고로 여기에서 사용된 괄호는 필수이다. 조건연산자의 평가순서는 할지금까지 다룬 그 어떤 연산자보다도 낮다.

**조건표현식**은 프로그램을 간결하게 해주지만 가독성을 떨어뜨릴 수 있다. 그렇기 때문에 사용하지 않는 것이 좋지만, 특정 경우에선 사용하는 것이 간편할 수 있다. 대표적인 예시가 `return`문이다.

```c
if (i > j)
    return i;
else
    return j;
```

대부분의 프로그래머들은 위보다는 아래처럼 코드를 작성한다.

```c
return i > j ? i : j;
```

`printf` 함수 또한 조건표현식을 사용함으로써 상당히 간편하게 코드를 짤 수 있다.

```c
if (i > j)
    printf("%d\n", i);
else
    printf("%d\n", j);
```

위와 같이 작성하기 보다는 다음과 같이 간단하게 작성할 수 있다.

```c
printf("%d\n", i > j ? i : j);
```

조건표현식은 특정 매크로정의에서도 자주 사용된다.

#### C89에서의 불 방식의 값

수년간 C언어는 제대로된 불리언형이 없었고, C89 표준도 마찬가지였다. 많은 프로그램은 참과 거짓을 판별하는 값을 갖는 형식이 필요했기에 불리언형이 없는 것은 여간 골치거리가 아니었다. C89에서 이를 해결하기 위한 방법 중 하나는 `int` 변수를 정의해서 여기에 0 또는 1을 할당하는 것이다.

```c
int flag;

flag = 0;
...
flag = 1;
```

물론 이러한 방법이 가능하기는 하지만 가독성에 그렇게 도움되지는 않는다. `flag` 하나만 보고 이게 불리언형만 저장하고 있고, 0과 1이 거짓 혹은 참을 나타내는지 알 수 있겠는가.

좀 더 가독성을 높이기 위한 다른 방법은 `TRUE`와 `FALSE`라는 이름으로 매크로정의를 하는 것이다.

```c
#define TRUE 1
#define FALSE 0
```

이제 `flag`라는 변수가 좀 더 자연스럽게 보일 것이다.

```c
flag = FALSE;
...
flag = TRUE;
```

`flag`가 참인지를 판별하려면 다음과 같이 작성해주면 된다.

```c
if (flag == TRUE) ...
```

혹은 그냥 다음과 같이 간단하게 작성할 수도 있다.

```c
if (flag) ...
```

밑에 형태처럼 작성하는 것이 사실 더 낫다. 더 정확할 뿐만 아니라 `flag` 변수가 0이나 1이 아닌 값을 가져도 작동하기 때문이다.

`flag` 변수가 거짓인지 판별하려면 다음과 같이 작성해주면 된다.

```c
if (flag == FALSE) ...
```

혹은 그냥 다음과 같이 간단하게 작성할 수도 있다.

```c
if (!flag) ...
```

이 방법을 좀 더 확장한다면 타입처럼 사용할 수 있는 매크로를 정의할 수도 있을 것이다.

```c
#define BOOL int
```

`BOOL`을 불리언형의 변수를 선언할 때 `int` 대신 사용할 수 있다.

```c
BOOL flag;
```

이제 드디어 `flag`가 단순히 정수형 변수로 보이지 않고 확실한 불리언형이라는 것으로 읽힌다. (컴파일러는 `flag`를 물론 `int`형 변수로 취급할 것이다) 나중 단원에서 C89에서 형식정의type definition와 열거enumeration라는 좀 더 나은 방법으로 불리언형을 제작하는 방법을 배울 것이다. (역자: 물론 C가 아닌 C++을 배울 여러분은 걸러도 된다)

#### C99에서의 불 방식의 값

C99에선 `_Bool` 형식을 제공하기에 사실상 불리언형이 존재한다. C99에서 불리언형 변수를 정의하려면 다음과 같이 해주면 된다. **[Q & A]**

```c
_Bool flag;
```

`_Bool`은 정수형이다.(정확히 말하면 무부호 정수형이다.) 그렇기 때문에 `_Bool`형 변수는 사실상 `int`형 변수이다. 다만 일반적인 정수형 변수와는 달리 `_Bool`형 변수에는 0 또는 1만 할당될 수 있다. 일반적으로 `_Bool`형 변수에 0이 아닌 값을 저장하게 되면 이는 1로 변환되어 저장된다.

```c
flag = 5; /* flag엔 1이 할당된다 */
```

`_Bool`형 변수로 산술연산을 할 수는 있다(하지 않는 편이 좋다). 또한 `_Bool`형 변수를 출력하는 것 또한 가능하다(0 또는 1이 출력될 것이다). 물론, 당연히 `if`문의 조건에 사용될 수 있다.

```c
if (flag)    /* flag의 값이 1인지 판별한다 */
    ...
```

`_Bool`형 뿐만 아니라 C99에는 ``이라는 이름의 헤더파일을 제공한다. 이 헤더파일을 통해 불리언형 변수를 좀 더 손쉽게 다룰 수 있다. 이 헤더파일에는 `bool`이라는 이름의 매크로가 존재하고, 이는 `_Bool`을 의미한다. 만약 ``를 프로그램에 추가해주었다면 다음과 같이 코드를 작성할 수 있다.

```c
bool flag; /* _Bool flag;와 같은 의미이다 */
```

헤더파일은 또한 `true`와 `false`라는 매크로를 갖고 있고, 이는 각각 1과 0을 의미한다. 즉, 이를 사용하면 다음과 같이 코드를 작성할 수 있다.

```c
flag = false;
...
flag = true;
```

헤더는 매우 간편하기 때문에 앞으로 프로그램에서 불리언형 변수가 필요할 때마다 사용하겠다.

