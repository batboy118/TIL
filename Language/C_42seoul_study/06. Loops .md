# 6. Loops

 5 단원에선 C의 선택문인 `if`문과 `switch`문을 다뤘다. 본 단원에선 C에서 루프를 생성시켜주는 반복문을 다룬다.

**루프loop**란 구문(**루프 본문loop body**)을 반복해서 실행하는 구문이다. C의 모든 루프는 **제어식controlling expression**을 필요로한다. 루프 본문이 실행될 때마다(루프의 한 **반복iteration**) 제어식이 평가된다. 만약 제어식이 참, 즉 0이 아닌 값을 갖는다면 루프는 계속해서 실행된다.

C엔 총 세 가지 반복문이 있다. `while`문, `do`문, `for`문이다. 이 세 가지 반복문은 순서대로 6.1, 6.2, 6.3 단원에서 다룰 것이다. `while`문은 루프 본문 이전에 제어식이 평가되는 루프에 사용한다. `do`문은 반대로 루프 본문이 실행이 된 다음 제어식이 평가되는 루프에 사용한다. `for`문은 루프가 특정 변수를 증감시킬 때 사용하기 유용하다. 6.3 단원에선 `for`문에 사용되는 쉼표연산자도 다룬다.

마지막 두 단원에선 루프의 접속에 사용되는 기능들을 다룬다. 6.4 단원에선 `break`문, `continue`문, `goto`문을 다룬다. `break`문은 루프에서 벗어나며 제어를 루프 다음 구문으로 넘긴다. `continue`문은 본 구문 이하의 루프 반복을 무시한다. `goto`문은 함수 내 특정 구문으로 도약한다. 6.5 단원에선 본문이 없는 루프를 생성할 때 사용되는 null문을 다룬다.

### 6.1 while문

`while`문은 C언어의 반복문 중에선 가장 간단하면서도 중요한 구문이다. `while`문은 다음과 같은 구조를 갖는다.

```c
while (  expression  )  statement
```

괄호 내의 표현식이 제어식이고, 괄호 이후에 나오는 구문이 루프 본문이다. 다음 예제로 실습해보자.

```c
while (i < n)    /* 제어식 */
    i = i * 2;     /* 루프 본문 */
```

괄호는 필수이며, 오른쪽 괄호와 루프 본문 사이에는 아무 것도 추가되지 않는다(몇몇 프로그래밍 언어는 `do`를 필요로 한다).

`while`문이 실행되면 우선 제어식이 평가된다. 제어식의 값이 0이 아니라면(참) 루프 본문이 실행된 다음 제어식을 다시 평가한다. 이런 방식으로, 우선 제어식을 확인하고, 루프 본문으로 넘어가는 방식이 제어식의 값이 0이 될 때까지 계속 반복된다.

`while`문을 사용하는 예제를 좀 더 알아보자. 어떤 수 `n`보다 크거나 같은 수 중 가장 작은 2의 제곱수를 찾아보자.

```c
i = 1;
while (i < n)
    i = i * 2;
```

**`n`의 값이 10**이라고 가정하자. 이때 `while`문이 실제로 어떻게 동작하는지 논리를 따라가보자.

| statement    | 결과               |
| :----------- | :----------------- |
| `i = 1;`     | `i`의 값은 1이다.  |
| `i < n`인가? | 참; 다음 단계.     |
| `i = i * 2;` | `i`의 값은 2이다.  |
| `i < n`인가? | 참; 다음 단계.     |
| `i = i * 2;` | `i`의 값은 4이다.  |
| `i < n`인가? | 참; 다음 단계.     |
| `i = i * 2;` | `i`의 값은 8이다.  |
| `i < n`인가? | 참; 다음 단계.     |
| `i = i * 2;` | `i`의 값은 16이다. |
| `i < n`인가? | 거짓; 루프 종료.   |

제어식 `(i < n)`이 참이면 루프는 계속해서 돌아간다. 식이 거짓이 될 때 루프는 종료되며, `i`의 값은 우리가 의도했던 것처럼 `n`보다 크거나 작을 것이다.

루프 본문은 반드시 한 개의 구문이어야 하지만 이는 단순히 기술적인 문제일 뿐이다. 여러 구문을 실행시키고 싶다면 단순히 중괄호를 추가하여 복합문을 사용하면 된다.

```c
while (i > 0) {
    printf("T 빼기 %d, 세는 중\n", i);
    i--;
 }
```

중괄호가 굳이 필요하지 않은 상황이더라도 몇몇 프로그래머들은 중괄호를 추가해준다.

```c
while (i < n) {    /* 중괄호 사용 가능하나 필수는 아님 */
    i = i * 2;
}
```

다음 두번째 예제는 "카운트다운" 메세지를 연속으로 출력한다. 이 예제를 통해 반복문이 어떻게 실행되는지 확인해보도록 하자.

```c
i = 10;
while (i > 0) {
    printf("T 빼기 %d, 세는 중\n", i);
    i--;
}
```

`while`문이 실행되기 전 `i`에 10이라는 값이 할당된다. 10이 0보다 크므로 루프 본문이 실행되며, `T 빼기 10, 세는 중`이라는 메세지가 출력되고 `i`의 값이 감소된다. 그 다음 조건 `i > 0`가 다시 판별될 것이다. 9는 0보다 크므로 루프 본문이 다시 실행된다. 이 과정은 `T 빼기 1, 세는 중`이라는 메세지가 출력될 때까지 실행되고 `i`의 값이 0이 될 때까지 지속된다. 이 다음에는 조건 `i > 0`이 거짓이므로 루프가 종료된다.

이 카운트다운 예제를 통해 다음과 같은 `while`문의 특징을 알아볼 수 있다.

- 제어식이 거짓이면 `while`문의 루프가 종료된다. 그러므로 루프가 제어식 `i > 0`에 의해 종료되었다는 것은 `i`가 반드시 0보다 작거나 같아야한다. (그렇지 않다면 루프는 종료되지 않고 계속해서 실행될 것이다!)
- `while`문의 루프 본문이 아예 실행되지 않을 수도 있다. 제어식이 루프 본문이 실행되기 이전에 판별되므로 루프 본문이 단 한 번도 실행되지 않을 수도 있다. 만약 카운트다운 루프에서 `i`의 값이 음수나 0이였다면 루프는 아무 것도 하지 않을 것이다.
- `while`문은 다양한 방식으로 작성될 수 있다. 예를 들어 카운트다운 루프를 다음과 같이 `i`를 `printf` 함수의 호출 내에서 감소시켜주어 루프의 길이를 압축시킬 수 있다.

```c
while (i > 0) {
    printf("T 빼기 %d, 세는 중\n", i--);
}
```

**[Q & A]**

#### 무한루프

만약 제어식이 언제나 0이 아닌 값을 갖는다면, `while`문은 종료되지 않는다. 사실 많은 C언어 프로그래머들은 0이 아닌 상수를 제어식으로 사용하여 이런 식의 **무한루프infinite loop**를 의도적으로 만들어낸다.

**[관용구]** `while (1) ...`

위와 같은 `while`문은 루프 본문에 루프 밖으로 벗어나게 해주는 구문(`break`, `goto`, `return`)이 없거나 프로그램이 종료되게하는 함수를 호출하지 않는다면 평생 실행될 것이다.

#### [프로그래밍] 제곱표 출력하기

제곱수를 표 형식으로 출력하는 프로그램을 만들어보자. 우선 사용자로부터 숫자 n을 받는다. 그 다음엔 n개 줄을 출력할 것이고, 1에서 n까지 각 줄에는 해당 번째 숫자와 그 숫자의 제곱수를 출력할 것이다.

> 본 프로그램은 제곱수 표를 출력합니다.
> 본 표의 크기를 결정해주세요: 5
> 1 1
> 2 4
> 3 9
> 4 16
> 5 25

이 프로그램을 제곱수를 출력하고 싶은 만큼의 개수를 `n`이라는 변수에 저장하게 만들자. 숫자 `i`와 그 숫자의 제곱수를 지속적으로 출력하는 루프가 필요할 것이고, 시작은 `i`가 1과 같은 때이다. `i`가 `n`보다 작거나 같을 때 루프는 지속적으로 실행될 것이다. 매 루프가 실행될 때마다 `i`에 1을 더해줄 것이다.

우선 루프를 `while`문으로 작성하자(뭐, 당연한 것 아니겠는가. 배운 반복문이 `while`문 밖에 없는데). 아래는 프로그램의 코드이다.

**square.c**

```c
/* while문을 활용해 제곱수 표를 출력하라 */

#include <stdio.h>

int main (void)
{
    int i, n;

    printf("본 프로그램은 제곱수 표를 출력합니다.\n");
    printf("본 표의 크기를 결정해주세요:  ");
    scanf("%d", &n);

    i = 1;
    while (i <= n) {
        printf("%10d%10d\n", i, i * i);
        i++;
    }

    return 0;
}
```

위의 실행 예제에도 보이듯이, `square.c` 프로그램은 숫자를 매우 규칙적으로 출력한다. 이는 변환규격을 `%d` 대신 `%10d`를 사용함으로써 얻는 효과다. 출력 길이가 지정된다면 `printf`는 숫자를 우측정렬한다.

#### [프로그래밍] 수열의 합 구하기

두번째 예제로는 사용자가 입력한 정수열의 합을 출력하는 프로그램이다. 프로그램을 실행하면 다음과 같은 모습을 띨 것이다.

> 본 프로그램은 정수열의 합을 출력한다.
> 정수 여러 개를 입력하라 (수열을 끝내려면 0을 입력하라): 8 23 71 5 0
> 정수열의 합: 107

딱 봐도 `scanf`로 숫자를 읽어야할 때와 수열의 합을 구할 때 루프가 필요해보인다.

`n`이 읽은 숫자라 하고 `sum`이 수열의 합이라고 하자. 그러면 다음과 같이 코드를 짤 수 있다.

**sum.c**

```c
/* 수열의 합을 구한다 */

#include <stdio.h>

int main (void)
{
    int n, sum = 0;

    printf("본 프로그램은 정수열의 합을 출력한다.\n");
    printf("정수 여러 개를 입력하라 (수열을 끝내려면 0을 입력하라): ");

    scanf("%d", &n);
    while (n != 0) {
        sum += n;
        scanf("%d", &n);
    }
    printf("정수열의 합: %d", sum);

    return 0;
}
```

숫자를 입력받은 다름 조건 `n != 0`을 판별해주었다. 이를 통해 루프가 가능한 순간 바로 종료되게 만들어주었다. 또한 `scanf`를 두 번, 그것도 똑같이 호출해주었는데, `while`문을 사용할 때 자주 발생하는 중복이다.



### 6.2 do문

`do`문은 사실상 `while`을 얘기할 때 빼놓을 수 없을 정도로 관련깊은 구문이다. 사실 `do`문은 사실상 `while`문과 동일하다고 할 수 있다. 다만 제어식을 루프 본문 실행 이후에 판별할 뿐이다. `do`문의 일반형은 다음과 같다.

```c
do   statement   while   (  expression  )   ;
```

`while`문과 동일하게 `do`의 본문 또한 단 한 개의 표현식(물론 당연히 복합문일 것이다)으로 이루어져 있고, 제어식 또한 괄호로 감싸야 한다.

`do`문이 실행되면 우선 루프 본문이 먼저 실행이 되고 나서 제어식이 평가된다. 만약 표현식이 0이 아닌 값을 갖는다면, 루프 본문은 다시 실행되고 표현식은 다시 한 번 더 평가된다. 루프 본문이 실행된 **이후** 제어식의 값이 0이라면 `do`문은 종료된다.

6.1절의 "카운트다운" 예제가 기억나는가? 이번엔 `do`문으로 동일한 예제를 다시 프로그래밍해보자.

```c
i = 10;
do {
    printf("T 빼기 %d, 세는 중\n", i);
    --i;
} while (i > 0)
```

위의 `do`문이 실행이 되면 우선 `T 빼기 10, 세는 중`이라는 메세지가 출력되고 `i`는 감소된다. 그 뒤 조건 `i > 0`가 평가된다. 9는 0보다 크므로 루프 본문은 한 번 더 실행이 된다. 이 과정은 `T 빼기 1, 세는 중`이 출력되고 `i`가 0이 될 때까지 지속된다. 이제 `i > 0`를 판별하면 거짓이 나오므로 루프는 종료된다. 이 예제가 보여주듯 `do`문을 `while`문과 구분하기란 여간 쉬운 일이 아니다. 둘의 차이점은 `do`문의 본문은 적어도 한 번은 실행된다는 점이다. `while`문은 애초에 제어식이 0이면 본문을 무시하고 진행하기 때문이다.

추가적으로, **모든** `do`문에는 필요하지 않더라도 꼭 중괄호를 작성해주는 것이 좋다. 만약 중괄호를 작성하지 않는다면 `do`문인지 `while`문인지 구분하기가 쉽지 않다.

```c
do
    printf("T 빼기 %d, 세는 중\n", i--);
while (i > 0)
```

아무 생각없이 읽으면 뒤에 나오는 `while`을 보고 `while`문의 시발점이라고 착각하기 쉽다.

#### [프로그래밍] 정수의 자릿수 계산하기

물론 C언어에선 `do`문보다는 `while`문이 더 자주 사용되기는 하지만, 루프 본문을 반드시 한 번은 실행시켜야하는 경우엔 상당히 유용하다. 이 유용성을 좀 더 알아보기 위해 사용자가 입력한 정수의 자릿수를 출력하는 예제를 보자.

> Enter a nonnegative integer: 60
> The number has 2 digit(s).

여기서 우리가 사용할 전략은 간단하다. 입력값이 0이 될 때까지 10으로 나누는거다. 나눈 횟수가 곧 자릿수가 될 것이다. 즉, 입력값이 0이 될 때까지 몇 번을 나눠야하기 모르기 때문에 당연히 루프가 필요해보인다. 여기서 문제는 `while`문을 사용할 것인지, `do`문을 사용할 것인지에 대한 해답이다. 결론만 얘기하자면 `do`문이 좀 더 유용해보인다. 왜냐하면 심지어 0조차도 적어도 자릿수가 **최소 1**이기 때문이다. 코드를 직접 보도록 하자.

**numdigits.c**

```c
/* 한 정수의 자릿수를 계산한다 */

#include <stdio.h>

int main(void) {
    int digits = 0, n;

    printf("음수가 아닌 정수를 입력하시오: ");
    scanf("%d", &n);

    do {
        n /= 10;
        digits++;
    } while (n > 0);

    printf("자릿수는 %d이다.\n", digits);

    return 0;
}
```

그럼 이제 왜 `do`문이 더 적합한지에 대해서 알아보자. 우선 위의 `do` 루프를 `while` 루프로 재작성해보자.

```c
while (n > 0) {
    n /= 10;
    digits++;
}
```

만약 애초에 `n`이 0이었다면 루프는 실행조차 되지 않고 프로그램은 다음을 출력할 것이다.

> 자릿수는 0이다.

### 6.3 for문

이번 단원에서는 C언어의 마지막 반복문인 `for`문에 대해서 다뤄볼 것이다. 구조가 어려워보인다고 해서 겁먹지 말라. 사실상 `for`문이 루프의 상당부분을 차지한다. 특히 `for`문은 숫자를 세야하는 변수가 있을 때 상당히 유용한 반복문이다. 물론, 그러한 경우가 아니더라도 다양하게 사용될 수 있다.

`for`문은 다음과 같은 구조를 갖는다.

```c
for   (   expr1   ;   expr2   ;   expr3   )    statement
```

여기서 `expr1`, `expr2`, `expr3`은 표현식이다. 예제로 직접 알아보자.

```c
for (i = 10; i > 0; i--)
    printf("T 빼기 %d, 세는 중\n", i);
```

예제의 `for`문이 실행이 되면 변수 `i`는 10으로 초기화가 되고, `i`가 0보다 큰지 판별한다. 10은 0보다 크므로 `T 빼기 %d, 세는 중` 메세지가 출력되고, `i`는 감소된다. 그 다음 다시 `i > 0`을 판별한다. 여기서 `i`는 10부터 1까지 지속되므로 예제의 루프본문은 총 10번 실행된다.

`for`문은 `while`문과 상당히 밀접한 관계를 갖는다. 사실 몇가지 특수한 경우를 제외하고 `while`문은 `for`문으로 대체될 수 있다: **[Q & A]**

```c
expr1;
while  (  expr2  ) {
    statements
    expr3;
}
```

이런식으로 `for`문을 `while`문 형식으로 교환하다보면 `for`문이 왜 유용한지 이해할 수 있게 된다. 위의 `for`문 예제에서 `i--`을 `--i`로 작성했다고 하자:

```c
for (i = 10; i > 0; --i)
    printf("T 빼기 %d, 세는 중\n", i);
```

이러한 변화가 루프에 어떠한 영향을 가져다줄까? 위의 `for`문을 `while`문으로 치환해보면 사실 아무 것도 바뀐 것이 없다는 것을 알 수 있다.

```c
i = 10;
while (i > 0) {
    printf("T 빼기 %d, 세는 중\n", i);
    --i;
}
```

`for`문의 첫번째와 세번째 표현식은 사실 구문으로서 실행이 되기 때문에 그들의 값은 중요하지 않다. 만약 필요하다면 그저 부작용 때문에 필요할 뿐이다. 따라서 첫번째와 세번째 표현식은 할당식이나 증감식이 사용된다.

#### `for`문 관용적 표현

`for`문은 일정 횟수 또는 구간에서 변수를 증감시키는 동안 반복을 할 때 매우 유용한 반복문이다. 주로 `n`번 숫자를 세야할 때 `for`문이 사용된다.

> - `0`에서 `n-1`까지
>
> **[관용구]** `for (i = 0; i < n; i++) ...`
>
> - `1`에서 `n`까지
>
> **[관용구]** `for (i = 1; i <= n; i++) ...`
>
> - `n-1`에서 `0`까지
>
> **[관용구]** `for (i = n - 1; i >= 0; i--) ...`
>
> - `n`에서 `1`까지
>
> **[관용구]** `for (i = n; i > 0; i--) ...`

이런 식으로 관용적으로 사용하는 표현들을 외워서 사용하면 C 프로그래머들이 자주 겪는 다음과 같은 에러들을 방지할 수 있다.

- `>` 대신 `<`를 사용하거나, 그 반대의 경우. 위의 관용구를 보면 알겠지만, 변수가 증가하는 경우에 `<` 혹은 `<=` 연산자를 사용하고, 변수가 감소하는 경우엔 반대로 `>` 혹은 `>=` 연산자를 사용한다.
- 제어식에서 `<`,`<=`,`>`,`>=` 연산자 대신 `==` 연산자를 사용하는 경우. 제어식은 루프가 실행되기 이전 참이어야하고, 이후에 루프가 종료될 수 있도록 거짓이어야한다. `i == n`와 같은 판별식은 전자의 경우에 참이 될 수 없기 때문에 무의미한 표현식이다.
- 제어식을 `i < n` 대신 `i <= n`으로 작성할 때 발생하는 "하나 부족한" 에러(Off-by-one Error. OBOE)의 경우.

#### `for`문에서 표현식 생략하기

사실 우리는 `for`문을 지금까지 활용했던 것보다 좀 더 자유롭게 사용할 수 있다. 사실 몇몇 `for`문의 경우 굳이 모든 세 개의 표현식이 필요하지 않은 경우가 있기 때문에 C언어는 `for`문의 표현식을 생략할 수 있게 해준다. 만약 **첫번째** 표현식이 생략된다면 루프가 실행되기 이전 아무런 초기화도 일어나지 않는다.

```c
i = 10;
for (; i > 0; i--)
    printf("T 빼기 %d, 세는 중\n", i);
```

위 예제를 잘 살펴보면 알듯이 `for`문 이전에 이미 `i`가 따로 할당자에 의해 초기화가 되었으니 `for`문의 첫번째 표현식을 생략해주었다. (여기서 첫번째 표현식과 두번째 표현식 사이의 쌍반점 `;`은 생략되지 않았다. 우리가 표현식 몇 개를 생략한다 하더라도 쌍반점은 생략해선 안된다.) 만약 `for`문에서 **세번째** 표현식을 생략한다면 우리는 루프 본문을 통해 두번째 표현식이 언젠가는 거짓이 되게 만들어주어야한다. 위의 예제는 다음과 같이 작성할 수 있다.

```c
for (i = 10; i > 0;)
    printf("T 빼기 %d, 세는 중\n", i--);
```

세번째 표현식을 생략했기 때문에 그 역할을 루프본문 내에서 `i--`를 통해 `i`를 감소시켜주었다. 만약 **첫번째** 표현식과 **세번째** 표현식이 둘 다 생략된다면 이 루프는 사실상 `for`문을 뒤집어 쓴 `while`문이다. 예제를 통해 직접 확인해보자.

```c
for (; i > 0;)
    printf("T 빼기 %d, 세는 중\n", i--);
```

위 루프는 사실상 다음과 같은 루프이다.

```C
while (i > 0)
    printf("T 빼기 %d, 세는 중\n", i--);
```

보면 알겠지만 `while`문이 좀 더 의미가 명확하므로 `while`문으로 작성하는 것이 더 낫다. 만약 두번째 표현식을 생략한다면, `for`문은 이를 참값이라고 단정하기 때문에 `for`문은 종료되지 않는다. (물론 특수한 방법을 사용하지 않는 경우에 말이다). 예를 들어 몇몇 프로그래머들은 무한 루프를 만들기 위해 다음과 같이 `for`문을 이용하기도 한다. **[Q & A]**

**[관용구]** `for (;;) ...`

#### C99에서의 `for`문

**[C99]**

C99에서는 `for`문의 첫번째 표현식은 선언문으로 대체할 수 있다. 즉, 루프에서 사용할 변수를 선언하는게 가능하다는 뜻이다.

```c
for (int i = 0; i < n; i++)
    ...
```

여기서 사용된 `i`라는 변수는 `for`문 이전에 선언해줄 필요가 없다. (**만약 위의 `for`문 이전에 이미 `i`라는 이름의 변수가 선언되었다면,** **이 `for`문은 아예 루프 내에서만 사용되는 새로운 `i`를 만든다.)**

**`for`문 내에서 선언된 변수는 루프본문 밖에서 사용할 수 없다. (보통 루프 밖에서 찾을 수 없다고 한다.)**

```c
for (int i = 0; i < n; i++) {
    ...
    printf("%d", i);    /* 가능; i는 루프 내에서 찾을 수 있다 */
    ...
}
printf("%d", i);        /*** 틀림 ***/
```

`for`문 내에서 따로 사용할 변수를 선언해주는 것은 상당히 유용하다. 간편할 뿐만 아니라, 프로그램의 가독성을 높여준다. 다만, 루프가 종료된 이후에도 해당 변수를 사용해야한다면, C89 기준의 방식으로 사용해야한다.

또한, `for`문은 여러 개의 동일한 형식의 변수를 선언할 수 있다.

```c
for (int i = 0, j = 0; i < n; i++)
    ...
```

#### 쉼표연산자

가끔 프로그래밍을 할 때 `for`문 내에 두 개 (이상)의 표현식을 초기화하거나 루프가 실행될 때마다 여러 변수를 증감시켜야할 때가 있다. 이는 `for`문의 첫번째와 세번째 표현식 내에서 **쉼표연산자**를 통해 구현 가능하다.

쉼표식은 다음과 같은 구조를 갖는다.

> ```c
> expr1, expr2
> ```

여기서 `expr1`와 `expr2`은 임의의 표현식이다. 쉼표식은 두 가지 과정으로 평가된다. 우선 `expr1`이 평가가 되고 그 값은 버려진다. 그 다음 `expr2`이 평가되며 그 값이 전체 표현식의 값이 된다. `expr1`을 평가할 때엔 언제나 부작용이 발생한다. 부작용이 발생하지 않는다면 애초에 `expr1`은 의미가 없는 표현식이다.

예를 들어 값이 각각 1과 5인 변수 `i`와 `j`가 있다고 하자. 쉼표식 `++i, i + j`이 평가된다면, 우선 `i`가 증가가 되고 나서 `i + j`이 평가될 것이다. 그렇기 때문에 전체 표현식의 값은 7이다. (당연하겠지만 `i`의 값은 2로 바뀌었을 것이다) 쉼표연산자의 순서는 다른 연산자보다 낮기 때문에 `++i`와 `i + j`를 괄호를 치는 의미가 없다.

우리가 할당을 여러개 이어 쓰듯 쉼표식들을 이어 쓸 수 있다. 쉼표연산자는 좌향결합적이다. 즉,

```c
i = 1, j = 2, k = i + j
```

위의 코드는 아래와 동일하다.

```c
((i = 1), (j = 2)), (k = (i + j ))
```

쉼표식에선 좌측 피연산자가 우측 피연산자보다 먼저 평가되므로, 할당식 `i = 1`, `j = 2`, `k = i + j`은 왼쪽에서 오른쪽 순서로 진행된다.

쉼표연산자는 C 언어가 형식상 한 개의 표현식만을 요구할 때, 필요에 의해 두 개 이상의 표현식을 사용할 수 있게 해준다. 쉽게 말해 쉼표연산자는 두 개의 표현식을 "붙여서" 하나의 표현식으로 만들어준다. (뭔가 여러 구문들을 하나의 구문으로 취급하게 해주는 복합문과 비슷하게 들리지 않는가?)

사실 여러 표현식을 하나로 붙이는 상황은 그렇게 자주 생기지 않는다. 몇몇 특정 매크로 정의의 경우 쉼표연산자를 유용하게 사용하기도 한다. 이는 이후 단원에서 다룰 것이다. 사실상 쉼표연산자는 `for`문에서만 등장한다고 생각하는 것이 편하다. 예를 들어 `for`문을 사용할 때 두 개의 변수를 초기화하고 싶을 때, 우리는 보통 다음과 같이 코드를 작성했다.

```c
sum = 0;
for (i = 1; i <= N; i++)
    sum += i;
```

이제는 위와 같이 작성하지 않고 아래와 같이 작성할 수 있다.

```c
for (sum = 0, i = 1; i <= N; i++)
    sum += i;
```

표현식 `sum = 0, i = 1`은 우선 `sum`에 0을 할당하고 `i`에 1을 할당한다. 이런식으로 쉼표를 이용해 `for`문에서 두 개 이상의 변수를 초기화시켜줄 수 있다.

#### [프로그래밍] 제곱표 출력하기 (수정)

6.1 단원의 `square.c` 프로그램은 우리가 배운 `for`문을 사용하여 코드를 개선할 수 있다.

**square2.c**

```c
/* Prints a table of squares using a for statement */

#include <stdio.h>

int main(void)
{
    int i, n;

    printf("This program prints a table of squares.\n");
    printf("Enter number of entries in table: ");
    scanf("%d", &n);

    for (i = 1; i <= n; i++) {
        printf("%10d%10d\n", i, i * i);
    }

    return 0;
}
```

위의 코드에서 우리는 `for`문의 중요한 점을 하나 발견할 수 있다: C 언어는 `for`문의 행동을 제어하는 세 개의 표현식에 그 어떤 제한도 두지 않는다는 점이다. 물론 주로 우리는 `for`문을 사용할 땐 같은 변수를 초기화하고, 평가하고, 값을 최신화해주었다. 하지만 반드시 이러한 형식을 따라야하는 것은 아니다. 아래 코드로 직접 확인해보자.

```c
/* Prints a table of squares using an odd method */

#include <stdio.h>

int main(void)
{
    int i, n, odd, square;

    printf("This program prints a table of squares.\n");
    printf("Enter number of entries in table: ");
    scanf("%d", &n);

    i = 1;
    odd = 3;
    for (square = 1; i <= n; odd += 2) {
        printf("%10d%10d\n", i, square);
        ++i;
        square += odd;
    }

    return 0;
}
```

위 코드의 `for`문에선 `square`라는 변수를 초기화해주고, `i`를 평가하며 `odd`의 값을 증가시켜주었다. `i`는 제곱할 숫자이고, `odd`는 현재 제곱수에 더하여 다음 제곱수를 구할 때 쓰이는 변수다. (이를 통해 곱하기 연산을 사용하지 않고 제곱수를 구할 수 있다)

`for`문의 뛰어난 융통성과 다재다능함은 상당히 유용하다. 특히 연결목록linked list를 사용할 때 상당히 유용하다. 다만, 너무 오용할 수 있는 가능성이 있기에 주의해서 사용해야한다. 사실 `square3.c`보다는 `square2.c`처럼 `i` 하나로 명확하게 `for`문을 제어하는 것이 더 낫다.

### 6.4 루프에서 벗어나기

우리는 `while`문과 `for`문을 통해 루프본문 이전에 반복이 종료되는 유형의 반복문을 다루었고, `do`문과 같이 루프본문 이후에 반복이 종료되는 유형의 반복문 또한 다루었다. 헌데, 프로그래밍을 하다보면 루프를 중간에 종료시켜야하는 때, 혹은 아예 종료되는 지점이 여러개인 반복문을 작성해야할 때가 발생한다. 우리는 `break`문을 통해 이 두 가지 상황을 모두 만족시킬 수 있다.

우선 `break`문을 다룬 이후에 `continue`문이나 `goto`문과 같이 비슷한 구문을 다룰 것이다. `continue`문은 반복문을 종료하지 않으면서 반복문의 특정 영역을 건너뛸 수 있게 만들어주는 구문이다. `goto`문은 한 구문에서 다른 구문으로 아예 넘어가게 만들어주는 구문이다. 물론 `break`문과 `continue`문만으로도 많은 것이 가능하기에 `goto`문은 잘 사용되지 않는 구문이다.

#### `break`문

우리는 사실 `switch`문을 배울 때 `break`문이 `switch`문의 작동 방식을 어떻게 유용하게 만드는지를 같이 배웠다. `break`문은 같은 방식으로 `while`문, `for`문, `do`문과 같은 반복문에도 사용된다.

우리가 자연수 `n`이 소수인지를 판별하는 프로그램을 작성한다고 가정해보자. 우선은 `for`문을 통해 `n`을 `2`에서 `n - 1` 사이의 숫자들로 나누는 코드를 작성한다고 전략을 세워보자. 여기서 나눗수가 만약 발견된다면 바로 반복문을 중단해야한다. 나뉜다는 것이 확인되었으므로 이후의 숫자들의 경우를 확인할 필요가 없기 때문이다. 루프가 종료된 이후 우리는 `if`문을 통해 루프가 도중에 종료되었는지(`n`이 합성수) 아닌지(`n`이 소수)를 판별할 수 있다.

```c
for (d = 2; d < n; d++)
    if (n % d == 0)
        break;

if (d < n)
    printf("%d은/는 %d로 나뉘어진다\n", n, d);
else
    printf("%d은/는 소수이다.\n", n);
```

`break`문은 종료점이 루프의 시작이나 끝이 아닌 도중에 있을 때 상당히 유용하다. 사용자의 입력을 받을 때 특정 입력이 들어올 경우 루프를 중단하는 코드의 경우도 마찬가지다.

```c
for (;;) {
    printf("Enter a number (enter 0 to stop): ");
    scanf("%d", &n);
    if (n == 0)
        break;
    printf("%d cubed is %d\n", n, n * n * n);
}
```

`break`문은 **가장 안쪽**의 `while`문, `for`문, `do`문, `switch`문에서 제어를 밖으로 옮긴다. 그렇기 때문에 위와 같은 구문들이 여러 겹으로 작성되어있다면 `break`문은 오로지 한 구문만에서 벗어나게 해준다. `while`문 내에 있는 `switch`문의 경우를 살펴보자.

```c
while    (...)    {
    switch    (...)    {
        ...
        break;
        ...
    }
}
```

`break`문은 `switch`문에서 제어를 밖으로 빼내지만, `while`문에서 빼내지는 않는다. 이후에 다시 이 부분을 구체적으로 다루겠다.

#### `continue`문

엄밀히 따지면 `continue`문은 루프에서 벗어나는 구문은 아니기 때문에 이 소단원의 주제에 맞지는 않다. `continue`는 마치 `break`와 비슷하다. 그렇기 때문에 이 소단원에 포함시킨 것은 아예 말이 안되는 것은 아니다. `break`가 프로그램의 제어를 루프 **이후**로 전달한다면, `continue`는 제어를 루프 끝나기 바로 **이전**에 전달한다. `break`가 루프에서 벗어나게 해준다면, `continue`는 루프 안에 그대로 남아있게 해준다. `break`와 `continue` 사이엔 또다른 차이점이 존재한다. `break`는 `switch`문과 루프문(`while`, `do`, `for`)에 사용될 수 있지만 `continue`는 루프에만 사용할 수 있다.

숫자 여러 개를 연속적으로 받아 그들의 합을 계산하는 예제를 통해 `continue`가 어떻게 사용되는지 확인해보도록 하자. 루프는 10개의 0이 아닌 수가 입력되면 종료시킨다. 0이 입력이 되면 `continue`가 실행이 되어 남은 루프본문(`sum += i;`, `n++`과 같은 구문들)을 생략하지만, 루프가 종료되지는 않는다.

```c
n = 0;
sum = 0;
while (n < 10) {
    scanf("%d", &i);
    if (i == 0)
        continue;
    sum += i;
    n++;
    /* continue jumps to here */
}
```

위 예제를 `continue` 없이 작성해보면 아래와 같다.

```c
n = 0;
sum = 0;
while (n < 10) {
    scanf("%d", &i);
    if (i != 0) {
        sum += i;
        n++;
    }
}
```

#### `goto`문

`break`문과 `continue`문은 프로그램의 제어를 다른 줄로 옮기는 도약문이다. 둘의 범위 또한 정해져있다. `break`는 둘러 쌓인 루프의 **밖**으로 도약하고, `continue`는 루프의 끝 바로 **이전**으로 도약한다. `goto`문은 이 둘과는 다르게 해당 구문에 **표식label**이 있는 한 함수 내의 그 어느 구문으로든 도약할 수 있다. (**[C99]** C99의 경우 `goto`문에 약간의 범위를 부여한다. 변수 크기를 갖는 배열의 선언을 우회할 때 사용할 수 없다.)

표식이란 구문의 시작에 표기한 식별자이다.

```c
identifier : statement
```

구문은 두 개 이상의 식별자를 가질 수 있다. `goto`문 자체는 다음과 같은 구조를 갖는다.

```c
goto identifier ;
```

구문 `goto L;`을 실행한다면 프로그램의 제어를 표식 `L`이 있는 구문으로 옮긴다. 여기서 표식 `L`은 반드시 `goto`문이 있는 함수 내에 있어야한다.

루프를 도중에 강제로 종료할 때 `break`문이 아니라 `goto`문을 이용할 수도 있다.

```c
for (d = 2; d < n; d++)
    if (n % d == 0)
        goto done

done:
if (d < n)
    printf("%d is divisible by %d\n", n, d);
else
    printf("%d is a prime\n", n);
```

`goto`문은 옛날 프로그래밍 언어들의 잔재이기 때문에 사실 C 프로그램에서 자주 사용되지 않는다. **[Q & A]** `goto`문의 일종이라 할 수 있는 `break`, `continue`, `return`과 `exit` 함수들이 사실상 대부분의 경우 `goto`를 대체할 수 있기 때문이다.

물론, `goto`문이 가끔 유용하게 사용될 때도 있다. 루프 내에 `switch`문이 있는 상황이라면, **`switch`문 내부에선 전체 반복문에서 벗어날 수가 없다(원래 break문은 스위치문을 벗어나기 위해 사용됨)**. `break`문을 사용하면 `switch`문에서 벗어나지, 반복문에서 벗어나지 않는다. 이는 `goto`문을 통해 손쉽게 해결해줄 수 있다.

```c
while   (...)
    switch   (...)   {
        ...
        goto loop_done;    /* 이 상황에선 break가 먹히지 않는다 */
        ...
    }
}
loop_done:   ...
```

반복문이 여러겹일 때도 `goto`문은 유용하게 사용된다.

#### [프로그래밍] 은행계좌 프로그램

대부분의 간단한 상호작용할 수 있는 프로그램들은 메뉴에 기반해서 상호작용한다. 사용자에게 여러 명령어를 쭉 나열해서 보여주고, 거기서 선택하게 하는 것이다. 사용자가 거기에서 명령을 선택하면 프로그램은 해당 명령에 따라 행동을 한다. 행동이 종료되면 다시 명령어 목록을 띄운다. 이 과정은 사용자가 명령어 중에 종료 명령어를 선택해야 종료된다.

이러한 프로그램의 핵심은 당연히 루프이다. 루프는 명령어를 묻는 구문, 명령어를 읽는 구문, 명령을 실행하는 구문으로 나뉠 것이다.

```c
for   (;;)   {
   명령어를 묻는다;
   명령어를 읽는다;
   명령을 실행한다;
}
```

명령을 실행하는 부분에선 `switch`문(혹은 계단식 `if`문)을 사용하는 것이 좋아보인다.

```c
for   (;;)   {
   명령어를 묻는다;
   명령어를 읽는다;
   switch   (명령어)   {
       case   명령어1:    명령1 실행;    break;
       case   명령어2:    명령2 실행;    break;
       ...
       case   명령어n:    명령n 실행;    break;
       default:   에러 메시지 출력;    break;
   }
}
```

위의 코드를 실생활에 사용해보도록 하자. 한 번 은행계좌 관리 프로그램을 작성해보도록 하자. 프로그램은 사용자에게 여러 명령어를 나열하고 그 중 하나를 선택하라고 할 것이다. 계좌의 금액을 초기화하거나, 입금하거나, 출금하거나, 현재 금액을 출력하거나, 프로그램을 종료하는 선택지들이 있을 것이다. 여기서 선택은 정수 0, 1, 2, 3, 4로 정해주도록 하자. 본 프로그램을 작성해보자.

> ** `ACME checkbook-balancing program` **
> `Commands: 0=clear, 1=credit, 2=debit, 3=balance, 4=exit
> Enter command: 1`
> `Enter amount of credit: 1042.56`
> `Enter command: 2`
> `Enter amount of debit: 133.79`
> `Enter command: 1`
> `Enter amount of credit: 1754.32`
> `Enter command: 2`
> `Enter amount of debit: 1400`
> `Enter command: 2`
> `Enter amount of debit: 68`
> `Enter command: 2`
> `Enter amount of debit: 50`
> `Enter command: 3`
> `Current balance: $1145.09`
> `Enter command: 4`

사용자가 4번 명령을 입력하면 `switch`문 뿐만 아니라 전체 루프에서 벗어나야 한다. 당연히 `break`문은 여기서 무용지물이다. 게다가 `goto`문은 사용하기 좀 꺼려지는 구문이다. 대신, 아예 `return`문을 사용해주어 프로그램을 종료시키도록 하자. 여기서 `return`문은 `main` 함수가 운영체제게 값을 반환하게 만들어준다.

```c
/* Balances a checkbook */

#include <stdio.h>

int main(void)
{
    int cmd;
    float balance = 0.0f, credit, debit;

    printf("*** ACME checkbook-balancing program ***\n");
    printf("Commands: 0=clear, 1=credit, 2=debit, 3=balance, 4=exit\n\n");

    for (;;) {
        printf("Enter command: ");
        scanf("%d", &cmd);

        switch (cmd) {
        case 0:
            balance = 0.0f; break;
        case 1:
            printf("Enter amount of credit: ");
            scanf("%f", &credit);
            balance += credit; break;
        case 2:
            printf("Enter amount of debit: ");
            scanf("%f", &debit);
            balance -= debit; break;
        case 3:
            printf("Current balance: $%.2f\n", balance); break;
        case 4: return 0;
        default: printf("Commands: 0=clear, 1=credit, 2=debit, 3=balance, 4=exit\n\n"); break;
        }
    }
}
```

`switch`문에서 `return`문이 사용될 때 굳이 `break`문을 같이 안써주었다. 애초에 `return`문 뒤에 있는 구문들은 실행될 수가 없기 때문이다. 몇몇 컴파일러는 `return`문 뒤에 구문이 있으면 경고 메시지를 출력하기도 한다.

### 6.5 null문

구문은 **무형null**의 형태를 띨 수 있다. 이는 즉 세미콜론을 제외하고 아무 기호도 없는 구문을 의미한다. 직접 예시로 들어보겠다.

```c
i = 0; ; j = 1
```

이 줄에는 세 개의 구문이 있다. `i` 할당문, null 구문, `j` 할당문.

null 문은 사실 단 한 가지 용도로 거의 쓰인다. 바로 본문이 비어있는 루프다. 6.4 단원에 있었던 소수 찾기 루프를 예시로 들어보겠다. **[Q & A]**

```c
for (d=2; d<n; d++)
    if(n%d == 0 )
        break;
```

만약, `n%d==0`조건을 loop 제어식 안으로 옮기면, 반복문의 body는 비게 될 것이다.

```c
for(d=2; d<n && n%d !=0; d++)
/* 반복문의 body가 비었음*/  ;
```

반복문은 배번, `d<n`조건을 먼저 테스트하고, 만약 거짓이라면 반복문을 종료한다. 반대로, 참일 경우에는 `n %d != 0`을 테스트하고, 만약 거짓이라면 반복문을 종료한다. (후자(`n %d != 0`가 거짓인)의 경우 `n%d==0`는 참이기 때문에, n의 divisor를 구할 수 있다.)

> [!!!] 의도치 않게, if,while, for 문의 괄호 뒤에 `;`을 입력하게 되면 null문을 생성하게 된다.
>
> - `if`문의 괄호 뒤에 `;`을 붙이면, 제어식에 상관없이 항상 같은 결과를 보인다.
>
>   ```c
>   if(d==0) ;           /*WRONG*/
>   	printf("Error:Division by zero\n");
>   ```
>
> - `while`문의 괄호 뒤에 `;`를 붙이면, 무한루프를 생성하게 될수 있다.
>
>   ```c
>   i=10;
>   while(i>0);              /*WRONG*/
>   {
>   	printf("T minus %d and countin\n", i);
>   	--i;
>   }
>   ```
>
>   또는, 루프를 종료시킨다. 루프가 스스로 종료 되고, loop body는 루프가 종료된 후 딱 한번만 실행된다.
>
>   ```c
>   i=11;
>   while(--i>0);                  /*WRONG*/
>   	printf("T minus %d and counting\n", i);
>   ```
>
>   > 출력은 T minus 0 and counting
>
> - `for`문에서도 마찬가지로, `for`문 뒤에 `;`을 붙이면 loop body는 한번만 출력된다.
>
>   ```c
>   for(i=10; i>0 ; i--);              /*WRONG*/
>   	printf("T minus %d and counting\n", i);
>   ```
>
>   > 출력은 T minus 0 and counting



#### 