# C를 학습하면서 배운 것들

### 01. Intriducing C



### 02.C Fudamentals



### 03.Formatted Input-Output



### 04.Expressions



### 05. Selection Statements

#### 5.1 논리 표현식

- **대소 비교는 좌항결합적이다.**

  C언에서 `i < j < k`와 같은 표현식은 구문상 문제될 것은 없다. 다만 실제로 평가했을 때 우리가 의도했던 의미와는 다른 결과가 나온다. **`<` 연산자가 좌향결합적**이기 때문에 위의 표현식은 다음과 같다.

  ```
  (i < j) < k
  ```

  즉, 이 표현식은 우선 `i`가 `j`보다 작은지 평가한다. 그렇게 되면 이 표현식은 `k`가 0 또는 1보다 큰지를 평가하는 식이 된다. 그렇기 때문에 `j`가 `i`보다 크고 `k`보다는 작다는 것을 위와 같이 표현해줄 수 없다. (추후에 배울 개념을 사용한다면, 올바른 식은 `i < j && j < k`이다.)

- **몇몇 똑똑한 프로그래머들은 관계연산자와 동등연산자가 정수값을 반환한다는 점에서 착안해서 다양한 표현식을 만들어낸다.**

   `(i >= j) + (i == j)`은 `i`가 `j`보다 작거나, 크거나, 같느냐에 따라 순서대로 0, 1이거나 2를 값으로 갖는다. 이런 복잡한 코드는 일반적으로 좋은 생각은 아닐 뿐더러 프로그램의 가독성을 떨어뜨린다.

  또는 ,표현식 i < j == j < k 은 다음과 같다.

  ```
  (i < j) == (j < k)
  ```

  `i < j`와 `j < k` 둘이 동시에 참이거나 거짓이라면 위의 표현식은 참이다.

- **&& 나 ||연산자는 왼쪽 피연산자를 우선 평가 하고 더이상 평가할 의미가 없으면 오른쪽 피연산자를 연산하지 않는다.**

  ```c++
  (i != 0) && (j / i > 0)
  ```

  이 표현식의 값을 알려면 우선 왼쪽 피연산자인 `(i != 0)`을 평가해야한다. `i`가 0과 같지 않다면 `(j / i > 0)`을 평가해서 전체 표현식이 참인지 거짓인지 판별해야한다. 하지만 만약 `i`가 0이라면 전체 표현식은 거짓이므로 오른쪽 피연산자인 `(j / i > 0)`을 평가할 필요가 없다. 단락식 평가는 여러모로 유용하다. 만약 단락식 평가가 아니었다면 위의 표현식에서 오른쪽 피연산자에서는 값을 0으로 나누는 에러가 발생했을 것이다.

  논리표현식을 잘못 사용하면 부작용이 발생할 수도 있다. 다행히도 `&&`과 `||`은 단락성을 가지므로 피연산자에서 발생하는 부작용을 피할 수 있다. 다음 표현식을 예로 들겠다.

  ```
  i > 0 && ++j > 0
  ```

  표현식을 평가할 때의 부작용으로 `j`는 증가되겠지만, 여기선 부작용이 발생하지 않는다. 만약 `i > 0`이 거짓이라면 `++j > 0`은 평가되지 않기에 **`j`는 증가되지 않는다.** 만약 무조건 증가시키고 싶다면 피연산자의 순서를 바꾸어 `++j > 0 && i > 0`로 표현식을 변경하면 된다. 물론, 아예 `j`를 따로 증가시키는게 더 좋은 방법이다.

#### 5.2 if문

- **조건 표현식 ( 비교 ? 참 :  거짓)**

  **조건표현식**은 프로그램을 간결하게 해주지만 가독성을 떨어뜨릴 수 있다. 그렇기 때문에 사용하지 않는 것이 좋지만, 특정 경우에선 사용하는 것이 간편할 수 있다. 대표적인 예시가 `return`문이다.

  ```c
  if (i > j)
      return i;
  else
      return j;
  ```

  대부분의 프로그래머들은 위보다는 아래처럼 코드를 작성한다.

  ```c
  return i > j ? i : j;
  ```

  `printf` 함수 또한 조건표현식을 사용함으로써 상당히 간편하게 코드를 짤 수 있다.

  ```c
  if (i > j)
      printf("%d\n", i);
  else
      printf("%d\n", j);
  ```

  위와 같이 작성하기 보다는 다음과 같이 간단하게 작성할 수 있다.

  ```c
  printf("%d\n", i > j ? i : j);
  ```

  조건표현식은 특정 매크로정의에서도 자주 사용된다.

#### 5.3 Switch문

- **`case` 다음엔 반드시 한 개의 상수식만 올 수 있지만 여러 개의 조건부호들이 다음 예시처럼 같은 구문을 공유할 수 있다.**

  

  ```c
  switch (grade) {
      case 4:
      case 3:
      case 2:
      case 1:  printf("좋지 않아요!");
               break;
      case 0:  printf("좀 더 노력하세요!");
               break;
      default: printf("잘못된 학점입니다");
               break;
  }
  ```

  좀 더 공간을 아끼려고 중복되는 조건부호들을 한 줄에 놓기도 한다.

  ```c
  switch (grade) {
      case 4: case 3: case 2: case 1:
               printf("좋지 않아요!");
               break;
      case 0:  printf("좀 더 노력하세요!");
               break;
      default: printf("잘못된 학점입니다");
               break;
  }
  ```

  아쉽게도 다른 프로그래밍 언어처럼 일정 범위를 조건부호로 나타낼 수는 없다.

#### Q&A

- **제 컴파일러는 `==` 대신 `=`를 써도 경고 메세지를 출력하지 않던데, 컴파일러가 이런 점을 강제로 경고로 알려주게 만들 수 있나요? [if문]**

  몇몇 프로그래머들이 사용하는 방법이 있죠.

  ```c
  if (i == 0) ...
  ```

  이렇게 작성 안하고

  ```c
  if (0 == i) ...
  ```

  이렇게 습관적으로 작성해요. 그 다음에 `==` 연산자를 실수로 `=`로 작성했다고 해봅시다.

  ```c
  if (0 = i) ...
  ```

  이러면 0에 값을 할당할 수 없기에 컴파일러가 에러 메세지를 낼거에요. 사실 전 이 방법을 사용하진 않아요. 프로그램이 상당히 비정상적으로 보이거든요. 그리고 조건의 한 피연산자가 왼쪽값이 아닐 때 밖에 쓸 수 있어요.

  다행히도 대부분의 컴파일러는 `=` 연산자를 `if`문에서 잘못 사용한 경우를 잡아줘요. 예를 들어 GCC 컴파일러는 `-Wparentheses` 기능 혹은 `-Wall`(모든 경고 메세지 표시) 기능으로 위 경우를 잡아줄 수 있어요. GCC를 사용할 때 만약 의도적으로 `=` 연산자를 써준 경우 괄호를 두 번 해주면 경고 메세지가 뜨지 않게 해줄 수 있어요.

  ```c
  if ((i = j)) ...
  ```



### 06. Loops

#### 6.3for문

- **쉼표연산자**

  가끔 프로그래밍을 할 때 `for`문 내에 두 개 (이상)의 표현식을 초기화하거나 루프가 실행될 때마다 여러 변수를 증감시켜야할 때가 있다. 이는 `for`문의 첫번째와 세번째 표현식 내에서 **쉼표연산자**를 통해 구현 가능하다.

  쉼표식은 다음과 같은 구조를 갖는다.

  > ```
  > expr1, expr2
  > ```

  여기서 `expr1`와 `expr2`은 임의의 표현식이다. 쉼표식은 두 가지 과정으로 평가된다. 우선 `expr1`이 평가가 되고 그 값은 버려진다. 그 다음 `expr2`이 평가되며 그 값이 전체 표현식의 값이 된다. `expr1`을 평가할 때엔 언제나 부작용이 발생한다. 부작용이 발생하지 않는다면 애초에 `expr1`은 의미가 없는 표현식이다.

  예를 들어 값이 각각 1과 5인 변수 `i`와 `j`가 있다고 하자. 쉼표식 `++i, i + j`이 평가된다면, 우선 `i`가 증가가 되고 나서 `i + j`이 평가될 것이다. 그렇기 때문에 전체 표현식의 값은 7이다. (당연하겠지만 `i`의 값은 2로 바뀌었을 것이다) 쉼표연산자의 순서는 다른 연산자보다 낮기 때문에 `++i`와 `i + j`를 괄호를 치는 의미가 없다.

  우리가 할당을 여러개 이어 쓰듯 쉼표식들을 이어 쓸 수 있다. 쉼표연산자는 좌향결합적이다. 즉,

  ```
  i = 1, j = 2, k = i + j
  ```

  위의 코드는 아래와 동일하다.

  ```
  ((i = 1), (j = 2)), (k = (i + j ))
  ```

  쉼표식에선 좌측 피연산자가 우측 피연산자보다 먼저 평가되므로, 할당식 `i = 1`, `j = 2`, `k = i + j`은 왼쪽에서 오른쪽 순서로 진행된다.

  쉼표연산자는 C 언어가 형식상 한 개의 표현식만을 요구할 때, 필요에 의해 두 개 이상의 표현식을 사용할 수 있게 해준다. 쉽게 말해 쉼표연산자는 두 개의 표현식을 "붙여서" 하나의 표현식으로 만들어준다. (뭔가 여러 구문들을 하나의 구문으로 취급하게 해주는 복합문과 비슷하게 들리지 않는가?)

  사실 여러 표현식을 하나로 붙이는 상황은 그렇게 자주 생기지 않는다. 몇몇 특정 매크로 정의의 경우 쉼표연산자를 유용하게 사용하기도 한다. 이는 이후 단원에서 다룰 것이다. 사실상 쉼표연산자는 `for`문에서만 등장한다고 생각하는 것이 편하다. 예를 들어 `for`문을 사용할 때 두 개의 변수를 초기화하고 싶을 때, 우리는 보통 다음과 같이 코드를 작성했다.

  ```
  sum = 0;
  for (i = 1; i <= N; i++)
      sum += i;
  ```

  이제는 위와 같이 작성하지 않고 아래와 같이 작성할 수 있다.

  ```
  for (sum = 0, i = 1; i <= N; i++)
      sum += i;
  ```

  표현식 `sum = 0, i = 1`은 우선 `sum`에 0을 할당하고 `i`에 1을 할당한다. 이런식으로 쉼표를 이용해 `for`문에서 두 개 이상의 변수를 초기화시켜줄 수 있다.

#### 6.4루프에서 벗어나기

- **goto문**

  `break`문과 `continue`문은 프로그램의 제어를 다른 줄로 옮기는 도약문이다. 둘의 범위 또한 정해져있다. `break`는 둘러 쌓인 루프의 **밖**으로 도약하고, `continue`는 루프의 끝 바로 **이전**으로 도약한다. `goto`문은 이 둘과는 다르게 해당 구문에 **표식label**이 있는 한 함수 내의 그 어느 구문으로든 도약할 수 있다. (**[C99]** C99의 경우 `goto`문에 약간의 범위를 부여한다. 변수 크기를 갖는 배열의 선언을 우회할 때 사용할 수 없다.)

  표식이란 구문의 시작에 표기한 식별자이다.

  ```c
  identifier : statement
  ```

  구문은 두 개 이상의 식별자를 가질 수 있다. `goto`문 자체는 다음과 같은 구조를 갖는다.

  ```c
  goto identifier ;
  ```

  구문 `goto L;`을 실행한다면 프로그램의 제어를 표식 `L`이 있는 구문으로 옮긴다. 여기서 표식 `L`은 반드시 `goto`문이 있는 함수 내에 있어야한다.

  루프를 도중에 강제로 종료할 때 `break`문이 아니라 `goto`문을 이용할 수도 있다.

  ```c
  for (d = 2; d < n; d++)
      if (n % d == 0)
          goto done
  
  done:
  if (d < n)
      printf("%d is divisible by %d\n", n, d);
  else
      printf("%d is a prime\n", n);
  ```

  `goto`문은 옛날 프로그래밍 언어들의 잔재이기 때문에 사실 C 프로그램에서 자주 사용되지 않는다. **[Q & A]** `goto`문의 일종이라 할 수 있는 `break`, `continue`, `return`과 `exit` 함수들이 사실상 대부분의 경우 `goto`를 대체할 수 있기 때문이다.

  물론, `goto`문이 가끔 유용하게 사용될 때도 있다. 루프 내에 `switch`문이 있는 상황이라면, `switch`문 내부에선 전체 반복문에서 벗어날 수가 없다. `break`문을 사용하면 `switch`문에서 벗어나지, 반복문에서 벗어나지 않는다. 이는 `goto`문을 통해 손쉽게 해결해줄 수 있다.

  ```c
  while   (...)
      switch   (...)   {
          ...
          goto loop_done;    /* 이 상황에선 break가 먹히지 않는다 */
          ...
      }
  }
  loop_done:   ...
  ```

  반복문이 여러겹일 때도 `goto`문은 유용하게 사용된다.

  

#### 6.5 null문

- null문

  구문은 **무형null**의 형태를 띨 수 있다. 이는 즉 세미콜론을 제외하고 아무 기호도 없는 구문을 의미한다. 직접 예시로 들어보겠다.

  `i = 0; ; j = 1`

  이 줄에는 세 개의 구문이 있다. `i` 할당문, null 구문, `j` 할당문.

#### Q&A

- **무한 루프 :  while(1)과 for( ; ; )**

  오래된 컴파일러에서는 for( ; ; ) 이 while(1) 보다 더 효율적이다. while(1)은 계속 1을 체크하기 때문에 효율이 떨어진다. 하지만, 최근 컴파일러에서는 차이가 없다. 

- `goto`는 스파게티 코드를 만들 수 있다. 이는 이해하기 어렵고, 수정하기 어렵다.



### 07. Basic Types

#### 7.1 정수형 타입

- **signed and unsinged**

  부호가 있는 (signed) 정수형에서는 가장 왼쪽에 있는 bit가 부호 비트이다. 부호비트가 0이라면 양수, 1이라면 음수를 나타낸다. 

  예를들면, 32bit의 부호가 있는 정수형에서 나타낼 수 있는 최대 값은 `0111` (2³¹-1)일 것이다. 반대로 부호가 없는(모두 양수인) 정수형에서 나타낼 수 있는 최대값은 `1111`(2³²-1) 이다.

- C의 정수형 종류

  | 구분                                                         | Signed  `():생략가능`    | Unsinged  `():생략가능`  |
  | ------------------------------------------------------------ | ------------------------ | ------------------------ |
  | int : 32bit<br />(16bit cpu에서는 16bit)                     | (signed) int             | unsinged int             |
  | short : 16bit<br />(16bit cpu에서는 int와 동일)              | (signed) short (int)     | unsinged short (int)     |
  | long : 32bit<br />(32bit cpu에서는 int와 동일)<br />(맥,리눅스 64bit에서는 64bit) | (signed) long (int)      | unsigned long (int)      |
  | long long : 64bit                                            | (signed) long long (int) | unsigned long long (int) |

  ![img](https://dojang.io/pluginfile.php/73/mod_page/content/50/unit7-1.png)

  C 언어의 정수 자료형은 운영체제, CPU(플랫폼)에 따라 같은 short, int, long이라 하더라도 크기가 달라집니다. 다음은 각 데이터 모델별 정수 자료형의 크기(비트)입니다. S는 short, I는 int, L은 long, LL은 long long, P는 포인터를 뜻합니다.

- **데이터 모델** 

  | 데이터 모델   | short | int  | long | long long | 포인터 | CPU 및 운영체제                                             |
  | ------------- | ----- | ---- | ---- | --------- | ------ | ----------------------------------------------------------- |
  | IP16L32(near) | 16    | 16   | 32   |           | 16     | x86(16비트): MS-DOS                                         |
  | I16LP32(far)  | 16    | 16   | 32   |           | 32     | x86(16비트): MS-DOS                                         |
  | ILP32         | 16    | 32   | 32   | 64        | 32     | x86(32비트): 유닉스 및 리눅스, 솔라리스, BSD, OS X, Windows |
  | LLP64/IL32P64 | 16    | 32   | 32   | 64        | 64     | x86-64(64비트): Windows                                     |
  | LP64/I32LP64  | 16    | 32   | 64   | 64        | 64     | x86-64(64비트): 유닉스 및 리눅스, 솔라리스, BSD, OS X       |
  | ILP64         | 16    | 64   | 64   | 64        | 64     |                                                             |
  | SILP64        | 64    | 64   | 64   | 64        | 64     |                                                             |

   

  32비트 Windows, 리눅스, OS X에서 사용하는 ILP32는 int, long, pointer의 크기가 32비트라는 뜻입니다.

  64비트 Windows에서 사용하는 LLP64/IL32P64에서 LLP64는 long long과 pointer의 크기가 64비트라는 뜻이고, IL32P64는 int와 long의 크기가 32비트, pointer의 크기가 64비트라는 뜻입니다.

  64비트 리눅스, OS X에서 사용하는 LP64/I32LP64에서 LP64는 long과 pointer의 크기가 64비트라는 뜻이고, I32LP64는 int의 크기가 32비트, long과 pointer의 크기가 64비트라는 뜻입니다.

  

- **<`limits.h`> 헤더는 타입별 최대값과 최소값을 정의하고 있다.**

  | 자료형             | 최솟값    | 최댓값     |
  | ------------------ | --------- | ---------- |
  | char               | CHAR_MIN  | CHAR_MAX   |
  | short              | SHRT_MIN  | SHRT_MAX   |
  | int                | INT_MIN   | INT_MAX    |
  | long               | LONG_MIN  | LONG_MAX   |
  | long long          | LLONG_MIN | LLONG_MAX  |
  | unsigned char      | 0         | UCHAR_MAX  |
  | unsigned short     | 0         | USHRT_MAX  |
  | unsigned int       | 0         | UINT_MAX   |
  | unsigned long      | 0         | ULONG_MAX  |
  | unsigned long long | 0         | ULLONG_MAX |

  ```c
  #include <stdio.h>
  #include <limits.h>    // 자료형의 최댓값과 최솟값이 정의된 헤더 파일
  
  int main()
  {
      char num1 = CHAR_MIN;          // char의 최솟값
      short num2 = SHRT_MIN;         // short의 최솟값
      int num3 = INT_MIN;            // int의 최솟값
      long num4 = LONG_MIN;          // long의 최솟값
      long long num5 = LLONG_MIN;    // long long의 최솟값
  
      // char, short, int는 %d로 출력하고 long은 %ld로 출력, long long은 %lld로 출력
      printf("%d %d %d %ld %lld\n", num1, num2, num3, num4, num5);
      // -128 -32768 -2147483648 -2147483648 -9223372036854775808
  
      return 0;
  }
  ```

  > -128 -32768 -2147483648 -2147483648 -9223372036854775808

  다음과 같이 limits.h에 정의된 최댓값을 넘어서도 오버플로우가 발생합니다.

  integer_max_overflow.c

  ```c
  #include <stdio.h>
  #include <limits.h>    // 자료형의 최댓값과 최솟값이 정의된 헤더 파일
  
  int main()
  {
      char num1 = CHAR_MAX + 1;          // char의 최댓값보다 큰 수를 할당. 오버플로우 발생
      short num2 = SHRT_MAX + 1;         // short의 최댓값보다 큰 수를 할당. 오버플로우 발생
      int num3 = INT_MAX + 1;            // int의 최댓값보다 큰 수를 할당. 오버플로우 발생
      long long num4 = LLONG_MAX + 1;    // long long의 최댓값보다 큰 수를 할당. 오버플로우 발생
  
      // char, short, int는 %d로 출력하고 long long은 %lld로 출력
      // 부호 있는 정수에서 저장할 수 있는 범위를 넘어서면 최솟값부터 다시 시작
      printf("%d %d %d %lld\n", num1, num2, num3, num4);
      // -128 -32768 -2147483648 -9223372036854775808
  
      unsigned char num5 = UCHAR_MAX + 1;          // unsigned char의 최댓값보다 큰 수를 할당
                                                   // 오버플로우 발생
    
      unsigned short num6 = USHRT_MAX + 1;         // unsigned short의 최댓값보다 큰 수를 할당
                                                   // 오버플로우 발생
  
      unsigned int num7 = UINT_MAX + 1;            // unsigned int의 최댓값보다 큰 수를 할당
                                                   // 오버플로우 발생
  
      unsigned long long num8 = ULLONG_MAX + 1;    // unsigned long long의 최댓값보다 큰 수를 할당
                                                   // 오버플로우 발생
  
      // unsigned char, unsigned short, unsigned int는 %u로 출력하고 
      // unsigned long long은 %llu로 출력
      // 부호 없는 정수에서 저장할 수 있는 범위를 넘어서면 최솟값 0부터 다시 시작
      printf("%u %u %u %llu\n", num5, num6, num7, num8); // 0 0 0 0
  
      return 0;
  }
  ```

  실행 결과

  ```
  -128 -32768 -2147483648 -9223372036854775808 0 0 0 0
  ```

  부호 있는 정수는 저장할 수 있는 범위를 넘어서면 최솟값(음수)부터 다시 시작하고, 부호 없는 정수는 범위를 넘어서면 최솟값인 0부터 다시 시작합니다.

  마찬가지로 최솟값보다 작아지면 언더플로우가 발생합니다

  integer_min_underflow.c

  ```c
  #include <stdio.h>
  #include <limits.h>    // 자료형의 최댓값과 최솟값이 정의된 헤더 파일
  
  int main()
  {
      char num1 = CHAR_MIN - 1;          // char의 최솟값보다 작은 수를 할당. 언더플로우 발생
      short num2 = SHRT_MIN - 1;         // short의 최솟값보다 작은 수를 할당. 언더플로우 발생
      int num3 = INT_MIN - 1;            // int의 최솟값보다 작은 수를 할당. 언더플로우 발생
      long long num4 = LLONG_MIN - 1;    // long long의 최솟값보다 작은 수를 할당. 언더플로우 발생
  
      // char, short, int는 %d로 출력하고 long long은 %lld로 출력
      // 부호 있는 정수에서 최솟값보다 작아지면 최댓값부터 다시 시작
      printf("%d %d %d %lld\n", num1, num2, num3, num4);
      // 127 32767 2147483647 9223372036854775807
  
      unsigned char num5 = 0 - 1;         // unsigned char의 최솟값보다 작은 수를 할당
                                          // 언더플로우 발생
  
      unsigned short num6 = 0 - 1;        // unsigned short의 최솟값보다 작은 수를 할당
                                          // 언더플로우 발생
  
      unsigned int num7 = 0 - 1;          // unsigned int의 최솟값보다 작은 수를 할당
                                          // 언더플로우 발생
  
      unsigned long long num8 = 0 - 1;    // unsigned long long의 최솟값보다 작은 수를 할당
                                          // 언더플로우 발생
  
      // unsigned char, unsigned short, unsigned int는 %u로 출력하고
      // unsigned long long은 %llu로 출력
      // 부호 없는 정수에서 최솟값보다 작아지면 최댓값부터 다시 시작
      printf("%u %u %u %llu\n", num5, num6, num7, num8);
      // 255 65535 4294967295 18446744073709551615
  
      return 0;
  }
  ```

  실행 결과

  ```
  127 32767 2147483647 9223372036854775807 255 65535 4294967295 18446744073709551615
  ```

  최솟값에서 1을 빼서 값이 더 작아지면 언더플로우가 발생하여 다시 한 바퀴 돌게 되므로 최댓값이 출력됩니다.

  지금까지 정수 자료형의 오버플로우와 언더플로우를 설명했습니다. 값을 계산하다가 오버플로우나 언더플로우 현상이 발생하면 의도치 않은 결과가 나올 수 있습니다. 따라서 프로그래밍할때는 정수 자료형의 크기를 항상 생각하고, 값이 범위를 넘어서지는 않는지 반드시 확인합니다.

- **정수형 상수**

  C는 10진수, 8진수, 16진수로 정수형 상수를 쓰는 것을 허용한다.

  8진수 : 0으로 시작 (예 : 017, 0977, 07777)

  16진수 : 0x로 시장 (예 : 0xf, 0xff2, 0xab4)

  - 16진수에서 알파벳은 대문자, 소문자 둘다 가능하다.

    0xff == 0xfF == 0Xff = 0xFF = 0XFF = 0XFf

  정수형 상수는 처음 int로 할당되고, 만약 int로 정수형 상수를 담기 힘들다면, long으로 정수형 상수를 담는다. 그래도 부족하다면 unsigned long에 담는다. 이런식으로 수용가능한 자료형을 찾을때까지 탐색을 하는데, 직접 프로그래머가 지정을 해 줄수 있다.

  > long형으로 지정할 떄는 정수형 상수 끝에 L(또는l)을 붙여준다. 예) 15L, 075L,  0x7fffL
  >
  > unsigned int형으로 지정할 떄는 정수형 상수 끝에 U(또는 u)를 붙여준다. 예) 15U, 075L, 0x7fffU
  >
  > unsigned long int형지정할 떄는 정수형 상수 끝에 UL 또는 LU를 붙여준다. 예) 0x7ffffffLU
  >
  > long long 형은 LL(또는 ll) 

  ```c
  /* Decimal Constants */
      int                 dec_int    = 28;
      unsigned            dec_uint   = 4000000024u;
      long                dec_long   = 2000000022l;
      unsigned long       dec_ulong  = 4000000000ul;
      long long           dec_llong  = 9000000000LL;
      unsigned long long  dec_ullong = 900000000001ull;
  
  
  /* Octal Constants */
      int                 oct_int    = 024;
      unsigned            oct_uint   = 04000000024u;
      long                oct_long   = 02000000022l;
      unsigned long       oct_ulong  = 04000000000UL;
      long long           oct_llong  = 044000000000000ll;
      unsigned long long  oct_ullong = 044400000000000001Ull;
  
  
  /* Hexadecimal Constants */
      int                 hex_int    = 0x2a;
      unsigned            hex_uint   = 0XA0000024u;
      long                hex_long   = 0x20000022l;
      unsigned long       hex_ulong  = 0XA0000021uL;
      long long           hex_llong  = 0x8a000000000000ll;
      unsigned long long  hex_ullong = 0x8A40000000000010uLL;
  
  ```

- **Integer Overflow**

  정수형 자료형의 산술연산의 결과가 지정된 자료형이 표현가능한 범위를 넘어가게되는 것을 `오버플로우`라 한다.  오버플로우의 결과는 정수형 자료형이 signed 인지 unsigned 인지에 따라 다르다. (각각의 표현 가능한 최대 값에서 1을 더하면, 부호가 없는 자료형은 0을, 부호가 있는 자료형은 -로 표현 가능한 최소값을 나타낸다.)

- **정수의 입력과 출력**

  만약 `unsigned integer`를 입력 또는 출력하려면, 10진수는 `%u`를,  8진수는 `%o`를, 16진수는 `%x`를 사용한다.

  ```c
  unsigned int u;
  
  scanf("%u", &u); /*10진수 읽기*/
  printf("%u", u); /*10진수 쓰기*/
  scanf("%o", &u); /*8진수 읽기*/
  printf("%o", u); /*8진수 쓰기*/
  scanf("%x", &u); /*16진수 읽기*/
  printf("%x", u); /*16진수 쓰기*/
  ```

  `short`의 입출력은 d,o,u,x 앞에   `h`를 붙인다.

  ```c
  long s;
  
  scanf("%hd", &s);
  printf("%hd", s);
  ```

  `long long`의 입출력은 d,o,u,x 앞에   `ll`를 붙인다.

  ```c
  long long ll;
  
  scanf("%lld", &ll);
  printf("%lld", ll);
  ```

#### 7.2 실수형 타입

- 실수형 종류

  | 자료형       | 크기             | 범위                        | 유효자릿수 | 비고                         |
  | ------------ | ---------------- | --------------------------- | ---------- | ---------------------------- |
  | float        | 4바이트,  32비트 | 1.175494e-38~3.402823e+38   | 6          | IEEE 754 단정밀도 부동소수점 |
  | double       | 8바이트,  64비트 | 2.225074e-308~1.797693e+308 | 15         | IEEE 754 배정밀도 부동소수점 |
  | long  double | 8바이트,  64비트 | 2.225074e-308~1.797693e+308 | 15         | IEEE 754 배정밀도 부동소수점 |

  **지수표기법**

  > 아주 큰 숫자나 아주 작은 숫자를 표기할 때는 지수 표기법(exponential notation)을 사용합니다. 지수 표기법은 과학적 표기법(scientific notation)이라고도 부릅니다. 
  >
  > - 실수e+지수: 실수 * 10의 거듭제곱입니다. 2.1e+3이라면 2.1 * 1000 = 2100이 됩니다.    
  >
  > - 실수e-지수: 실수 * (1 / 10의 거듭제곱)입니다. 2.1e-2라면 2.1 * (1/100) = 0.021이 됩니다. 

  **long double**

  long double은 운영체제와 플랫폼마다 크기가 다릅니다.

  | 운영체제 | CPU(플랫폼)    | 바이트 크기 | 비트 크기 |
  | -------- | -------------- | ----------- | --------- |
  | Windows  | x86(32비트)    | 8           | 64        |
  | Windows  | x86-64(64비트) | 8           | 64        |
  | 리눅스   | x86(32비트)    | 12          | 96        |
  | 리눅스   | x86-64(64비트) | 16          | 128       |
  | OS X     | x86(32비트)    | 16          | 128       |
  | OS X     | x86-64(64비트) | 16          | 128       |

  > 64비트 리눅스, OS X에서는 IEEE 754 4배정도 부동소수점을 저장할 수 있습니다(3.362103e-4932~1.189731e+4932).

  **부동소수점**

  컴퓨터에서는 값을 0과 1로 저장합니다. 그래서 실수도 0과 1로 저장해야 하는데 이렇게 실수와 소수점을 2진수로 표현하는 방식을 부동소수점 표현 방식이라고 합니다. 부동소수점 방식은 자료형의 일정 부분을 비트 단위로 나누어 부호, 가수(significand), 기수(base), 지수(exponent)를 저장하여 실수를 표현합니다.

  부동소수점은 다음과 같이 기수(n)를 지수(p)만큼 거듭제곱한 값을 가수(m)와 곱하는 방식을 사용합니다. 단, 컴퓨터는 값을 저장할 때 2진수로 저장하므로 기수(밑수)는 2로 고정되어 있으며 2 자체는 따로 저장하지 않습니다.

  ![img](https://dojang.io/pluginfile.php/95/mod_page/content/42/unit8-1.png)

  | 자료형 | 크기   | 부호  | 지수   | 가수   |
  | ------ | ------ | ----- | ------ | ------ |
  | float  | 32비트 | 1비트 | 8비트  | 23비트 |
  | double | 64비트 | 1비트 | 11비트 | 52비트 |

  유효자릿수는 실수를 일정 자릿수만큼만 표현할 수 있다는 뜻입니다. 만약 유효자릿수가 6이라면 0.123456789는 **반올림**하여 0.12346로 표시됩니다. 즉, 정수 부분 1자리와 소수 부분 5자리로 6자리가 표시됩니다.

  단정밀도와 배정밀도 부동소수점은 저장할 수 있는 크기가 다르므로 유효자릿수의 차이가 있습니다. 따라서 배정밀도 부동소수점이 좀 더 긴 자릿수의 소수점을 정밀하게 표현할 수 있습니다.

- **Floating Constants**

  실수형 상수는 다양하게 표현이 가능하다.

  `57.0` `57.` `57.0e0` `57E0` `5.7e1` `5.7e+1` `.57e2` `570.e-1` 

  실수형 상수는 반드시 소수점을 표현하거나 지수(e or E)표기법을 사용해야한다.

  기본적으로 실수형 상수는 배정밀도(double)숫자로 저장된다. 필요하다면 자동으로 float으로 변환된다. 그래도 지정해주기 위해서는 실수형 상수 뒤에, F(or f)나 L(or l)을 붙여줘서 형식을 지정해 줄 수 있다.

- **부동소수점 읽고 쓰기**

  `%e` : 지수형  (예：1.256637e+001)

  `%f` : 일반 실수형 (예：12.566371)

  `%g` : 숫자값의 크기에 따라 f나 e로 출력 (예：12.5664、2.99792e+008). 숫자값의 절대치가 너무 커서 precision의 자리수를 넘는 경우와 숫자값의 절대값이 0.0001보다 작은 경우 e형식이 사용되어짐. 그 외의 경우는 f형식으로 사용됨

  

  `double` 자료형은 `scanf`를 쓸때  e,f,g 앞에 `l`을 붙인다.

  cf)`printf`는 `l`을 붙이지 않아도 된다.

  ```c
  double d;
  
  scanf("%lf", &d); 
  ```

  `long double` 자료형은 double과 다르게 `scanf` 또는 `printf` 모두 e,f,g 앞에 `L`을 붙인다.

  ```c
  long double ld;
  
  scanf("%Lf", &ld);
  printf("%Lf", ld);
  ```

#### 7.3 문자형 타입

- **문자형의 기본 타입은 `char`이다. 컴퓨터 마다 character sets이 다를 수 있다.**

- **문자형에 연산자를 쓰면?**

  문자형도 비트단위의 숫자로 저장되기 때문에 숫자처럼 다룰수도 있다.

  ```c
  char ch;
  int i ;
  i = 'a';    // i is now 97  ('a' == 97)
  ch = 65;    // ch is now 'A'  ('A' == 65)
  ch = ch + 1; // ch is now 'B'  ('B' == 66)
  ch++;       // ch is now 'C'  ('C' == 67)
  ```
  비교 연산자도 사용 할 수 있다.

  ```c
  if( 'a' <= ch && ch <= 'z')
     ch = ch - 'a' +'A';
  ```

  ```c
  for( ch = 'A'; ch <= 'Z'; ch++)
  {
      ...
  }
  ```

- **signed and unsigned 문자형**

  C는 signed char과 unsigned char를 제공한다. signed char는  -128~127 까지, unsigned char는 0~ 255까지 표현 가능한 작은 단위의 정수형 처럼 사용 가능하다.

  ```c
  signed char sch;
  unsigned char uch;
  ```

  이때, signed와 unsigned를 반드시 지정해주는 것이 바람직하다.

- **Arithmetic Types**

  - Integral Types
    - char
    - singned integer types ( signed char, short int, int , long int)
    - unsigned integer types ( unsigned char, unsigned  short int, unsigned  int , unsigned long int)
    - Enumerated types
  - Floating types
    - Real Floating types(float, double, long double)
    - Complex type (float_Complex, double_Complex, long double_Complex )

- **Escape Sequences**

  | Escape sequence | Hex value in ASCII |                    Character represented                     |
  | :-------------: | :----------------: | :----------------------------------------------------------: |
  |       \a        |         07         | [Alert (Beep, Bell)](https://en.wikipedia.org/wiki/Bell_character) (added in C89) |
  |       \b        |         08         |     [Backspace](https://en.wikipedia.org/wiki/Backspace)     |
  |       \e        |         1B         | [Escape character](https://en.wikipedia.org/wiki/Escape_character) |
  |       \f        |         0C         | [Formfeed](https://en.wikipedia.org/wiki/Formfeed) [Page Break](https://en.wikipedia.org/wiki/Page_Break) |
  |       \n        |         0A         | [Newline](https://en.wikipedia.org/wiki/Newline) (Line Feed); see notes below |
  |       \r        |         0D         | [Carriage Return](https://en.wikipedia.org/wiki/Carriage_Return) |
  |       \t        |         09         | [Horizontal Tab](https://en.wikipedia.org/wiki/Horizontal_Tab) |
  |       \v        |         0B         |  [Vertical Tab](https://en.wikipedia.org/wiki/Vertical_Tab)  |
  |       \\\       |         5C         |     [Backslash](https://en.wikipedia.org/wiki/Backslash)     |
  |       \\'       |         27         | [Apostrophe](https://en.wikipedia.org/wiki/Apostrophe) or single quotation mark |
  |       \\"       |         22         | Double [quotation mark](https://en.wikipedia.org/wiki/Quotation_mark) |
  |       \?        |         3F         | [Question mark](https://en.wikipedia.org/wiki/Question_mark) (used to avoid [trigraphs](https://en.wikipedia.org/wiki/Digraphs_and_trigraphs#C)) |

  `\ooo` 시퀀스는 ASCII 문자 집합의 문자를 세 자리 8진수 문자 코드로 지정할 수 있음을 의미합니다. 8진수 정수의 숫자 값은 원하는 문자 또는 와이드 문자의 값을 지정합니다. 마찬가지로 `\xhhh` 시퀀스를 사용하면 ASCII 문자를 16진수 문자 코드로 지정할 수 있습니다. 예를 들어, ASCII 백스페이스 문자를 표준 C 이스케이프 시퀀스(**\b**)로 지정하거나 **\010**(8진수) 또는 **\x008**(16진수)로 코딩할 수 있습니다.

  8진수 이스케이프 시퀀스에 0부터 7까지의 숫자만 사용할 수 있습니다. 8진수 이스케이프 시퀀스는 길이가 3자리 이내여야 하며 8진수가 아닌 첫 번째 문자로 끝납니다. 3자리 숫자를 모두 사용할 필요는 없지만 하나 이상 사용해야 합니다. 예를 들어, 8진수 표현은 ASCII 차트에 지정된 대로 ASCII 백스페이스 문자에 대해 **\10**이고 문자 A에 대해 **\101**입니다.

  마찬가지로 16진수 이스케이프 시퀀스에 대해 하나 이상의 숫자를 사용해야 하지만 두 번째 숫자와 세 번째 숫자를 생략할 수 있습니다. 따라서 백스페이스 문자의 16진수 이스케이프 시퀀스를 **\x8**, **\x08** 또는 **\x008**로 지정할 수 있습니다. 이때 x는 반드시 소문자여야 합니다.

  또한, 단독으로 쓰일 경우에는 반드시 `' '`(따옴표)를 사용해주어야 합니다.

  ```c
  #define ESC '\33'
  ```

  문자열 내부에서도 사용이 가능합니다.

- **문자 취급 함수**

  소문자를 대문자로 바꾸는 코드는 아래와 같다.

  ```c
  if( 'a' <= ch && ch <= 'z')
     ch = ch - 'a' +'A';
  ```

  하지만, C는 더 간편한 방수를 제공한다.

  ```c
  #include <ctype.h>
  
  ch = toupper(ch);
  ```

- **scanf와 printf**

  하나의 문자를 읽거나 쓸때, scanf와 printf를 사용할 수 있다.

  ```c
  char ch;
  
  scnaf("%c", &ch);
  printf("%c", ch);
  ```

  scanf는 공백을 스킵하지 않고 읽는다. 만약 공백을 스킵하고 싶다면, `%c`이전에 공백을 추가한다.

  ```c
  scnaf(" %c", &ch);
  ```

  개행문자를 체크해서, 한줄을 읽어 올 수 있다.

  ```c
  do{
  	scanf("%c", &ch);
  }while(ch!='\n');
  ```

- **getchar과 putchar**

  putchar는 하나의 문자를 쓰는 함수이다. `putchar(ch);`

  getchar는 문자 하나를 읽어와 반환해준다.`ch = getchar();`

  getchar와 putchar는 scanf와 printf보다 빠르다

  	1. 더 단순한 구조이다. (scanf와 printf는 다양한 자료형을 목적으로 만들어짐)
   	2. getchar와 putchar는 속도를 내기위해 매크로를 수반한다.

  getchar가 scanf보다 좋은 점

  - 그 자체로 값을 리턴해주기 때문에 아래와 같이 사용이 가능하다.

    ```c
    //해당 줄의 남은 문자skip 
    
    do{
    	ch = getchar();
    }while(ch!='\n');
    //또는
    while((ch=getchar())!='\n')
        ;
    //또는
    while(getchar() !='\n')
        ;
    ```

    ```c
    //공백 스킵
    while((ch = getchar()) ==' ')
        ;
    //반복문이 끝나면 ch는 처음으로 공백이 아닌 글자를 가지고 있다
    ```

  **getchar와 scanf를 같은 프로그램에서 혼용해서 사용할때 주의 점**

   scanf는 버퍼에 개행문자나 쓰레기 값을 남기게 된다. 그렇기 때문에 scanf를 사용하고 나서 `fflush(stdin)`을 해주는 것이 좋다.
  
  

#### 7.4 형변환

- 연산적인 부분에 있어 컴퓨터는 C보다 더 제한적인 경향을 보인다. 컴퓨터가 연산을 할 때 피연산자는 같은 사이즈여야 하고 저장도 같은방식으로 된다. 하지만 C는 기본타입의 형을 섞어서 연산하는것을 허용한다. 하나의 표현식에서 int,float,char을 혼용할 수 있다. C컴파일러는 서로 다른 타입을 전환해주어 하드웨어가 연산이 가능하도록 해준다. 

  예를들어, `short`(16bit) 와 `int`(32bit)형을 더하면, 컴파일러는 short를 int로 변환하여 연산한다. 만약, int와 float을 연산하면 int를 float으로 바꿔 연산한다. 이 변환은 int와 float이 다른 형식으로 저장되어 있기 때문에 생각보다 복잡하다. 

  **묵시적 형변환**

  프로그래머가 관여하지 않고, 컴파일러가 자동으로 형변환 시켜주는 것

  컴파일러가 묵시적으로 형변환 하는 것은 복잡하다.(많은 Type이 존재하기 때문에)

  - 묵시적 형변환이 실행되는 경우들

  1. 논리 또는 산술 연산의 피연산자가 다른 타입을 가질 때 (**The usual Arithmetic conversios**)
  2. 변수에 값을 할당할 때 우측값이 좌측변수의 타입과 다를 때
  3. 함수 호출 시 아규먼트와, 파라미터의 타입이 매칭 되지 않을 때
  4. 리턴 값의 자료형과 함수의 리턴 타입이 일치 하지 않을 때

- **The usual Arithmetic conversios**  

  `int + float`의 경우 int를 float으로 형변환하여 계산


# 아직 안됨!! 143페이지

### 08. Array

c는 배열과 구조체라는 두개의 집합 변수를 지원한다.

#### 8.1 1차원 배열

- 한 줄로 원소를 나열하는것

- 배열을 선언하기 위해 배열 사이즈와 자료형을 지정해줘야 함

  - `int a [10];`

- 원소의 자료형은 어떤 타입이나 가능함

- 상수로 배열의 길이를 지정 가능

- 추후에, 배열의 길이를 수정해야 할 수도 있기 떄문에, define을 사용해서 배열의 길이를 지정해주는 것이 좋음

  ```c
  #define N 10
  
  int a[N];
  ```

- 배열의 이름과 대괄호안에 인덱스를 넣어 특정 원소에 접근 가능하다
- 길이가 n인 배열의 원소의 인덱스는 0번부터 n-1까지 존재한다.
  - 배열의 길이가 10일때
    - `a[0]` `a[1]` . . . `a[8]` `a[9]`

- 배열의 원소는 다른 변수와 마찬가지로 취급 할 수 있다.
  
- `a[0]=1` `++a[i]` `printf("d\n", a[5])`
  
- for를 활용하여 배열을 잘 활용할 수 있음, for루프로 배열의 모든 원소를 접근하여 연산할 수 있음

  ```c
  for(int i =0; i<N;i++){
      a[i]=0;
  } //clear
  
  for(int i =0; i<N;i++){
      scanf("%d", &a[i]);
  } // read data into a
  
  for(int i =0; i<N;i++){
      sum += a[i];
  } //sum
  ```

- C는 배열의 범위를 체크하지 않는다. 배열의 범위를 넘어서면 프로그램은 비정의행동을 한다.  몇몇 컴파일러는 아래의 예시에서 무한 루프를 만들어낸다. a[9] 다음에 i가 정의 되어 있을때, a[10]=0;을 실행하면 i=0이 되기 때문이다.

  ```c
  int a[10],i;
  for(i =0; i<N;i++){
      a[i]=0;
  }
  ```

- 아래의 코드는 비정의 행동을 한다. 4.4에서 본것 같이 증감연산자는 표현식이 끝나기전까지 실행이 되지만, 그게 언제인지는 명확하지 않다. 아래의 코드에서 a[i] 와 b[i++]의 i가 같지 않을 수 있다.

  ```c
  i=0;
  while (i<N){
      a[i]=b[i++];
  }
  ```

- 배열 초기화

  일반적인 방법은 중괄호 안에 콤마로 구분지어 선언과 동시에 배열을 초기화 해주는 방법이다.

  `int a[10] = {1,2,3,4,5,6,7,8,9,10}`;

  만약, 전체를 다 초기화하지 않고 일부만 초기화 할경우, 나머지 값은 모두 0으로 초기화 된다.

  `int a[10] = {1,2,3,4,5,6}`; => a : 1 2 3 4 5 6 0 0 0 0

  이 특성을 이용하여, 모두 0으로 초기화하는 쉬운방법이 있다

  `int a[10] = {0}`;  //중괄호 안에 아무것도 안쓰는 것은 허용되지 않음

  배열의 길이를 쓰지않고 초기화하는 방법이 있다. 이 경우 컴파일러가 배열의 길이를 지정해준다.

  `int a[] = {1,2,3,4,5,6,7,8,9,10}`

- `C99` 만약 특정 원소만 특정정값을 가지고 나머지 원소는 0으로 만들고 싶으면 C99버전부터는 아래와 같은 식을 허용한다.

  ```c
  // a : 0 0 29 0 7 0 0 0 0 48 
  
  
  //지정자는 반드시 정수형 상수여야 한다.
  int a[10] = { [2] = 29, [4] = 7, [9] = 48 };
  //또는 순서에 상관없이도 지정이 가능하다
  int a[10] = { [4] = 7, [9] =48, [2] = 29 };
  
  ```

- 만약 길이가 지정이 안된다면, 내부에서 가장 큰 값을 배열의 길이로 갖는다. 아래의 배열의 초기화 괄호 내부의 가장큰 지정자 값이 30이므로, 배열의 크기는 31이다.

  ```c
  int a[] = { [2] = 29, [4] = 7, [9] = 48, [30] = 1 };
  ```

- 아래와 같이 혼용해서 사용도 가능하다.

  ```c
  int a[10] = {1, 2, [4] = 7, 8, 9, [9] = 48 };
  // 1 2 0 0 7 8 9 0 0 48
  ```

  1과 2는 처음에 나오고, 4번째 원소는 7, 4번쨰 원소 뒤 8, 9가 순서대로 오고, 다시 9번째 원소는 48이 온다. 이때 나머지 원소는 모두 0이 된다.

- bool과 true와 false는 `stdbool.h`에 포함되어있다. 만약 컴파일러가 이를 지원하지 않는다면 직접 define을 사용해서 선언해 주어야 한다

  ```c
  #define true 1;
  #define true 0;
  #define bool int;
  ```

- sizeof 연산자를 이용해 배열의 사이즈를 구할 수 있다.

  배열의 길이가 10인 int형 배열 `int a[10]`의 sizeof(a)는 40이 나온다. 이는 int형 자료형 4byte가 10개가 있어 40이 나오는 것이다. 즉 sizeof는 byte의 크기를 반환한다.

  만약 배열의 길이를 구하고 싶다면 `sizeof(a) / sizeof(a[0])`을 사용하면 된다. (10이 나옴)

  만약 배열의 길이를 모를 경우, for문을 사용할 때 sizeof를 활용 할 수 있다. 이때  배열의 길이가 달라져도 코드를 수정할 필요가 없다. 이는 매크로를 사용한 결과와 비슷하지만, sizeof를 활용한 방법은 매크로이름을 기억할 필요가 없기 때문에 오류의 확률을 줄여준다.

  ```c
  for(i=0; i< sizeof(a) / sizeof(a[0]); i++){
      a[i]=0;
  }
  ```

  하지만, 몇몇 컴파일러는 `i< sizeof(a) / sizeof(a[0])`표현식에 에러를 띄운다. i는 int 타입(signed)이지만, sizeof의 결과는 size_t 타입(unsigned) 이기때문이다. signed 타입과 unsigend 타입을 비교하는 것은 위험하다. (물론 이경우에는 `i`와 `i< sizeof(a) / sizeof(a[0])`모두 음수가 나올 일이 업기 때문에 위험하진 않다. ) 에러를 피하기 위해 형변환을 해줄 수 있다.

  ```c
  for(i=0; i< (int) (sizeof(a) / sizeof(a[0])); i++){
      a[i]=0;
  }
  ```

  하지만, `(int) (sizeof(a) / sizeof(a[0]))`는 너무 긴 표현식이기 때문에 매크로를 이용하여 간략화 해주는 것이 좋다.

  ```c
  #define SIZE_a (int) (sizeof(a) / sizeof(a[0]))
  
  for(i=0; i< SIZE_a ; i++){
      a[i]=0;
  }
  ```

  #### 8.2 다차원 배열

- 배열은 어떤 수의 차원이든 가질 수 있다. 행렬과 같이 2차원 배열도 가능하다

  `int m[5][9]`는 5개의 행과 9개의 열을 가진 배열이다.

- `m[i][j]`와 `m[i,j]`는 다르다. 여기서 ,는 연산자로 취급되어 m[i,j]는 m[j]와 같다. 
- 우리는 테이블 형태로 2차원배열을 시각화하지만, 사실 메모리에는 일렬로 저장된다. 

- 다중 배열의 초기화 `m[2][3]` 배열을 초기화 할때, 중괄호의 집합을 또 중괄호의 집합으로 묶어주어 표현해준다.

  ```c
  int m[2][3]={{1, 1, 1},
               {1, 1, 1}};
  ```

- 초기화시 비워둔 열이나 행이 있다면 0으로 해당 부분은 0으로 초기화 된다.

- 실제로는, 내부 중괄호를 생략 가능하다. 이때 열단위로 먼저채우고 나머지는 0 으로 초기화된다. (비추)

- 2차원 배열을 아래와 같이 초기화하면 모든 원소를 0으로 만들 수 있다.

  ```c
  bool ABC[10][10]={false};
  int I[10][10]={0};
  ```

  

- 1차원 배열과 마찬가지로, 초기화시 원하는 원소만 원하는 값으로 초기화하고 나머지는 다 0으로 초기화가 가능하다.

  ```c
  double ident[2][2]={[0][0]=1.0, [1][1]=1.0};
  ```

- 상수 배열

  const를 붙여 1차원 배열이나 다차원배열에서 상수 배열을 만들수 있다.

  ```c
  const char hex_chars[]={'0','1','2','3','4','5','6','7','8','9','A', 'B','C','D','E','F'};
  ```

  상수 배열은 프로그램에의해 수정되지 말아야하며, 컴파일러에 의해 감시된다. 즉, 변화하지 않는 자료라는 것을 컴파일러에게 알려주는 것이다.

#### 가변길이 배열 (비주얼스튜디어에서는 불가, gcc컴파일러에서는 가능)

C99버전 부터 가변길이 배열 사용이 가능하다. 보통 상수에 의해 배열의 길이가 정해지지만, 아닌 경우도 존재한다. 아래와 같이 길이가 프로그램이 실행될 때 결정이 될 수있다.

```c
int i,n;

scanf("%d", &n);

int a[n];
```

VLA(variable-length array)는 배열을 너무 길거나 짧게 선언하는 문제에 대해서 효과적이다. VLA를 사용할때는 초기화를 사용해서는 안되며, 정적인 저장소를 가질 수 없다. 그리고, VLA는 메인문보다는 함수에 사용하기 유용하다. 함수가 호출될때마다 다른 길이의 배열을 사용 할 수 있기 때문이다.

또한, 연산자를 포함한 선언도 가능하다.

```c
int a[3*n+i];
```

#### Q&A

- 아래의 경우 초기화를 여러번 할 수 있다.

```c
int a[] ={4,9,1,8,[0]=5,7};
```

이 경우 a는 5, 7, 1, 8의 원소가 들어가는 길이 4의 배열이 된다.

- 배열의 복사는 원소단위로 해야한다.

  `a=b`는 허용되지 않는다.

  다른 방법으로는, `string.h`에 있는  `memcpy`함수를 이용하는 것이다. 이 방법은 low레벨에서 메모리를 바이트 단위로 카피하는 역할을 한다.

  `memcpy(a, b, sizeof(a));`

  큰 배열의 경우 원소단위로 복사하는 것 보다. memcpy 함수가 더 빠르다.

- goto를 이용하여 VLA에 접근할 수 없다. 만약, goto를 이용하여 VLA에 접근하게 하려고한다면, VLA는 아직 메모리가 할당되지 않은 상태이기 때문에 주소가 존재하지 않기 때문에 불가능하다.

### 09. 함수

#### 9.1 함수의 정의와 호출

- 리턴타입
- 파라미터 : 함수에서 실제 사용되는 변수 (아규먼트를 받는 변수)
- body
- 아규먼트 : 함수를 호출하는 곳에서 사용되는 자료(상수, 변수 등)

- 함수 정의

  ```
  return type 함수 이름 (파라미터)
  {
  	선언문(declarations)
  	statements
  }
  ```

- 함수는 배열을 리턴 할 수 없음

- 리턴 타입이 없으면 void

- C89에서 리턴타입이 생략되면 int 값을 리턴하는것으로 가정한다.

- C99에서는 리턴타입이 없으면 illegal이다

- 파라미터는 각각 자료형을 써주어야 한다.

  ```c
  double avg (double a,b){     //Wrong
  
  }
  
  double avg (double a, double b){     //OK
  
  }
  ```

- 함수 안에서 선언된 변수는 그 함수내에서 만 사용된다.

- C89에서 변수의 선언이 앞에온 다음 statements가 와야 한다.

- C99 부터는 변수 선언과 statements가 섞일 수 있다.

- 리턴 타입이 void인 함수의 body는 비어있을 수 있다. body가 비어 있으면 시간이 소요되지 않고 호출된 자리로 다시 돌아간다.

  ```c
  void emptyFunc(void){
  
  }
  ```

  

-  함수 호출

  함수 명과 괄호 안에 아규먼트를 써서 호출 한다.

  ```c
  avg (x,y);
  print_count(i);
  print_pun();
  ```

  괄호는 필수이다. 괄호가 없어도 실행은 되지만 아무런 결과를 보여주지 않는다. 몇몇 컴파일러는 경고를 하기도 한다.

- nov void 리턴 함수의 결과는 사용하지 않으면 버려질 수 있다.

- 사실 printf 함수는 char의 갯수를 리턴하지만, 보통 리턴값은 무시하고 사용된다,

  ```c
  num_char = printf("hi, mom!\n");
  printf("hi, mom!\n");
  ```

  리턴을 버리는것을 명확하게 명시하기 위해 함수 앞에 void를 써줄 수 있다.

  ```c
  (void) printf("hi, mom!\n");
  ```

  이 방법은 형변환 캐스팅을 해주는 것이다. printf의 리턴 타입을 void로 형변환 해주는 것이다. 

#### 9.2 함수의 선언

- 함수가 호출되기전의 위치에 함수가 정의 되어야하지만, 사실 C는 함수의 정의가 함수가 호출되는 위치의 뒤에 와도 된다. 예를 들어 메인함수에서 어떤 함수를 호출한다고 하면, 그 함수가 메인문이 끝난 후에 정의 되어도 된다. 컴파일러가 처음 함수의 호출을 만나면, 그 함수에 대한 정보(파라미터의 타입, 리턴 타입 등)가 없기 때문에 컴파일러는 함수의 리턴 타입을 **int 타입(디폴트)으로 가정**한다. (실제로는 다른 타입이라고 하더라도) 이것을 컴파일러가 함수의 **묵시적 선언**을 했다고 한다. 또한, 컴파일러는 파라미터의 수와 아규먼트의 수가 동일한지 모른다. 후에 컴파일러가 함수의 정의를 만났을 때 컴파일러는 **함수의 리턴타입이 int가 아닌 다른 타입인걸 알아채면** **에러 메세지**를 보낸다.

- 위와 같은 문제를 피하기 위해, 함수가 호출 되기 이전에 함수를 정의하는 것이다. 하지만, 함수의 정의를 전체다가 호출되기 이전에 놓으면, 더러운 코드가 된다. C는 함수의 선언을 함수가 호출 되기 이전에 하는 것을 허용해준다.  함수의 선언을 통해 함수에 대한 정보를 컴파일러에게 미리 제공해 줄 수 있다.

- 함수의 선언 == **function prototypes**

  ```c
  #전처리
  
  리턴타입 fn1 (파라미터);  /*함수의 선언or function prototypes*/
  
  int main(){
      statemesnts;
  }
  
  리턴타입 fn1 (파라미터){
      return (a+b) / 2;
  }
  ```

  함수의 선언(function prototypes)을 할때에는 파라미터의 정확한 변수 이름을 쓰지 않아도 되고, 자료형만 쓰거나 쓰고 싶은 이름을 마음대로 써도 괜찮다. `double avg (double, double)`

- C99부터는 함수의 정의 또는 선언이 호출되기 이전에 나오지 않으면 int형으로 묵시적으로 컴파일러가 판단하지 않고 바로 에러를 띄운다.

#### 9.3 Arguments

- 파라미터와 아규먼트의 차이점.
  - 파라미터 : 함수의 정의에 있음
  - 아규먼트 : 함수의 호출에 있음

- Passed by value : 각 아규먼트가 각 파라미터로 매칭이되어 할당 되는 방식, 아규먼트의 값을 파라미터로 카피한다. 함수내에서 파라미터의 값이 바뀌어도, 아규먼트에는 영향을 주지 않는다.

  하지만, 두개 이상의 값을 리턴 받고 싶을 때 유용하지 않다.

- **아규먼트 conversion(형변환)**

  파라미터와 아규먼트의 타입이 일치하지 않을 때 함수의 선언이 호출 전에 있는지 아닌지에 따라 형변환이 일어난다.

  **함수 호출 전에 함수 프로토 타입이 있는 경우 :**  아규먼트들은 묵시적으로 파라미터로 형변환 된다.(할당과 비슷)

  **함수 호출 후에 함수 선언이 있는 경우 :**  아규먼트들은 **defalut argument promotions**를 수행한다. float 타입의 아규먼트는 double로, char 타입이나 short 타입의 아규먼트는 int로 변환된다.

- 함수를 호출 할 때, `avg((int)x,(int)y);`와 같이 명시적 형변환을 해 줄 수 있다.

- **배열 아규먼트**

  배열을 아규먼트로 사용할 수 있는데, 이때 파라미터는 길이를 생략할 수 있다.

  ```c
  int f (int a[])
  {
  ...
  }
  ```

  이때, 아규먼트는 길이에 상관없이 1차원 배열이면 가능하다. 이때, 문제는 아규먼트 배열의 길이가 얼마나 될지 함수가 어떻게 아냐는 건데, 파라미터를 하나더 추가해서 배열의 길이 까지 전달해주면 문제를 해결 할 수 있다.

  **참고로, 함수내에서 a 배열의 길이를 구하는 sizeof()함수를 써도 아규먼트 였던 배열의 길이는 알 수 없다.** 

  파라미터 명을 생략한 프로토 타입의 경우는 이렇게 사용할 수 있다.

  ```c
  int sum_arr (int [], int);
  ```

  함수를 호출 할 때에는 아규먼트에는 `[]`를 써주지 않는다.

  ```c
  sum_arr(arr, n);   //OK
  sum_arr(arr[], n);   //WRONG
  ```

  **★배열을 파라미터로 사용 할 때 가장 중요한 포인트는, 함수내에서 변화된 파라미터는 아규먼트에도 그대로 반영이 된다는 점이다.**

- **다중 배열 파라미터**

  배열의 가장 처음 길이만 생략한다.

  ```c
  int f (int a[][4])  //2차원 배열을 파라미터로 받을 때 예
  {
  ...
  }
  ```

- **VLA 파라미터**

  C99, VLA 배열의 경우 n을 명시적으로 적어 줄 수 있다.

  하지만, 이때 n이 먼저 선언이 되어야 하기 때문에, 파라미터 선언 순서에 주의 하자. 컴파일 에러 발생! (n을 선언 후 int a[n] 선언)

  ```c
  int sum_arr (int n, int a[n]){
  
   ...
  
  }
  //OK
  int sum_arr (int n, int m, int a[n+m], int b[n]){
  
   ...
  
  }
  //OK
  int sum_arr (int n, int m, int a[n][m]){
  
   ...
  
  }
  //OK
  ```

- 2차원 배열을 선언 할 때 가능한 방법 들

  ```c
  int sum_arry(int n, int m, int a[n][m]);
  int sum_arry(int n, int m, int a[*][*]);
  int sum_arry(int n, int m, int a[][m]);
  int sum_arry(int n, int m, int a[][*]);
  ```
  

배열을 선언 할 때 가능한 방법 들

  ```c
  int sum_arry(int n, int a[n]);
  int sum_arry(int n, int a[*]); // 선언 할 때에는 *로 어떠한 값이 함수를 정으할때 들어 가는 것을 암시적으로 표현 가능하다.
  int sum_arry(int, int [*]);
  int sum_arry(int n, int a[]);
  int sum_arry(int , int []);
  ```

  225 / 200page

#### 9.4

#### 9.5 

- 함수의 리턴 타입과 `return ~~~`의 `~~~`타입이 다르다면 함수의 리턴 타입으로 자료형이 묵시적 형변환 된다.

- void 타입 retrun

  return 뒤에 아무것도 쓰지 않는 것.

  void 타입의 함수에는 return; 을 써주거나 아예 리턴을 생략해도 무방하다.

- 만약 void형이 아닌 함수에서 리턴이 존재하지 않을 경우, 몇몇 컴파일러에서는 경고를 해주지만, 아닌 경우도 존재한다. 이경우 비정의 행동을 하기 때문에 어떤 값이 나올지 모른다.
- 



### 12. 포인터와 배열

(267페이지)

#### 12.4 다차원 배열과 포인터

일차원 배열과 마찬가지로 다차원 배열의 원소도 포인팅 할 수 있음.

- **다차원 배열에서 원소를 처리하는 법**

  다차원 배열도 행단위의 배열이 메모리 상에 일렬로 나열되어 있는 형태이기 때문에 포인터를 이용하여 순차적으로 접근이 가능하다. (267페이지)

  ```c
  /*모든 원소 0으로 초기화*/
  
  /*이중포문*/
  int row, col;
  for( row = 0; row < NUM_ROWS; row++)
  	for( col = 0; col <NUM_COLS; col++)
          a[row][col] = 0;
  /*---------------------------------------*/
  
  /*포인터를 이용(하나의 포문)*/
  int *p;
  
  for(p = &a[0][0]; p <= &a[NUM_ROWS-1][NUM_COLS-1]; p++)
      *p = 0;
  ```

  다차원 배열을 마치 일차원 배열 처럼 다룰 수 있다. 

  &a\[0][0]은 배열의 가장 첫 주소를 나타낸다.

  오래된 컴파일러에서는 일차원 배열처럼 다루는 것이 효율적인 측면에서 이점이 있지만, 최신 컴파일러에서는 거의 차이가 없다.

  

- **다차원 배열에서 행을 처리하는 법**

  `p = &a[i][0]` 은 i행의 첫 번째 원소의 주소를 포인터에 담는 것

  `p = &a[i][0]` 은 `p=&a[i]` 로 표현 가능하다. ( 1차원 배열에서 `a[i]` 는 `*(a+i)`와 동일하다. 그러므로, 2차원 배열에서는 `&a[i][0]`은 `&( *( a[i] + 0 ) )`와 동일하고  `&*a[i]` 이렇게 변형이 가능하다. *와 &는 상쇄가 되어 `a[i]`로 표현이 가능하다)

  ```c
  /*i번째 행을 0으로 초기화 하는 법*/
  
  int *p, i, a[NUM_ROWS][NUM_COLS];
  ...
  for(p = &a[i]; p < a[i] + NUM_COLS; p++)
      *p = 0;
  ```

   한 행을 1차원 배열 처럼 함수의 아규먼트로 활용 할 수 있다.

  ```CQL
  largest = find_largest(a[i], NUM_COLS);
  ```

  

- **배열에서 열을 처리하는 법**

  ```c
  /*i번째 열을 0으로 초기화 하는 법*/
  
  int i, a[NUM_ROWS][NUM_COLS], (*p)[NUM_COLS];
  ...
  for(p = &a[0]; p < &a[NUM_ROWS]; p++)
      (*p)[i] = 0;
  ```

  변수 선언에서 `int (*p)[NUM_COLS]`는 길이가 int형 배열의 길이가 NUM_COLS 인 배열을 가리키는 포인터를 의미한다. 이때 ()를 생략하면 안된다.(괄호를 생략하게 되면 배열의 포인터가 아닌, 포인터의 배열로 인식함) 

  `p++`은 p를 다음 행의 첫 번째 원소의 주소로 증가시켜준다.

  `(*p)[i]` 은 각 행의 i번째 원소에 접근한는 방법이다. (이때 `*p`자체는 하나의 배열을 의미 한다. 즉 *p는 길이가 NUM_COLS인 1차원 배열의 이름과 같다고 볼 수 있다.) 이때 괄호를 생략하면 안된다.( *p[i]를 *( p[i] )로 해석하기 때문에 )

  

- **다중 배열의 이름을 포인터로 활용는 법**

  `int a[NUM_ROWS][NUM_COLS];` 의 배열의 `a`는 `a[0][0]`의 포인터가 아니라 `a[0]`의 포인터라고 생각하는 게 좋다. `a`의 타입은 `int (*) [NUM_COLS]` (길이가 NUM_COLS인 int형 배열을 가리키는 포인터)
  
  a[0] 는 2차원 배열의 처리를 하는 간단한 방법이다.
  
  ```c
  /*i번 째 열을 초기화 하는 방법*/
  for(p= &a[0]; p<&a[NUM_ROWS]; p++){
      (*p)[i] = 0;
  }
  //아래 방법도 사용가능하다.
  for(p= &a[0]; p< a + NUM_ROWS; p++){
      (*p)[i] = 0;
  }
  ```
  
  다차원 배열을 1차원 배열처럼 사용할 때 주의 해야할 점이 있다.
  
  a와 a[0]의 차이를 먼저 이해해야 한다.
  
  a의 자료형은 `int (*) [NUM_COLS]`으로 a+1을 하면 배열의 길이만큼 메모리를 점프한다.
  
  a[0]의 자료형은 `int(*)`으로 a[0]+1을 하면 int 하나만큼의 길이를 점프한다.
  
  따라서 `largest = find_largest(a, NUM_ROWS * NUM_ COLS)`는 잘못되었다.
  
   `largest = find_largest(a[0], NUM_ROWS * NUM_ COLS)`이 맞는 표현이다.



포인터.. #include <typeinfo>

#### 12.5 포인터와 VLA

- C99에서 가변 길이 배열 

  ```c
  void f(int n)
  {
  	int a[n], *p;
  	p=a;
      ....
  }
  ```

- 다중배열 VLA

  ```c
  void f(int m, int n)
  {
  	int a[m][n], (*p)[n];
  	p=a;
      ....
  }
  ```

  p는 n의 크기에 따라 결정되고  n은 상수가 아니기 때문에, p는 v**ariably modified type** 이라고 불린다. p=a;의 가능여부는 컴파일러에 의해 결정되지 않는다. 예를 들어

  ```c
  int a[m][n], (*p)[m];   // (*p)[n]이 아님..
  p=a;
  ```

  위의 경우 m과 n이 같은 값이 아니라면 비정의 행동을 할 것이다. 따라서 m과 n이 같을 때에만 정상 동작하게 된다.

  VLA처럼 **variably modified type**은 특정한 제약에 지배를 당한다. 가장 중요한 제약은 variably modified type은 함수의 body나 prototype에 선언이 되어야 한다는 것이다.  

  VLA의 Pointer arithmetic은 일반적인 배열의 방식과 동일하게 동작한다.

  ```c
  int a[m][n];
  int (p*)[n];
  
  for (p=a; p<a+m; p++)
      (*p)[i] = 0;
  ```

  