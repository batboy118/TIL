# C를 학습하면서 배운 것들

### 01. Intriducing C

#### Origin

C는 유닉스의 부산물이다. 유닉스는 같은 시기의 다른 OS와 동일하게 어셈블리 언어로 프로그래밍 되었다. 어셈블리 랭귀지는 디버깅과 업그레이드하기 힘들고 유닉스도 예외는 아니다. 유닉스의 창시자인 Thompson은 고급 언어를 사용하여 유닉스를 개발하기로 결심했다. 그는 처음 B라는 언어를 디자인 했다. 하지만 유닉스에 B언어는 적당하지 않았고, 유닉스에 적당한 언어인 C를 개발하여 유닉스를 개발하였다. C는 이식성이 우수했고, 연구소에 있는 다른 컴퓨터들을 위한 C컴파일러를 만들어, 성공적으로 유닉스를 다른 컴퓨터에서도 실행할 수 있었다.

#### Standardization

 1983년에 ANSI가 K&R C를 확장 겸 표준화하기 위해 짐 브로디를 주축으로 X3J11 위원회를 소집하고 1989년에 ANSI X3.159-1989라는 공식 명칭으로 C언어 표준을 제정했다. K&R C의 확장안 성격을 가지고 있으며, 이때 제정된 C언어 표준이라고 해서 C89라고도 불렀다. 1990년에 ANSI가 C언어 표준을 국제 표준화기구(ISO)에 넘기면서 내용 변화 없이 ISO/IEC 9899:1990라는 또 다른 공식 명칭으로도 채택되었다. 내용 자체는 먼저 제정된 ANSI C와 동일하기 때문에 C90이라고 부르기도 하지만 보통은 먼저 승인된 C89가 더 많이 불려진다. 2019년에도 이 C89/90가 사실상의 표준인데, 이유는 여러 가지가 있다. 먼저 C89/90 다음 버전부터는 [마이크로소프트](https://namu.wiki/w/마이크로소프트)에서 표준안을 제대로 지키는 컴파일러를 내놓지 않은 영향이 가장 크다. 또 거의 대부분의 C 컴파일러는 여기서 큰 차이 없는 C99를 따르기 때문이다. 사실상 표준인 C89/90은 ANSI가 직접 제정한 표준이라서 관용적으로 'ANSI C'라고도 부른다. 이 페이지에서도 ANSI C는 C89/90를 의미한다. 하지만 공식적으로 2019년 시점에서 ANSI C와 ISO C는 최신 표준인 C18을 가리키므로. 혼동을 주기 쉬운 표현이다. 왜냐하면 ANSI가 C89/90이후 C 표준 제정에서 손을 떼고 ISO를 받아들였고, ISO에서는 C99, C11, C18까지 계속 업데이트를 했기 때문에. 

C95(1995년)

 1995년에 기존 C90 표준의 일부 세부 사항이 수정되고 국제 문자 집합을 추가 지원하기 위해 ISO/IEC 9899/AMD1:1995라는 공식 명칭으로 C언어 표준 첫 수정안이 발표되었다. 

C99(1999년)

 1999년에 ISO/IEC 9899:1999라는 공식 명칭으로 표준안이 발표되었고 이후 세 차례 개정되었다.

인라인 함수, 가변 길이 배열 및 가변 배열 원소, [IEEE](https://namu.wiki/w/IEEE) 754 부동 소수점 지원 강화, 가변 매크로 인수 등의 새로운 기능들이 추가 지원되었으며 이는 여러 C 컴파일러에서 이미 비표준 확장으로 구현해 놓았던 내용이다.

C90과 대부분 상호 호환이 가능하지만 형식 지정자가 없는 선언을 허용하는 않는 등의 엄격함이 더해졌는데, 대부분의 프로그래머들이 명시적으로 선언하는 습관을 기르도록 교육받았기 때문에 큰 혼란은 없었다. 

C11 (2011년), C18 (2018년)

 2007년부터 비공식으로 "C1X"라 불렸던 C언어 표준의 개정판이 논의되었다가 2011년 4월에 제출된 후 12월 8일에 최종 승인되었다.

제네릭 매크로, 익명 구조, 향상된 유니코드 지원, 원자적 조작, 멀티스레드, 경계 검사 기능 등 문법 및 라이브러리에 새로운 기능들이 대거 추가되었다.

2018년 6월에는 최신 표준인 C18이 최종 승인되었다. C18에는 새로운 기능은 없고, 이전 C11 표준의 결함에 대한 기술적인 수정 및 설명만 추가되었다. 단, 컴파일러 옵션은 여전히 `-std=c11`이 최신이다.

C11, C18은 2019년 현재까지는 실무에서 아직 잘 안 쓰인다. 가변길이 배열, 가변인자 매크로 등 오늘날 유용하게 쓰이는 대부분의 문법은 C99에서 추가되어 C11, C18의 필요성을 느끼는 곳이 많지 않기 때문이다. 

#### C기반 언어

C++ : C의 모든 특성을 포함하였다. C에는 없는 클래스 등과 같은 특성을 가지는 객체지행 프로그래밍이라는 차이점이 있다.

Java : C++ 기반의 언어이기 때문에 C의 많은 특성을 가지고 있다.

C# : C++과 Java로 부터 파생된  비교적 최신 언어이다.

#### C의 장단점

Low-level Language : C는 시스템 프로그래밍에 적합합니다. 다른 프로그래밍 언어와 다르게 머신 레벨에 접근이 가능합니다.(바이트, 주소)  또한, 컴퓨터의 인스트럭션과 유사한 연산을 제공하기 때문에 프로그램의 속도도 빠릅니다.

Small Language : C는 제한된 특성을 제공합니다. 그렇기 C자체적으로는 적은 기능을 제공하고, 라이브러리를 이용한 다양한 펑션을 사용 가능하게 하여 라이브러리에 대한 의존성이 높습니다. 

Permissive Language : C는 허용적인 언어로, 다른 언어보다 프로그래머에게 많은 것을 허용한다. 또한, 디테일하게 에러를 체크하지 않는다.

- 장점
  - 효율성 :  효율성은 태초부터 C의 최고 강점 중 하나였다. C는 애초에 어셈블리어를 대체하기 위해 만들어졌기 때문에, C 언어로 짜인 프로그램들은 한정된 메모리가 내에서 최대한 빨라야 했다. 
  - 확장성 :  C가 지향했던 제일 중요한 목표가 확장성은 아니었으나, 사람들이 사용해보니 확장성은 C 언어의 최대 강점 중 하나였다. 어떠한 프로그램이 일반 가정집 컴퓨터이든, 슈퍼컴퓨터이든 다 실행이 되어야 했다면, 대부분은 C 언어를 이용하여 프로그래밍 되었다. C 언어가 이렇게 확장성이 좋은 이유 중 하나는 C가 초창기에 UNIX와 관련이 있었기 때문이고, 후에 ANSI와 ISO에 의해 규격화 되었기에 여러 가지의 방언들로 나뉘지 않았기 때문이다. 또 다른 이유는 C 컴파일러들은 상대적으로 규모가 작았고, 프로그래밍하기도 쉬웠기 때문이다. 또한 C 언어 자체에 확장성을 제공하는 특징들이 있었다. 물론 그렇다고 하더라도 모든 프로그래머들이 다 확장이 가능한 프로그램을 짤 줄 알았던 것은 아니었다. 
  - 유연성 :  C가 본래 시스템 프로그램을 위해 만들어졌지만, 여기를 위해서만 사용할 수 있는 것은 아니었다. C는 최근 임베디드 시스템이나 상업적인 데이터 처리 등 온갖 어플리케이션을 제작하는 데 사용된다. 또한 C는 스스로의 특징을 발현하는데 아주 적은 제한만을 둔다. 다른 언어에선 허용되지 않는 기능이 C 언어에서는 대부분 허용된다. 예를 들자면 C는 한 문자가 정수값이나 실수값에 추가될 수 있게 허용하고 있다. 이러한 유연함은 프로그래밍을 보다 쉽게 만들어준다. 물론 이러한 유연함은 몇 가지 버그를 발생시키기도 하지만. 
  - 방대한 표준 라이브러리 :  표준 라이브러리는 C의 최고 강점 중 하나다. 표준 라이브러리란  인풋/아웃풋, 문자열 처리, 메모리 할당 등 여러가지 유용한 함수들 수백가지를 갖고 있는 저장고이다. 
  - 유닉스와의 통합 :  C는 UNIX, 특히 UNIX의 변종인 Linux와 만났을 때 최고의 호흡을 보인다. 사실 몇 가지 UNIX의 기능들은 사용자가 C를 할 줄 안다는 전제하에 제공되기도 한다. 
  - 강력한 언어 :  C의 다양한 자료형들과 연산자들은 C를 강력한 언어로 만들어 주었다. C에선 힘든 작업을 몇 개의 줄 만으로도 수행할 수 있다. 
- 단점
  - 에러가 나기 쉽다
  - 언어가 어려운 펴이다
  - 수정하기 어려울 수 있다

#### C를 효과적으로 사용하는 법

- 눈에 보이지 않는 실수들을 피하는 방법을 배워라 :  이 책에 여러 군데에 이러한 방법이 적혀있다. 이러한 방법은 **[!!!]** 로 명시하도록 한다. 좀 더 이러한 눈에 보이지 않는 실수들을 알고 싶다면, Andrew Koenig의 C Traps and Pitfalls를 통해 공부할 수 있다. 최근에 나온 컴파일러들은 흔히 나오는 이러한 실수들을 파악해 알려주지만, 이러한 실수들 전부를 다루는 컴파일러는 존재하지 않는다.   

- 프로그램에 좀 더 의존하기 위해 소프트웨어 도구를 사용해라 :   C 프로그래머들은 도구들을 매우 자주 만들며, 이를 자주 이용한다. 제일 유명한 C 도구 중 하나는 `lint`인데, `lint`는 UNIX 운영체제에서 기본적으로 제공되는 프로그램이다. `lint`는 대부분의 C 컴파일러들보다 더 광범위한 에러 분석을 제공한다. 만약 `lint`나 이와 비슷한 프로그램을 사용할 수 있다면, 사용하는 것이 좋다. 다른 유용한 도구는 디버거이다. C 컴파일러는 알다싶이 대부분의 버그를 잡아낼 수 없어 실행에 에러가 발생하거나 잘못된 출력을 하게 된다. 결국 좋은 디버거를 사용하는 것은 C 언어로 프로그래밍하는 사람에게 있어 필수라고 할 수 있다. 

- 이미 존재하는 코드 라이브러리들을 활용하여 코드를 안정화 하라 :  C를 사용함에 있어 이득 중 하나는 하도 많은 사람들이 사용하다보니 그들이 미리 짜놓은 좋은 코드들이 존재한다는 것이고, 이를 활용할 수 있다는 것이다. 이러한 C 코드들은 보통 라이브러리라고 함수들의 집합에 저장되어있는데, 이러한 좋은 라이브러리를 갖고 있는 것은 에러를 줄이는 데에 도움이 될 뿐만 아니라 시간을 절약해 준다. 보통 자주 사용되는 라이브러리들은 많은 사람들이 통상적으로 자주 사용하는 것들인데, 대표적으로 UI 개발, 그래픽, 커뮤니케이션, 데이터베이스 관리와 네트워크 등이 있다. 이러한 라이브러리들은 주로 공용 저작물이거나, 오픈 소스이거나, 상용이다. 

- 실용적인 코딩 버릇을 들여라 :  코딩을 할 때의 버릇, 혹은 스타일은 언어 자체에서 강제하는 버릇이 아닌, 스스로 습득하게 되는 것이다. 버릇을 잘 들이면 프로그램이 좀 더 탄탄하고 읽기 쉬우며 유지보수하기 손쉽다. 다른 언어에서도 코딩을 할 때 일정 스타일을 따르는 것은 중요하겠지만 C에서는 특히나 더 중요하다. 위에서도 말했듯, C 언어가 갖는 유연성은 가독성을 떨어뜨린다고 했다. 이 책에서 제시하는 코드들은 단 하나의 스타일을 따를 것이다. 물론 실무에서 사용되는 다른 스타일들이 존재한다. 시간이 된다면 이러한 다른 스타일들을 논해보도록 한다. 어떤 스타일을 배우느냐는 중요하지 않지만, 몇 가지를 배우고 버릇을 들이는 것은 중요하다. 

- 코드는 간결하게 하라 :  C에는 여러가지 트릭들이 있다. 보통 프로그래밍을 할 때엔 여러 가지 방법이 있는데, 사람들은 주로 가장 간결한 해답을 고르는 경향이 있다. 그렇다고 너무 나가서 허세 부려서는 안된다. 어쩔 땐 가장 짧은 코드가 가장 이해하기 어려운 코드이다. 이 책에서는 최대한 간결하면서도 가독성 있는 방식으로 코딩을 공부할 것이다. 

- 표준을 지켜라 :  대부분의 C 컴파일러는 C89나 C99에 속하지 않는 새로운 C 언어의 기능이나 라이브러리를 지원할 것이다. 허나, 확장성을 위해선 최대한 이러한 **새로운 기능은 정말로 필요하지 않는 이상 지양하는 것이 좋다.** 

#### Q&A

**Q: Q&A 섹션에선 무엇을 하나요?**

A: 질문해줘서 감사합니다. 각 단원의 마지막에 나올 Q&A는 다양한 기능이 있습니다.

우선 제일 중요한 기능은 C를 배우는 학생들이 가장 자주하는 질문들에 대해 논하는 것입니다. 독자들 또한 제 C 언어 수업을 듣는 학생처럼 이 Q&A에 참가할 수 있습니다.

다른 기능은 Q&A를 통해 단원에서 다룬 내용에서 좀 더 나아간 부분을 다룰 수 있다는 것입니다. 이 책을 읽는 독자들은 각자 다른 배경지식을 갖고 있을 것입니다. 누구는 프로그래밍을 할 줄 아는 사람일 수도 있을 것이고, 누구는 처음으로 프로그래밍을 배우는 사람일 수도 있을 것입니다. 프로그래밍 경험이 있는 독자들은 간단한 설명과 몇 가지 예제로 만족하지만, 처음 배우는 사람은 그것보단 더 많은 내용을 필요로 할 것입니다. 만약 본인이 단원을 읽고 나서 설명이 모호하다 싶은 부분이 있으면 Q&A에서 좀 더 구체적인 설명을 확인할 수 있을 것입니다.

가끔엔 Q&A에서 C 컴파일러들 사이의 흔한 차이점을 다루기도 할 것입니다. 예를 들자면, 특정 컴파일러에서 제공하는 표준은 아니지만 자주 사용하는 기능들에 대해서 논할 것입니다.

**Q;** `lint`**의 역할이 뭔가요?**

A: `lint`는 C 프로그램이 발생할 가능성이 높은 에러들이 있는지 확인합니다. 이러한 에러들은 주로 이상한 자료형들의 집합, 사용되지 않은 변수들, 접근 불가능한 코드, 그리고 확장이 되지 않는, 포팅이 되지 않는 코드를 의미합니다. `lint`는 진단서처럼 프로그래머들이 확인해야할 리스트를 뽑아냅니다. `lint`의 장점은 컴파일러가 찾아내지 못하는 에러들을 찾아 낼 수 있다는 것입니다. 고로 반드시 `lint`를 사용하도록 합시다. 물론 `lint`는 실제 에러의 일부분인 수백가지의 에러에 대한 리스트를 받을 수 있습니다.

**Q:** `lint`**의 이름의 유래는 뭔가요?**

A: 대부분의 UNIX의 이름은 두문자어인데요, `lint`는 이와는 달리 프로그램에서 에러를 찾아내는 방식에서 이름을 따왔다고 합니다.

**Q:** `lint`**를 어떻게 다운 받을 수 있죠?**

A: `lint`는 UNIX 표준 도구입니다. 만약 UNIX 운영체제가 아니라면 `lint`가 없겠군요. 물론 서드 파티들을 위한 `lint`가 존재합니다. `lint`의 업그레이드 버전인 `splint`(Secure Programming Lint) 또한 존재하는데, 이는 대부분의 리눅스 운영체제에 제공될 것이고, www.splint.org에서 다운로드 받으실 수 있습니다.

**Q:** `lint`**를 사용하지 않고, 컴파일러로 하여금 좀 더 철저하게 일을 하게 강제할 순 없나요?**

A: 그런 방법이 존재합니다. 대부분의 컴파일러들은 프로그램을 좀 더 철저하게 확인하는 기능이 있습니다. 코드가 문법이 알맞는가를 확인하는 것에서 더 나아가서 대부분의 컴파일러들은 경고문까지도 출력하여 문제가 발생할 수 있는 지점을 가르쳐주죠. 일부 컴파일러는 단순히 한 가지 레벨의 경고만이 있는 것이 아닙니다. 좀 더 높은 레벨을 선택하면 컴파일러는 좀 더 신중하게 코드를 분석하죠. 만약 본인이 사용하는 컴파일러가 이러한 경고 레벨을 사용한다면, 제일 높은 레벨을 선택하여 사용하는 것이 좋습니다. GCC 컴파일러라고 리눅스에서 기본으로 제공하는 컴파일러에서 에러를 확인하는 옵션은 2단원의 Q&A에서 다루겠습니다.

**Q: 저는 제 프로그램이 최대한 안정적으로 만들고 싶습니다.** `lint`**나 디버거 말고 또 추가적으로 할 수 있는 도구가 없을까요?**

A: 있습니다. 대표적으로 "바운즈 체커bounds-checker"와 "릭 파인더leak-finder"가 있군요. C는 굳이 배열 서브스크립트array subscript를 확인하라고 하지 않는데, 바운즈 체커는 이를 확인해줍니다. 릭 파인더는 메모리 누수를 찾아줍니다. 메모리 누수란 동적으로 할당되지만, 절대로 할당이 해제되지 않는 메모리의 한 블록입니다.

### 02.C Fudamentals

#### 2.1 간단한 프로그래밍

**아래의 문장을 출력하는 프로그램**

> To C, or not to C: that is the question.

이 프로그램의 이름을 `pun.c` 라고 하고, 이 프로그램은 실행될 때 위와 같은 메세지를 전송할 것이다.

```C
//[pun.c]
#include <stdio.h>

int main(void)
{ 
    printf("To C, or not to C: that is the Question.\n"); 
    return 0;
}
```

 `#include`은 C의 표준 입출력 라이브러리에 대한 정보를 첨가include하기 위해 필요한 줄이다. 프로그램에서 사실상 실행되는 코드는 `main`에 존재하고, 말 그대로 대표main 프로그램을 의미한다. `main` 안에 유일한 명령어는 원하는 자료를 출력해주는 `printf`라는 함수이다. `printf`는 표준 입출력 라이브러리에 내장된 함수로, 데이터를 깔끔하게 출력해준다. 어록 뒤에 있는 `\n`는 다음 줄로 넘긴다는 의미이다. 즉, `\n` 다음에 뭔가 더 덧붙인다면, 어록 밑에 덧붙인 데이터가 출력될 것이다. 다음 줄인 ` return 0;`은 프로그램이 종료될 때 운영체제에 0이라는 값을 넘긴다, 혹은 리턴return한다는 것을 의미한다. 

**컴파일과 링크**

 생각보다 방금 짠 `pun.c` 프로그램은 매우 짧고 간결하지만, 이걸 실제로 실행하는건 생각보다 가벼운 일이 아니다. 우선, `pun.c`의 이름을 갖고 있고, 위의 프로그램의 코드 내용을 갖고 있는 파일을 제작해야 된다. 이 작업은 아무 텍스트 에디터로 할 수 있다. 사실 파일의 이름은 상관이 없지만, 대부분의 컴파일러들은 뒤에 `.c` 확장자명이 있어야 컴파일이 가능하다. 

이제 다음으로 할 일은 이제 이 프로그램을 컴퓨터가 실행할 수 있는 형태로 만들어야된다. C 언어의 경우 보통 다음과 같은 세 가지 과정이 필요하다.

- **전처리Preprocessing.**  : 프로그램은 우선 `전처리기preprocessor`에 보내지는데, 전처리기는 #으로 시작하는 `지시어directive`로 알려진 줄들의 지시를 먼저 따른다. 전처리기는 마치 에디터와 같다고 볼 수 있다. 프로그램에 무언가를 추가하고, 수정을 할 수 있기 때문이다.
- **컴파일Compiling.** : 수정된 프로그램은 이제 `컴파일러compiler`로 보내지는데, 여기서 코드는 기계어 명령문(`목적코드object code`)으로 번역이 된다. 번역을 했지만, 그래도 아직은 프로그램을 실행할 순 없다.
- **링킹Linking. ** : 마지막 단계에선 `링커linke`r가 컴파일에 의해 생성된 목적코드를 프로그램을 완벽하게 실행하기 위해 필요한 추가적인 코드와 합친다. 이 추가적인 코드는 보통 프로그램에 사용되는 라이브러리 내부의 명렁문을 의미한다. 위의 코드를 예시로 들면 `printf`가 되겠다.

 다행히도 이 과정은 전부 자동적으로 처리가 되기 때문에 부담 가질 필요는 없다. 사실 전처리 과정도 컴파일러에 보통 추가되어있어서 사실 전처리가 진행되고 있다는 사실조차 모를 수도 있다.   컴파일과 링크를 하기 위한 명령들은 컴파일러에 따라, 그리고 운영체제에 따라 다르다. UNIX에선 C 컴파일러가 보통 `cc`라고 불리는데, 그렇기 때문에 `pun.c`를 컴파일하기 위해선 터미널이나 커맨드라인창에 다음과 같은 명령문을 입력해야 한다. **`% cc pun.c`**

UNIX에서 %란 프롬프트를 의미한다. 이건 사용자가 입력해야하는 건 아니다. `cc`를 이용하면 링킹은 자동적으로 이뤄진다. 굳이 링크를 위한 또다른 명령문이 필요하지 않다.

 컴파일과 링킹이 끝나면, `cc`는 실행가능한 프로그램을 보통 기본 설정에 따라 `a.out`라는 이름으로 만들어낸다. `cc`에는 다양한 옵션들이 있는데, 그 중에 `-o`라는 옵션은 실행가능한 프로그램을 포함하는 파일의 이름을 바꿀 수 있게 해준다. 예를 들어 위에 `pun.c` 프로그램을 `pun`라는 이름으로 생성하고 싶다면 다음과 같은 명령문을 입력하면 된다.  **`% cc -o pun pun.c`** 

> **GCC 컴파일러**
>
> GCC 컴파일러는 가장 유명한 C 컴파일러 중 하나이다. 이 컴파일러는 리눅스에 기본 제공되는 컴파일러이지만, 다른 환경에서도 사용할 수 있다. 이 컴파일러를 사용하는 것은 마치 UNIX의 `cc` 컴파일러를 사용하는 것과 비슷하다. 아까 `pun.c` 프로그램을 컴파일 했을 때와 같은 방식으로 컴파일하기 위해선 다음과 같이 해주면 된다.
>
> **`% gcc -o pun pun.c`**
>
> **[Q&A]** 이 단원의 Q&A에서 GCC에 대해 좀 더 구체적으로 다루고 있다. 

**통합개발환경**

지금까진 운영체제가 기본적으로 제공하는 특별한 창에 명령문을 입력하여 커맨드 라인 컴파일러를 사용한다는 가정을 했다. 이 방법 말고 사용할 수 있는 방법은 **통합개발환경(Integrated Development Environment. IDE)**을 사용하는 것이다. IDE란 개발 환경에서 벗어나지 않은 상태에서 수정하고, 컴파일하고, 링크하고 실행하는 것 뿐만 아니라 심지어는 디버깅까지 해주는 소프트웨어 패키지이다. IDE의 구성 요소들은 다 같이 작동하도록 설계되어있다. 예를 들어 컴파일러가 어떠한 프로그램에서 에러를 찾아낸다면, 데이터로 하여금 에러가 발생한 특정 줄에 표시를 줄 수 있을 것이다. IDE에는 여러가지 종류가 있기에 굳이 이 책에서 언급하지는 않도록 한다. 물론 본인이 사용하고 있는 플랫폼에 가장 알맞는 IDE가 무엇인지 확인하는 것을 추천한다.

#### 2.2 프로그램의 일반적인 형태

 `pun.c`을 통해 어떻게 하면 이 프로그램을 일반화할 수 있는지 알아보도록하자. 간단한 C 프로그램은 다음과 같은 구조를 가진다. 

```C
directives

int main(void)
{
  statements
}
```

이 템플릿을 포함해 이 책에서 보게 될 여러 템플릿들을 보게 된다면, 이탤릭체로 된 글자들은 프로그래머가 직접 작성해야할 코드들을 의미하고, 나머지 글자들은 글자 하나 하나 똑같이 유지된다는 것을 알 수 있다.

`main` 함수의 중괄호들이 어떻게 시작하고 끝나는 지에 주목해보라. C가 중괄호 {와 }를 사용하는 방법은 다른 언어들이 `begin`과 `end`를 사용하는 방식과 같다. 즉, C는 축약과 특수 기호들을 자주 사용하고 있다는 것을 알 수 있다. **[Q&A]** 이는 C 언어가 간결하거나 덜 암호같다고 평가 받는 이유 중 하나다.

가장 간단한 C 프로그램조차 위의 템플릿에 보이는 세 가지 부분에 의존한다. 지시자directives, 함수function, 그리고 구문statement이다. 지시자란 어떤 프로그램을 컴파일하기 전에 그 프로그램을 수정하는 명령문을 수정하는 것이다. 함수란 `main` 함수처럼 이름이 있는 블록 형태로 이루어진 실행 가능한 코드다. 구문이란 프로그램이 실행될 때 실행되어야할 명령문들이다. 이제 이 세 가지 개념에 대해서 구체적으로 알아보도록 하자.

**지시자**

C 프로그램이 컴파일 되기전에, 전처리기에 의해 처음 수정된다. 전처리기를 위한 명령문들을 지시자(Directive)라고 한다. 지시자는 `#`으로 시작해야 한고 뒤에 `;`은 사용하지 않는다. 많이 쓰는 지시자 중 `#include<라이브러리.h>`지시자가 있는데 라이브러리의 정보를 컴파일 하기 이전에 프로그램에 포함하도록 해준다.  `#include<stdio.h>`에서 `stido.h` 와 같이 `.h`로 되어있는 파일은 헤더리거 불린다. `stido.h` 는 표준 입출력 라이프러리이다. C는 다른언어들과 달리 입출력에 대한 기본 내장 함수가 없기 때문에 라이브러리를 include 해줘야 한다.

**함수**

수학과는 다르게 C에서 사용하는 함수의 개념은 좀 더 광범위하다. C에서 함수는 이름이 주어진 여러 개의 구문을 포함한 집합을 의미한다. 함수는 값을 연산해낼수도 있고, 연산하지 않을 수도 있다. 만약 어떠한 연산의 결과를 반환하고 싶은 경우 `return`이라는 구문을 통해 그 함수가 어떤 값을 "반환return"하는지 명시해준다. 예를 들자면 입력값에 1을 더하는 함수가 존재한다면 다음과 같은 구문을 짜야할 것이다. 

```c
return x + 1;
```

만약 함수가 두 개의 입력값을 받아 각각의 제곱의 차를 구하는 함수라면 다음과 같이 구문을 짤 것이다.

```c
return y * y - z * z;
```

여러 함수를 사용자가 작성하여 사용할 수 있지만, 그 중 `main`함수는 필수 함수이다. `main`함수는 프로그림이 시작할 때 자동으로 실행되는 함수 이기 때에 `main`함수 없이는 프로그램이 동작하지 않는다. `main`함수의 이름은 반드시 main이어야 한다. 

그렇다면 `main`함수는 반환값을 가지는 함수인가? 답은 그렇다. main함수는 OS에 상태코드를 리턴해준다. 

`pun.c` 프로그램을 다시 살펴보면,

```c
#include<stdio.h>
int main(void)
{
	printf("To C, or not to C: that is the question.\n");
	return 0;
}
```

`main`앞에  `int`가 나오는데, 이것은 main 함수가 int형(정수) 값을 반환하는 것을 의미한다. 괄호 안에 `void`는 main 함수가 입력갑을 요구하지 않을 때 사용한다.(void 생략 가능)

`return 0;`는 두 가지 효과를 갖는데, 첫번째로는 `main` 함수를 종료시키고(프로그램 또한 중단) 두번째로는 0이라는 값을 반환한다. `main` 함수의 반환값에 대해선 나중 단원에서 다루도록 하고, **[Q&A]** 지금은 `main` 함수를 사용한다면 언제나 0이라는 값을 반환하도록 프로그래밍하도록 하자. 이는 **일반적인 프로그램 종료를 의미**한다.

 `return` 구문이 `main` 함수 마지막에 없더라도 프로그램은 종료될 것이다. **[Q&A]** 하지만 대부분의 컴파일러들은 `main` 함수는 정수값을 반환 받았어야 하는데 그러지 못했기 때문에 에러 메세지를 송출할 것이다. 

**구문**

`구문statement`이란 프로그램이 실행될 때 실행되어야 하는 명령들이다. `pun.c` 프로그램에선 두 가지 구문만을 사용한 것을 알 수 있다. 하나는 `return` 구문이고 다른 하나는 함수 `호출function call`이다. 함수를 호출call한다는 것은, 어떤 함수가 그 임무를 수행하게 만드는 것을 의미한다. `pun.c` 프로그램을 통해서 구체적으로 알아보도록 하자. 이 프로그램에선 `printf 함수`를 호출해내서 화면에 문자열을 출력시킨다.

```c
printf("To C, or not to C: that is the question.\n");
```

C에선 각 구문은 반드시 `세미콜론(;)`으로 끝나야 한다. 물론 복합문compound statement처럼 세미콜론이 필요 없는 유일한 예외가 있긴 하지만, 이건 나중에 다룰 내용이다. 세미콜론은 컴파일러로 하여금 구문이 어디서 끝나는지를 알려주는 역할을 한다. 줄 별로 구분하지 않는 이유는 구문 자체는 여러 줄이 될 수 있기 때문에 어디서 끝나는지 명확하지 않을 수 있기 때문이다. 지시자는 이와 반대로 한 줄짜리이기 때문에 굳이 세미콜론을 사용하지 않아도 되기 때문에 세미콜론을 사용하지 않는다

**문자열 출력하기**

`printf` 함수는 강력한 함수이다. 아직까지 이 책에 `printf`를 통해 `문자열 리터럴string literal`만 출력했다. 문자열 리터럴이란 여러 문자의 연속체를 의미한다. 여기서 이 연속체는 큰따옴표 안에 존재하고, `printf` 함수는 이 따옴표 안에 있는 정보만 출력한다.

`printf` 함수는 다음 줄로 넘어가라고 지시하지 않는 한 다음 줄로 넘어가지 않는다. 그렇기 때문에 다음 줄로 넘어가라고 지시할 땐 `\n`를 추가해줘야만 한다. 이 때 `\n`란 `줄 내림 문자`, 혹은 `개행 문자new-line character`이라고 부른다. 개행 문자를 추가해 줌으로써 현재 출력하던 줄을 끝내고 다음 줄로 넘어갈 수 있게 만들어줄 수 있는 것이다. 이 개행 문자가 어떻게 작동하는지는 다음 예제를 통해 직접 확인해보도록 한다.

```c
printf("To C, or not to C: that is the question.\n");
```

이 구문을 두 개로 나눠보도록 하자.

```c
printf("To C, or not to C: ");
printf("that is the question.\n");
```

첫번째 `printf` 함수는 `To C, or not to C:`를 출력을 할 것이고, 두번째 `printf` 함수는 `that is the question.`을 출력한 다음 다음줄로 넘어갈 것이다. 사실상 첫번째 예제나 두번째 예제나 순수하게 결과만 살펴본다면 같을 것이다.

개행 문자는 한 문자열 리터럴에서 여러번 등장할 수 있다. 만약 다음과 같은 메세지를 출력하고 싶다고 하자.

>  Brevity **is** the soul of wit. 
>
>  --Shakespeare 

이것을 출력하려면 다음과 같이 코드를 작성할 수 있다.

```c
printf(Brevity is the soul of wit.\n --Shakespeare);
```

#### 2.3 주석(comment)

프로그램에 대한 설명을 하기 위해 주석을 사용한다. `/*`와 `*/` 사이에 있는 문자는 주석 처리되며, 컴파일러에서 컴파일 시 무시가 된다.

으로 나타내준다. 즉 다음과 같이 작성해주면 된다.

```c
/* 이것은 주석입니다 */
/* This is a comment */
```

거의 대부분의 프로그램들은 주석으로 도배되어있을 것이다. 비슷한 느낌으로 `pun.c`을 주석으로 도배해보도록 하자.

```c
/* 제목: pun.c */
/* 목적: bad fun 출력 */
/* 작성자: K. N. King */
/* Name: pun.c */
/* Purpose: Prints a bad pun */
/* Author: K. N. King */
#include<stdio.h>
int main(void)
{
printf("To C, or not to C: that is the question.\n");
return 0;
}
```

주석이 한 줄 이상이 될 수도 있다. 그럴 땐 단순히 `/*`와 `*/`를 길게 사용하면 된다. 컴파일러는 `/*`가 먼저 나온다면, `*/`이 다음으로 나오지 않는 이상 `/*` 이후에 적혀있는 모든 문자들을 무시한다.

```c
/* Name: pun.c
```

하지만 사실 이렇게 주석을 작성하는 것을 추천하지는 않는다. 이렇게 작성하게 되면 어디부터 어디까지가 주석인지 확실하지 않기 때문이다. 그렇기 때문에 다음과 같이 작성하는 것을 추천한다.

```c
/* Name: pun.c
Purpose: Prints a bad pun
Author: K. N. King
*/
```

이것보다 더 좋은 방법은, 주석에 일종의 박스를 두르는 방법이 있다.

```c
/********************************************************************************
* Name: pun.c *
* Purpose: Prints a bad pun *
* Author: K. N. King *
********************************************************************************/
```

프로그래머들은 보통 좀 더 간단한 방식의 박스를 사용한다.

```c
/*
* Name: pun.c
* Purpose: Prints a bad pun
* Author: K. N. King
*/
```

짧은 주석은 프로그램의 코드가 존재하는 줄에 같이 존재할 수 있다.

```c
int main(void) /* 메인 프로그램의 시작 */
int main(void) /* Beginning of main program */
```

이러한 주석을 보통 "날개 주석winged comment"라고 부른다. **[!!!]** 주석을 깜빡하고 제대로 닫아주지 않는 경우 컴파일러는 주석이 열린 부분부터는 무시하므로 프로그램의 일부분을 무시할 수 있다. 다음 예제를 보자.

```c
printf("My "); /* 주석 깜빡하고 닫지 않기...
printf("cat ");
printf("has "); /* 여기서 주석이 끝날 것 */
printf("fleas");
printf("My "); /* forgot to close this comment...
printf("cat ");
printf("has "); /* so it ends here */
printf("fleas");
```

첫번째 주석을 제대로 닫아주지 않았기 때문에 컴파일러는 중간에 있는 두 구문을 무시하고, 출력 결과는 다음과 같을 것이다. 

> My fleas

**[C99]** C99를 사용하는 경우, `//`을 앞에 적어주어 주석 처리를 해줄 수 있다.

```cassandra
// 이것은 주석입니다
// This is a comment
```

이런 방식의 주석은 보통 한 줄이 끝나게 되면 덩달아 끝나게 된다. 만약 여러줄에 걸쳐서 주석 처리를 하고 싶다면, 위의 방식을 사용하거나, 여러 줄에 걸쳐 계속해서 `//`를 사용하면 된다.

```c
// Name: pun.c
// Purpose: Prints a bad pun
// Author: K. N. King
```

이 방식으로 주석 처리를 할 때엔 여러 가지 장점들이 있다. 우선 이 방식으로 주석 처리를 하면 한 줄 자체가 주석 처리가 되기 때문에 첫번째 방식처럼 닫지 않는다고 해서 프로그램의 일부가 주석처리 되지 않는다. 또다른 장점은 위의 예시에서 보았듯 여러줄로 이뤄진 주석이라면, 각 줄 마다 `//`를 써주기 때문에 좀 더 보기 좋아졌다는 것이다.

#### 2.4변수와 할당

대부분의 프로그램들은 출련전에 몇 가지의 연산을 수행하기 때문에 일시적으로 연산을 할 때 필요한 데이터를을 저장을 해야한다. 이때 저장 위치를 `변수variable`라고 부른다. 

**Type**

모든 변수들은 반드리 `유형Type`을 가진다. 즉 어떠한 데이터를 저장할 것인지를 정해주어야 한다. C언어에는 여러가지 변수 유형이 있지만, `int`와 `float`을 먼저 살펴보곘다. 적절한 변수를 선택하는 것은 변수가 어떻게 저장되고 그 변수가 어떤 연산을 수행할 수 있는지 영향을 미치기 때문에 매우 중요하다. 숫자 변수의 유형은 변수가 저장할 수 있는 최소값과 최대값을 정의하고, 부동 소수점 표시가 가능한지 여부 또한 정의한다.

정수 integer의 줄임말인 변수 `int`형은 정수(0,1,302.-332)를 저장할 수 있다. 하지만, 값의 범위는 정해져 있다. `int`의 최대값은 보통 `2,147,483,647`이다.

 **[Q&A]** `부동 소수점floating-point`의 줄임말인 변수 `float`형은 `int` 변수보다 더 큰 숫자를 저장할 수 있을 뿐더러 `379.125`와 같이 소수 형태로 저장할 수 있다. 허나 `float` 변수는 몇 가지 단점이 있다. **`float`을 이용한 연산은 `int`를 이용한 연산보다 더욱 느릴 수 있기 때문이고, 특히 `float` 변수의 값은 정확한 값이 아니라 근사값**이기 때문이다. 예를 들어 `float` 변수에 `0.1`을 저장한다면, 나중에 이 변수가 `0.1`이 아닌 `0.099999999999987`을 값으로 갖고 있을 것이다. 이는 반올림할 때 발생하는 오류이기 때문이다. 

**선언(Declare)**

만약 `height`과 `profit`라는 변수를 선언해야한다면 다음과 같이 선언해야한다.

```c
int height;
float profit;
```

첫번째 선언에선 `height`을 `int`형 변수로 선언했으므로, `height`은 정수값을 저장할 수 있을 것이다. 두번째 선언에선 `profit`이 `float`형 변수로 선언해주었다.

만약 여러 변수들이 같은 유형을 갖고 있다면, 동시에 선언해줄 수 있다.

```c
int height, lenght, width, volume;
float profit, loss;
```

각 선언이 세미콜론(`;`)으로 끝맺음 된다는 것을 알 수 있다.

이 책에서 처음 작성했던 예제 프로그램에선 `main` 함수에 아무런 선언을 해주지 않았다. 만약 `main`이 선언문을 포함한다면, 반드시 구문 전에 선언해주어야한다.**(C99부터는 아님)**

```c
int main(void)
{
*declarations*
*statements*
}
```

9 단원에서 좀 더 다뤄보도록 하겠지만, 대부분의 함수들이나 블록(내부에 선언문이 박혀있는 구문)들은 위와 같은 구조를 따른다. **좀 더 코드를 깔끔하게 짜기 위해선 선언문과 구문 사이에 한 칸을 뛰어 놓는 것이 좋다.**

 **[C99]** C99에선 선언이 굳이 구문 직전에 오지 않아도 된다. 예를 들어 `main` 함수 내부에서 선언 먼저하고, 구문하고, 또 다른 선언하고 이런식으로 작성할 수 있다는 것이다. 좀 구식 컴파일러와의 호환성을 위해선 위의 방식의 규칙을 지키는 것이 좋긴 하다. 허나 보통 C++이나 Java에선 프로그램을 작성할 때 변수가 필요한 순간 직전에 변수를 선언해주는 것이 보편화 되어있다. 그렇기 때문에 C99으로 프로그래밍을 공부하고 있다면, 이와 같이 버릇을 들이는 것이 좋다. 

**할당 (assignment)**

 변수는 할당assignment을 함으로써 값을 가질 수 있다. 다음 구문을 보도록 하자.

```c
height = 8;
length = 12;
width = 10;
```

다음 구문은 각 변수 `height`, `length`와 `width`에 값 8, 12, 10을 각각 할당하는데, 여기서 할당하는 숫자들을 `상수constant`라고 부른다. 변수에 값을 할당하거나, 변수를 사용하기전엔 **우선 먼저 선언**이 되어야한다. 고로 다음과 같이 작성해주도록 한다.

```c
int height;
height = 8;
```

허나 다음과 같이 작성하면 에러가 날 것이다.

```c
height = 8; /*** WRONG ***/
int height;
```

`float`형 변수에 할당된 변수는 보통 소수점을 포함한다. 만약 `profit`이 `float`형 변수라면, 다음과 같이 할당할 수 있다.

```c
profit = 2150.48;
```

**[Q&A]** 보통 `float`형 변수에 할당된 소수점을 갖는 상수에는 끝에 `f`(`float`의 앞 글자)를 붙인다.

```c
profit = 2150.48f;
```

만약 `f`를 추가해주지 않는다면 컴파일할 때 컴파일러가 에러를 낼 수도 있다.

`int`형 변수는 보통 `int`형 값을 할당받고, `float`형 변수는 보통 `float`형 값을 할당받는다. `int`형 변수에 `float`형 값을 할당하고, `float`형 변수에 `int`형 값을 할당하는 식의 유형을 섞는 행위는 가능은 하지만, 매우 불안정하다. 이와 관련된 내용은 4.2 단원에서 좀 더 다룰 것이다.

변수에 값이 할당된 이상 다른 새로운 변수의 값을 만드는데 사용될 수 있다.

```c
height = 8;
length = 12;
width = 10;
volume = height * lenght * width; /* volume is now 960 */
```

 C에서 `*`는 곱셈연산자를 의미하기에, 마지막 구문은 `height`, `length`, `width`에 각각 저장된 값을 모두 곱하여 `volume` 변수에 저장한다. 일반적으로 할당할 때의 우변은 상수, 변수와 연산자로 이루어진  `표현식expression`이 될 수 있다. 

**변수의 값 출력하기**

변수가 현재 갖고 있는 값은 `printf`를 이용해서 출력할 수 있다. 다음과 같은 글귀를 출력한다고 해보자.

> Height: h

여기서 `h`는 `height` 변수가 현재 갖는 값이라고 하자. 그렇다면 다음과 같이 `printf`를 이용하면 된다.

```c
printf("Height: %d\n", height);
```

`%d`의 역할은 출력될 때 `height`의 값을 대신하는 것이다. `\n`이 `%d` 바로 다음에 적혀있으니, `printf`는 `height`의 값을 출력한 다음 다음 줄로 넘어갈 것이다.

`%d`은 오로지 `int`형 변수만 대신할 수 있다. `float`형 변수는 `%f`를 이용해서 대신할 수 있다. `%f`는 **기본적으로 소수점 이하 여섯자리까지 출력**한다. `%f`로 하여금 소수점 이하 `p` 자리까지 출력하게 하려면 **`%`와 `f` 사이에 `.p`**를 적어주면 된다. 예를 들어 다음 줄을 출력해보도록 하자.

> Profit: $2150.48

이를 출력하기 위해서 `printf`를 다음과 같이 호출해주도록 한다.

```c
print("Profit: $%.2f\n", profit);
```

`printf`가 출력할 수 있는 변수의 개수엔 제한이 없다. 만약 `height`과 `lenght` 변수를 동시에 출력하고 싶다면 다음과 같이 `printf`를 호출해주면 된다.

```c
print(Height: %d Length: %d\n", height, length);
```

**초기화(Initialization)**

어떤 변수들은 프로그램이 실행될 때 자동으로 0을 값으로 갖지만, 대부분은 아니다. 기본 설정값이 없는 변수는 값을 할당하지 않는 이상 초기화initialization되지 않았다고 한다. **[!!!]**

초기화되지 않은 변수의 값을 예를 들어 printf를 이용해 변수를 출력하려고 하거나 표현식에서 사용하는 식으로 접근한다면 `2568`, `-30981`와 같이 예상하지 못한 결과값이 나올 수 있다. **어떤 컴파일러들은 심한 경우에 아예 프로그램이 중단**되는 경우가 생긴다.

변수에 초기값을 부여하는 방법은 당연히 할당을 하는 것이다. 허나 좀 더 간단한 방법이 있다. **변수의 초기값을 선언할 때 할당**해주는 것이다. 다음 예시처럼 `height`의 선언과 초기값 할당을 동시에 해줄 수 있다.

```c
int height = 8;
```

C 언어 용어로 `8`이라는 값을 초기값initializer라고 부른다.

같은 방식으로 여러 변수에 각기 여러 값을 할당해줄 수 있다.

```c
int height = 8, length = 12, width = 10;
```

각 변수는 반드시 자신만의 초기값가 필요하다. 위의 세 변수가 전부 `10`을 초기값로 갖는다고 해서 전부 아래와 같이 할당하면 마지막에 있는 `width` 변수만 초기값이 할당되고 나머지 변수들은 선언만 되고 초기화되지 않는다.

```c
int height, length, width = 10;
```

**표현식 출력하기**

`printf`는 변수에 저장된 값만을 출력하는 기능만이 있는 것은 아니다. `printf`는 사실 모든 표현식을 출력할 수 있다. 이러한 특징을 이용한다면 프로그램에서 변수를 줄여 프로그램을 간단하게 만들 수 있다. 다음 예제를 확인해보자.

```c
volume = height * length * width;
printf("%d\n", volume);
```

이 예제는 사실 아래와 같이 표현할 수 있다.

```c
printf("%d\n", height * length * width);
```

이렇듯 `printf`은 표현식을 출력할 수 있다. 이러한 면은 C의 일반적인 원칙을 단적으로 드러낸다. 어떠한 특정 값이 필요하다면, 같은 값을 갖는 표현식은 그것을 대체할 수 있다.

#### 2.5 입력값 읽기

`dweight.c` 프로그램은 특정 한 가지 유형의 박스의 용적 중량만을 계산하기 때문에 실무에서 사용할 수 없다. 프로그램을 좀 더 실무에 사용가능하도록 만드려면 사용자가 박스의 세변의 길이를 입력하고 이에 따라 용적 중량을 계산하게 만들어야 할 것이다.

입력값을 받기 위해선 C 라이브러리에 있는 `printf`의 반대의 의미인 `scanf` 함수를 사용해야한다. `scanf`와 `printf`에 사용된 `f`는 **형식화formatted의 약자**이다. `scanf`와 `printf` 각각 데이터를 입력받거나 출력할 때 형식 문자열format string이 필요하다. `printf`가 데이터를 출력할 때 어떻게 출력해야하는지 알려줘야 하듯, `scanf` 또한 입력받는 데이터의 형식을 정해주어야 한다.

만약 `int`형 변수를 입력받고 싶다면 다음과 같이 `scanf` 함수를 사용해야한다.

```c
scanf("%d", &i); /* 정수를 받아 i에 저장한다. */
scanf("%d", &i); /* reads an integer; stores into i */
```

`scanf`가 정수값을 받기 위해선 문자열 `%d`가 필요하다. 여기서 받은 값은 `int`형 변수인 `i`에 저장된다. **현재로선 `&`의 기능을 설명하기엔 이르다.** 우선은 이 기호가 반드시는 아니지만 주로 `scanf`를 사용할 때 사용한다는 것만을 알고 넘어가라.

`float`형 변수를 입력받고 싶다면 `scanf` 함수를 다른 방식으로 호출해야한다.

```c
scanf("%f", &x); /* 소수를 받아 x에 저장한다. */
scanf("%f", &x); /* reads an float value; stores into i */
```

`scanf`가 정수값을 받기 위해선 문자열 `%f`가 필요하다. 즉, `x`는 `float`형 변수가 될 것이고, 여기서 받은 값은 `x`에 저장될 것이다. `x`는 소수점을 포함할 수도, 아닐 수도 있을 것이다.

#### 2.6 상수 이름 정의하기

프로그램이 상수를 포함하고 있다면, 상수에 이름을 지어주는 것이 좋다. `dweight.c` 과 `dweight2.c` 프로그램은 `166`라는 상수를 중간에 사용해주고 있는데, 이렇게 단순히 숫자로만 표현하면 읽는 사람으로 하여금 이게 무슨 의미인지 이해가 안 될 수 있다. 그렇기 때문에 C 언어의 기능 중 하나인 `매크로 정의macro definition`을 사용하여 상수에 이름을 붙여줄 수 있다.

```c
#define INCHES_PER_POUND 166
```

`#define`은 `#include`와 같은 `전처리 지시자`이기 때문에 마지막에 세미콜론(`;`)이 들어가지 않는다. 프로그램이 컴파일 될 때 전처리자는 각 매크로를 지정된 값으로 대체한다. 다음 구문을 확인해보라.

```c
weight = (volume + INCHES_PER_POUND - 1) / INCHES_PER_POUND;
```

이 구문은 아래 구문과 같다.

```c
weight = (volume + 166 - 1) / 166;
```

매크로의 값은 `표현식`이 될 수 있다.

```c
#define RECIPROCAL_OF_PI (1.0f / 3.14159f)
```

Reciprocal은 역수라는 의미이다. 만약 연산자가 표현식에 존재한다면 괄호를 통해 열고 닫아줘야한다.

매크로의 이름에 **오로지 대문자만 사용하는 것은 필수는 아니다. 대부분 C 언어 프로그래머들이 암묵적으로 지키는 전통**과도 같다. C 언어를 처음 배우는 독자들도 이 전통에 따를 것을 권장한다.

#### 2.7 식별자(identifier)

프로그램을 작성하면서 변수, 함수, 매크로 등에 이름을 정해주어야 한다. 이러한 이름들을 `식별자identifier`라고 부른다. C에선 식별자를 정의할 때 문자, 숫자나 `_`와 같은 밑줄 표시를 사용할 수 있다. 단, 이름을 숫자로 시작할 수는 없다. [C99] C99에선 식별자에 특정 유니버설 문자 이름universal character name을 포함할 수 있다.

다음은 식별자로 가능한 경우들이다.

`times10` `get_next_char` `_done`

다음은 불가능한 경우들이다.

`10times` `get-next-char`

`10times`은 이름이 문자나 밑줄 표시가 아닌 숫자로 시작하고 있고, `get-next-char`은 밑줄 표시가 아니라 뺄셈 기호를 사용하고 있다.

C는 `대・소문자`를 구별한다(case-sensitive). 식별자 내에 대문자와 소문자는 엄연히 다른 문자인 것이다. 아래에 있는 식별자들은 전부 다 다른 식별자들이다.

`job` `joB` `jOb` `jOB` `Job` `JoB` `JOb` `JOB`

이 여덟 개의 식별자들을 모두 각기 다른 용도로 사용할 수 있다. (물론 실제로 그런다면 매우 혼란스러울 것이다!) 실용적인 프로그래머들은 변수들끼리 연관이 있지 않는 이상 전부 구분이 가능하게 식별자를 작성한다.

C는 대소문자를 구분하기에 많은 프로그래머들은 매크로를 제외하고는 식별자를 오로지 소문자로만 작성하고, 가독성을 위해 밑줄 표시를 사용하기도 한다.

**C스타일** : `symbol_table` `current_page` `name_and_address`

어떤 프로그래머들은 밑줄 표시를 사용하지 않고 대문자를 이용해 식별자를 작성한다.

**Java, C++스타일 **:`symbolTable` `currentPage` `nameAndAddress`

가끔 첫번째 글자를 대문자로 적어주기도 한다. 전자가 C에선 좀 더 흔하지만, 후자가 Java와 C#, 더 나아가서는 C++의 영향에 의해 더욱 더 유명해지고 있다. 다른 방법들 또한 있겠으나, 적어도 식별자가 다시 프로그램에서 등장할 때마다 각각 같은 방식으로 대문자 처리를 해주는 것이 좋다.

**[Q&A]** C에선 식별자가 몇 글자까지 되는지에 대한 한계는 없으니 좀 더 구체적인 식별자를 사용하는 것에 대해 거부감을 느끼지 말라. 실제로 `current_page가` `cp`보단 이해하기 훨씬 좋다.

**키워드**

**[C99]** C 컴파일러에선 아래 [표 2.1]에 명시된 일부 키워드keyword들을 특별히 인식하기 때문에 이들을 **식별자로 사용할 수 없다**. C99에는 다섯가지가 더 추가되었다.( † C99에서 추가된 키워드)

| `auto`     | `enum`     | `restrict` | `unsigned`    |
| :--------- | :--------- | :--------- | :------------ |
| `break`    | `hextern`  | `return`   | `void`        |
| `case`     | `float`    | `short`    | `volatile`    |
| `char`     | `for`      | `signed`   | `while`       |
| `const`    | `goto`     | `sizeof`   | `_Bool`†      |
| `continue` | `if`       | `static`   | `_Complex`†   |
| `default`  | `inline`†  | `struct`   | `_Imaginary`† |
| `do`       | `int`      | `switch`   |               |
| `double`   | `long`     | `typedef`  |               |
| `less`     | `register` | `union`    |               |

[표 2.1] 키워드

당연히 C는 대소문자를 구분하기 때문에 키워드들은 [표 2.1]에 명시된 대로 전부 소문자로 작성해야한다. 표준 라이브러리에 있는 `printf`과 같은 함수의 이름 또한 마찬가지로 전부 다 소문자로 이뤄져있다. 전부 작성해서 컴파일러가 이러한 함수나 키워드들을 인식하지 못하는 불상사를 미리 예방하도록 하자.

> **[!!!]** 식별자엔 위에서 다룬 것 외의 또다른 제한이 있기도 하다. 몇몇 컴파일러들은 `asm`과 같은 특정 식별자들 추가적인 키워드로 인식한다. 당연히 표준 라이브러리에 포함된 식별자 또한 제한된다. 이러한 이름을 실수를 해서 사용하는 경우 컴파일을 하거나 링크를 할 때 에러가 발생할 것이다. 식별자가 밑줄 표시로 시작하는 경우도 제한된다.

#### 2.8 C 프로그램의 레이아웃

C 프로그램을 일종의 `토큰token`의 연속이라고 이해할 수 있다. 토큰이란 **의미를 구성하는 최소 단위**이다. 식별자나 키워드가 토큰이 일종이다. +와 -와 같은 연산자나 쉼표나 세미콜론과 같은 구두점이나 문자열 리터럴 등 또한 마찬가지로 토큰의 일종이다. 다음 구문을 보자.

```c
printf("Height: %d\n", height);
```

위의 구문은 총 **일곱 개의 토큰**으로 이뤄져있다.

```c
printf  (  "Height: %d\n"  ,    height  )  ;
 ①      ②        ③          ④     ⑤     ⑥   ⑦
```

①번과 ⑤번 토큰은 식별자들이고 ③번 토큰은 스트링 리터럴이며, 나머지 토큰들은 전부 구두점들이다. 토큰 사이에 줄을 띄우는 것은 보통 그렇게 중요하진 않다. 극단적인 경우 두 토큰이 합쳐져서 새로운 토큰을 만들어내지 않는 한 줄 띄움 없이 전부 붙어있을 수도 있다. 예를 들어 2.6 단원에서 작성했던 `celsius.c` 프로그램에선 `int`와 `main` 사이, `float`와 `fahrenheit` 사이 등을 제외하고는 존재하는 대부분의 스페이스를 제거할 수 있다.

```c
/* Converts a Fahrenheit temperature to Celsius */
#include<stdio.h>
#define FREEZING_PT 32.0f
#define SCALE_FACTOR (5.0f / 9.0f)
int main(void){float fahrenheit, celsius;printf(
"Enter Fahrenheit temperature: ");scanf("%f", &fahrenheit);
celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;
printf("Celsius equivalent: %.1f\n", celsius);return 0;}
```

사실 만약 이 페이지가 더 넓었더라면 `main` 함수 전체를 한 줄에 작성할 수도 있다. 물론 프로그램 전체를 한 줄에 할 수는 없다. 전처리 지시자들은 따로 한 줄에 존재해야하기 때문이다.

프로그램을 이런 식으로 압축하는 것은 매우 지양해야할 행동이다. 사실 프로그램에 빈 공간이나 줄을 띄우는 것은 프로그램의 가독성을 매우 높여준다. 다행히도 C를 작성할 때엔 스페이스, 탭과 개행등을 통해 토큰 사이에 얼마든지 넓은 공간을 만들어낼 수 있다. 이러한 규칙은 프로그램의 레이아웃에 몇 가지 중요한 영향을 미친다.

구문은 여러 줄로 나뉠 수 있다. 다음 구문의 경우 매우 길기 때문에 한 줄에 우겨넣을 수 없다.

```c
printf("Dimensional weight (pounds): %d\n", (volume + INCHES_PER_POUND - 1) / INCHES_PER_POUND);
```

토큰 사이의 스페이스는 가독성을 높혀준다. 이러한 이유로 각 연산자마다 줄을 띄워준다.

```c
volume = height * length * width;
```

쉼표 이후에도 줄을 띄워주도록 하자. 몇몇 프로그래머들은 더 나아가서 괄호나 다른 구두점 사이에도 줄을 띄우기도 한다.

들여 쓰기는 함수 등을 찾기 쉽게 해준다. **[Q&A]** 예를 들어 선언문들이나 구문들이 `main` 함수 안에 제대로 있다는 것을 나타내주기 위해선 들여 쓰기를 해주면 좋다.

빈 줄은 프로그램을 논리의 흐름을 덩어리로 구분하게 해주어 독자로 하여금 프로그램의 구조를 쉽게 파악할 수 있게 해준다. 빈 줄 없는 프로그램은 마치 목차 없는 책을 읽는 것과 같다.

2.6 단원의 `celsius.c` 프로그램에선 위와 같은 조언들을 아주 잘 준수하고 있다. 이 프로그램의 `main` 함수를 한 번 보도록 하자.

```c
int main(void)
{
    float fahrenheit, celsius;
    printf("Enter Fahrenheit temperature: ");
    scanf("%f", &fahrenheit);
    celsius = (fahrenheit - FREEZING_PT) * SCALE_FACTOR;
    printf("Celsius equivalent: %.1f\n", celsius);
    return 0;
}
```

우선 `=`, `-`, `*`와 같이 연산자들 사이에 줄을 띄움으로써 가독성은 물론이고 연산 또한 좀 더 돋보이게 만들어주었음을 알 수 있다. 선언과 구문들을 들여 쓰기함으로써 이들이 `main` 함수에 속한다는 것을 쉽게 알 수 있다. 마지막으로 알 수 있는 것은 `main` 함수가 빈 줄에 의해 다섯 덩어리로 나뉜다는 것이다.

> `fahrenheit`과 `celsius` 변수의 선언
>
> 화씨 온도 입력 받기
>
> celsius의 값 계산하기
>
> 섭씨 온도 출력하기
>
> 운영체제에 값 반환하기

프로그램 레이아웃에 대해 논할 때 필자는 `main()` 밑에 `{` 토큰을 두었고, `}` 또한 따로 한 줄에 배치를 해두었다. `}`을 다른 줄에 배치하는 것은 함수의 말단에 구문을 추가하거나 삭제할 수 있게 만들어주며, `{`와 같은 세로 줄에 있음으로써 `main`이 어디서 끝나는지도 명확하게 알아볼 수 있게 해준다.

마지막으로 조언을 하자면, 토큰 사이에 충분히 공간을 만들 수는 있겠지만 토큰 내에 공간을 만들게 되면 프로그램의 의미가 바뀌거나 에러가 발생하게 된다. 다음 예시를 보라.

```c
fl oat fahrenheit, celsius; /*** WRONG ***/
```

위와 같이 작성하거나

```c
fl
oat fahrenheit, celsius; /*** WRONG ***/
```

다음과 같이 작성을 하게 된다면 프로그램을 컴파일할 때 에러가 발생할 것이다. 스트링 리터럴 내부에 스페이스를 넣게 되면 의미는 변할지라도 에러는 발생하진 않는다. 다만 문자열 내부에 개행을 하는 것, 즉 두 줄 이상짜리 문자열 등은 불가하다.

```c
printf("To C, or not to C:
that is the question.\n"); /*** WRONG ***/
```

문자열을 여러 줄에 걸쳐서 작성하는 방법은 나중 단원에서 배울 것이다.

#### Q & A

**GCC의 약자는 뭔가요? [GCC 컴파일러]**

GCC는 원래 "GNU C Compiler"의 약자였는데, 현재는 "GNU Compiler Collection"의 약자입니다. 이름이 바뀐 이유는 현재 GCC는 C 뿐만 아니라 Ada, C, C++, Fortran, Java와 Objective-C와 같은 다양한 언어를 컴파일하기 때문이죠.

**알겠어요. 그렇다면 GNU는 또 뭔가요?**

GNU는 "GNU's Not Unix!"(GNU는 유닉스가 아닙니다!)의 약자입니다. (GNU는 거뉴라고 발음함) GNU는 리처드 M. 스톨맨이 세운 Free Software Foundation의 프로젝트로, 사용권이 있어 사용하려면 돈을 내야했던 UNIX 소프트웨어에 일종의 저항을 하기 위해 만들었습니다. Free Software Foundation은 공식 홈페이지에 따르면 사용자들은 모두 무료로 소프트웨어를 실행하고, 복사하고, 배포하고, 공부하고, 바꾸고, 개선해야한다고 믿는다고 합니다. GNU 프로젝트에선 UNIX 소프트웨어 주로 사용하던 프로젝트들을 전부 처음부터 다시 새로 짜서 돈을 받지 않고 대중에게 공개했습니다.

GCC와 기타 GNU 소프트웨어들은 Linux 운영체제에 매우 중요합니다. Linux는 운영체제의 커널kernel일 뿐입니다. 커널이라는 것은 프로그램 순서 계획을 담당하고 간단한 입출력 서비스를 담당하는 것입니다. GNU 소프트웨어는 사실상 운영체제를 완전체로 만들어주는 역할을 합니다.

GNU 프로젝트에 좀 더 관심이 생겼다면, www.gnu.org에 직접 방문을 해보세요.

**그래서 GCC가 뭐가 중요합니까?**

GCC가 중요한 데엔 여러가지 이유가 있습니다. 우선 무료이고, 여러가지 언어를 컴파일할 수 있다는 장점이 있죠. 여러 운영체제에서 돌아가며 자주 사용하는 것을 포함해서 기타 다양한 CPU에 알맞는 코드를 작성해내죠. GCC는 대부분의 UNIX 기반 운영체제, 예를 들어 Linux, BSD, Mac OS X 등에서 주로 사용하는 컴파일러입니다. 또한 상용적인 목적으로 사용할 수 있죠. GCC에 대한 더 많은 정보는 gcc.gnu.org에서 확인하실 수 있습니다.

**GCC가 프로그램에서 에러를 잘 찾아내나요?**

GCC엔 얼마나 철저하게 프로그램을 확인하는지를 제어하는 다양한 커맨드라인 설정들이 있습니다. 이러한 설정을 사용한다면 GCC는 프로그램에서 에러를 발생할 가능성이 있는 곳을 꽤 잘 찾아냅니다. 다음이 몇 가지 자주 사용하는 설정들입니다.

- **`-Wall`** 컴파일러로 하여금 발생할 것 같은 에러를 찾아내면 경고 메시지를 출력하게 한다. (구체적인 경고문을 보고 싶다면 `-W`를 사용할 수 있다. `-Wall`이란 모든 `-W`이라는 의미이다. ) 효과를 제대로 보려면 `-O`와 결합해서 사용하는 것이 좋다.
- **`-W`** `-Wall`에 의해 생성된 경고 메시지보다 좀 더 구체적인 추가 경고 메시지를 출력한다.
- **`-pedantic`** C의 규격에서 필요로 하는 모든 경고문을 출력한다. 규격이 아닌 기능을 사용하는 모든 프로그램을 배제한다.
- **`-ansi`** C의 규격이 아닌 GCC의 기능들을 끄고 보통 사용 불가능한 몇 가지 C 규격인 기능들을 사용 가능하게 만든다.
- **`-std=c89`**
- **`-std=c99`** 컴파일러가 프로그램을 확인할 때 어떤 버전의 C를 사용할지 결정한다. 위의 설정은 주로 아래와 같이 섞어서 사용한다.

```
% gcc -O -Wall -W -pedantic -ansi -std=99 -o pun pun.c
```

**C가 도대체 어디가 간결하다는거죠? C가 `{`나 `}`말고 차라리 `begin`과 `end`를 사용하고, `int`말고 integer를, 뭐 이런 식으로 사용하는게 더 가독성이 있을 것 같은데요? [2.2 간단한 프로그램의 일반적인 형태]**

전설에 따르면 C 언어의 간결함은 당시 언어가 개발되던 벨 랩의 환경에 의한거라고 합니다. C의 첫 컴파일러는 최초의 미니 컴퓨터였던 DEC PDP-11에서 돌아갔습니다. 프로그래머들은 컴퓨터에 연결된 타자기였던 텔레타입teletype을 사용하여 프로그램을 작성하고 기타 명단 등을 작성했습니다. 텔레타입은 당시 초당 최대 10자 밖에 작성하지 못했습니다. 그렇기에 당연히 최대한 글자를 줄이는 것이 이들에게 도움이 됐겠죠?

**어떤 C 언어 교재에선 `main` 함수가 `return 0`이 아니라 `exit(0)`으로 끝나던데요, 같은 의미인가요? [함수]**

**`main` 함수내에서라면 이 두 구문은 같은 의미**입니다. 둘 다 프로그램을 끝내고 운영체제에 `0`이라는 값을 반환하죠. 둘 중 무엇을 쓸지는 취향 차이입니다.

**프로그램이 실행될 때 `main` 함수가 `return` 구문을 사용하지 않은 채로 끝난다면 무슨 일이 일어나나요?**

`return` 구문은 반드시 써야하는 건 아닙니다. 없더라도 프로그램은 종료될 것입니다. **[C99]** C89에선 운영체제에 반환되는 값이 정의되지 않지만, C99는 `main` 함수가 우리가 지금까지 다룬 예제에서처럼 만약 `int`를 반환하라고 선언된다면, 기본적으로 운영체제에 `0`을 반환합니다. 그렇지 않다면 프로그램은 특정하지 않은 값을 반환합니다.

**컴파일러가 주석을 전체를 지우나요, 아니면 그냥 빈칸으로 대체하나요?**

오래된 C 컴파일러들은 주석을 전부 다 지웠었습니다. 다음과 같이 작성할 수도 있었죠.

```
a/**/b = 0;
```

다음 구문을 아래와 같이 해석했습니다.

```
ab = 0;
```

**C 규격에 따르면 컴파일러는 반드시 주석의 각 문자를 스페이스로 대체**합니다. 그래서 위와 같은 꼼수는 통하지 않죠. 만약 위와 같이 작성하면 아래와 같이 잘못된 구문이 탄생합니다.

```
a b = 0;
```

**프로그램에 주석 처리를 제대로 안해준 주석이 있는지 어떻게 아나요?**

만약 운이 좋다면 컴파일러가 이를 인식하고 컴파일을 안하고 에러를 낼 것입니다. 만약 컴파일이 된다면, 여러가지 방법을 사용해볼 수 있습니다. 디버거를 이용해 한 줄 한 줄 분석해보면 어디서 주석 처리가 제대로 안되었는지 확인할 수 있습니다. 어떤 IDE들은 주석을 다른 일반 코드에 비해 잘 보이게 눈에 잘 띄는 색으로 출력하기도 합니다. 만약 이러한 환경에서 개발을 하고 있다면 쉽게 닫지 않은 주석을 찾을 수 있죠. `lint`와 같은 프로그램 또한 도움이 될 겁니다.

**한 주석을 다른 주석 내부에 처리해줄 수 있나요?**

최초로 나온 주석(`/*...*/`)으로는 불가능합니다. 예를 들어 다음과 같는 사용할 수는 없습니다.

```
/*
/*** WRONG ***/
*/
```

두번째 줄의 `*/`는 첫번째 줄의 `/*`과 짝 지어지기 때문에 컴파일러는 세번째 줄의 `*/`를 에러 처리합니다.

C가 갖고 있는 이러한 주석을 주석 내부에 처리하지 못하는 문제는 가끔 문제를 일으킵니다. 예를 들어 우리가 짧은 주석이 많으면서 코드가 긴 프로그램을 짠다고 가정해봅시다. 코드를 작성하다가, 예를 들어 코드를 테스트하기 위해서 중간에 명령문 일부를 주석 처리를 해줘서 작동하지 않게 만드려고 할 때가 있을 것입니다. 허나 이것은 옛날 방식으로 주석 처리를 해줄 수 없습니다. **[C99]** C99에서 나온 주석 처리 방식(`//`)은 반대로 옛날 방식의 주석 내부에서 사용할 수 있습니다. 이는 이 새로운 방식의 주석 처리가 갖는 또다른 장점입니다.

나중에 다루겠지만 사실 이런 방식보다 좀 더 깔끔하게 명령문을 작동하지 않게 만드는 방법이 있습니다.

**`float`의 이름의 유래가 뭔가요? [유형]**

`float`은 부동 소수점floating-point의 약자로, 소수점이 존재하는 숫자를 저장할 때 사용하는 겁니다. float 값은 주로 분수fraction(혹은 가수mantissa)와 지수exponent 두 부분으로 나뉘어서 저장됩니다. 12.0은 1.5×2^3 라고 저장될 수 있습니다. 1.5는 분수고 3이 지수죠. 몇몇 프로그래밍 언어는 이러한 유형을 `float` 대신 `real`이라고 부릅니다.

**부동 소수점 상수에 끝에 왜 f를 붙여주나요? [유형]**

완벽한 대답을 얻고 싶다면 7단원을 참고해보세요. 간단하게 답변드리자면, 소수점을 포함하지만 **`f`가 붙지 않은 상수는 `double` 유형**이 될 수 있습니다. 이는 배정밀도double precision의 약자이지요. `double` 값은 `float` 값보다 더 정확하게 저장되어있습니다. 또한 `double` 값은 `float` 값보다 더 클 수도 있죠. 그렇기 때문에 `float` 변수에 값을 할당할 때 끝에 `f`를 붙여주는 겁니다. 만약 `f`가 없다면 `float` 변수에 할당된 값이 변수가 저장할 수 있는 최대값보다 클 수도 있기 때문에 에러가 발생할 수 있죠.

**정말로 식별자의 이름 길이엔 한계가 없나요? [2.7 식별자]**

한계가 없으면서 있습니다. C89 표준에 의하면 식별자는 임의적으로 마음대로 길게 해도 된다고 합니다. 하지만 컴파일러들은 31번째 글자까지는 외우는데 그 이후는 안 외워도 됩니다. **[C99]** C99의 경우는 63 글자입니다. 그렇기에 서로 다른 두 이름이 31번째 글자까지는 전부 같다면, 컴파일러는 이 둘을 같은 이름으로 인식할 수 있습니다.

좀 더 일이 복잡해질 수도 있는데요, 외부 링크가 있는 식별자에는 또 특별한 법칙이 적용받습니다. 대부분의 함수 이름들은 이러한 경우에 포함되죠. 이러한 이름들은 링커가 꼭 나중에 확인을 해야하는데요, 좀 오래된 링커들은 오로지 짧은 이름만을 인식합니다. C89의 경우 여섯번째까지만 인식을 하죠. 심지어는 대소문자 구분을 안할 수도 있습니다. 그래서 `abcdefg`랑 `ABCDEFG`를 같다고 인식할 수 있습니다. **[C99]** C99의 경우 31번째까지 인식하고 대소문자 구분을 합니다.

대부분의 컴파일러나 링커는 생각보다 그렇게 엄하게 규격을 따르지 않으므로 이러한 규칙이 실생활에는 그렇게 큰 영향을 미치지 않을 것입니다. 식별자가 너무 길지 않을까를 고민하기보다 식별자가 너무 짧지 않나를 고민하세요.

**들여 쓰기를 할 때 줄을 몇 칸 띄워야하나요? [2.8 프로그램의 레이아웃]**

흠, 좀 대답하기 어려운 질문이군요. 적게 띄우자니 이게 들여 쓰기인지 제대로 확인이 안되고, 너무 많이 띄우자니 한 줄, 혹은 한 페이지 전체에 적을 수 있는 양이 적어지네요. 대부분의 C 프로그래머들은 8칸, 혹은 탭 한 번으로 들여 쓰기를 하는데, 이건 좀 너무 많다고 생각합니다. 연구 결과 최적의 개수는 세 칸 띄우기라고 하는데요, 대부분의 프로그래머들은 사실 2배수가 아닌 숫자들을 불편해합니다. 저는 개인적으론 세 칸이나 네 칸을 선호하는데, 전 이 책에선 책 내에 잘 알맞기 위해 두 칸만을 띄웠습니다.

### 03.Formatted Input-Output

#### 3.1 printf 함수

`printf` 함수는 format string이라고 불리는 문자열을 문자열의 특정 부분에 추가된 값과 함께 출력하는 기능을 수행하도록 만들어졌다. `printf`이 호출되려면 우선 format string과 출력을 할 때 삽입되어야하는 값을 공급해주어야 한다:

```c
printf(string, expr1, expr2, ...);
```

출력되는 값들은 상수일 수도, 변수일 수도, 혹은 매우 복잡한 표현식일 수도 있다. `printf` 함수는 호출 한 번으로 무한가지의 값을 출력할 수 있다.

서식렬은 일반적인 문자와 `%`로 시작되는 변환 규격conversion specification을 둘 다 포함할 수 있다. 변환 규격은 출력할 때 채워져야 하는 값을 대신하는 기호나 텍스트의 일부이다. `%` 다음으로 나오는 정보는 값이 어떤 규격으로 본래 형식(이진수)에서 출력되는 형식(문자) 변환되는지를 정한다. 이것이 변환 규격의 이름의 유래이다. 예를 들어 변환 규격 `%d`는 `printf`이 `int` 값을 이진수로부터 10진수를 갖는 문자열로 변환되어 출력을 하는 규격을 정해준다. `%f` 또한 `float` 값에 대하여 마찬가지로 규격을 정한다. 서식렬의 일반적인 글자들은 생긴 그대로 출력이 될 것이다. 변형 규격의 경우 출력되야할 값들로 바뀌어져서 출력된다. 다음 예제를 보라.

```c
int i, j;
float x, y;
i = 10;
j = 20;
x = 43.2892f;
y = 5527.0f
printf("i = %d, j = %d, x = %f, y = %f\n", i, j, x, y);
```

`printf` 함수를 호출하게 다면 다음과 같은 결과가 출력될 것이다.

```c
i = 10, j = 20, x = 43.289200, y = 5527.000000
```

서식렬의 일반적인 글자들은 그냥 그대로 출력이 되었다. 네 개의 변환 규격들은 순서대로 변수 `i`, `j`, `x`, 그리고 `y`로 바뀌어져서 출력되었다.

> **[!!!]** C 컴파일러들은 서식렬에서의 변환 규격의 개수와 출력되는 것들의 개수가 같은지를 반드시 확인하지 않는다. 다음과 같은 `printf` 함수의 호출을 보면 출력해야할 값보다 변환 규격이 더 많다.
>
> ```c
> printf("%d %d\n", i); /*** WRONG ***/
> ```
>
> `printf`은 `i`의 값은 제대로 출력하고, 아무런 의미가 없는 두 번째 정수값을 출력할 것이다. 반대로 출력해야할 값이 변환 규격보다 많으면 비슷한 문제를 일으킨다.
>
> ```c
> printf("%d\n", i, j); /*** WRONG ***/
> ```
>
> 이 경우엔 `printf`이 `i`의 값은 출력하지만 `j`의 값은 출력하지 않을 것이다.
>
> 좀 더 구체적으로 언급하자면, 컴파일러들은 굳이 변환 규격이 출력되는 것의 유형에 적합한지를 확인하지 않는다. 만약 프로그래머가 잘못된 규격을 사용한다 할지라도, 프로그램은 실행이 될 것이고 아무런 의미가 없는 결과값을 출력할 것이다. 다음과 같이 `int` 변수 `i`와 `float` 변수 `x`가 틀린 순서로 되어있는 상태에서 `printf`을 호출해주었다고 하자.
>
> ```c
> printf("%f %d\n", i, x); /*** WRONG ***/
> ```
>
> 우선 `printf`은 서식렬이 지시하는 대로 따라야하기 때문에 지시한 대로 `float` 값과 `int` 값을 순서대로 출력할 것이다. 물론 두 개 다 의미없는 결과값일 것이다.

**변환 규격**

변환 규격을 통해 프로그래머는 출력을 좀 더 다양하고 구체적으로 할 수 있다. 그렇기 때문에 변환 규격은 사용하기 복잡하고 읽기 복잡하다. 사실 변환 규격을 이 책에서 완벽하게 설명한다는 것은 매우 힘든 일이다. 대신 변환 규격의 중요한 기능들을 간단하게 확인해볼 것이다.

>  `float` 값을 소수점 아래 한 자리까지만 출력해주기 위해 `%.1f` 를 이용

좀 더 일반적으로 보자면 변환 규격은 `%m.pX`이나 `%-m.pX`와 같은 형식을 갖는다. 여기서 `m`과 `p`는 정수 상수이고 `X`는 문자이다. `m`과 `p`는 선택적으로 추가해주는 것이다. `m`과 `p`를 나누는 소수점은 `p`와 함께 사용해야한다. 

> 변환 규격 `%10.2f`에선 `m`은 `10`, `p`는 `2`이고 `X`는 `f`이다. 

변환 규격 `%10f`에선 `m`은 `10`, `p`는 사용되지 않았기 때문에 소수점과 함께 사용되지 않았으며, `X`는 `f`이다. 반면에 변환 규격 `%.2f`의 경우 반대로 `p`는 `2`이고 `m`는 사용되지 않았다.

> `m`의 뜻은 최소 범위 너비minimum field width로, 출력할 글자의 최소 개수를 정한다. 

출력할 값의 글자가 `m` 개보다 적다면 주어진 범위 내에 있는 것이다. 다시 말해서 출력해야할 최소 글자보다 적은 개수의 글자를 갖기 때문에 나머지는 **스페이스로 처리**된다. 예를 들어 규격 `%4d`을 준 다음 출력할 값을 `123`로 준다면, 실제 출력되는 값은 `·123`일 것이다. (이 단원에선 스페이스를 `·`로 표기하겠다.) 위의 경우와는 반대로 출력할 값의 글자가 `m` 개보다 크다면 **자동으로 범위를 필요한만큼 넓힌다**. 그렇기 때문에 규격 `%4d`을 준 다음 출력할 값을 `12345`로 준다면, 실제 출력되는 값은 `12345`일 것이다. 네 자리를 출력하라고 해서 다섯 자리 중에 잘리는 숫자가 없는 것이다. 

> 만약 `m`앞에 마이너스 기호를 표기해준다면 숫자를 **왼쪽에 정렬**하게 된다. 

즉, 규격 `%4d`을 준 다음 출력할 값을 `123`로 준다면, 실제 출력되는 값은 `123·`이다.

> `p`의 뜻은 정확도precision이다. 

정확도는 `X`, 혹은 변환 규격자conversion specifier의 종류에 따라 다르게 정의된다. `X`는 값이 출력되기 전 어떤 방식의 변환이 적용되어야하는지를 결정한다. 가장 자주 사용되는 숫자의 변환 규격자는 다음과 같다.

> - **`d`** - **[Q&A]** 정수를 십진법 형식으로 보여준다. `p`는 최소 자리수를 의미한다. 만약 필요하다면 숫자가 시작하는 부분에 추가적으로 `0`을 추가해준다. 만약 `p`가 포함되지 않았다면 `p`의 값이 `1`이라고 가정한다. 다시 말해 `%d`와 `%.1d`는 같은 것이다.
> - **`e`** - 소수를 지수 형식(물리량을 나타낼 때 사용하는 방식)으로 보여준다. `p`는 출력할 소수점 이하 자리수를 결정한다. 기본값은 여섯자리이다. 만약 `p`의 값이 `0`이라면 소수점을 출력하지 않는다.
> - **`f`** - 소수를 지수 없이 고정 소수점 형식으로 보여준다. `p`는 `e` 규격자와 같은 의미를 갖는다.
> - **`g`** - 소수를 숫자의 크기에 따라 지수 형식 혹은 고정 소수점 형식으로 보여준다. `p`는 최대 유효 숫자 자리수를 의미한다. 이는 소수점 아래 자리수를 의미하는 것이 아니다. `f` 변환과는 달리 `g` 변환은 추가적인 `0`을 출력하지 않는다. 심지어 출력할 값이 소수점 이하 자리수가 없다면 `g`는 소수점 조차 출력하지 않는다.

`g` 규격자는 프로그램을 작성할 때 숫자가 사이즈를 예측할 수 없거나, 사이즈가 다양할 때, 이를 출력하는데 유용하다. `g` 규격자는 적당히 크거나 적당히 작은 숫자를 출력할 때 고정 소수점 형식을 사용한다. 허나 매우 크거나 매우 작은 숫자를 출력할 땐 지수 형식을 사용함으로써 숫자가 길지 않게 만든다. `%d`, `%e`, `%f`, `%g` 외에도 다른 다양한 규격자들이 있지만 이후 단원에서 차차 소개하도록 하겠다. 모든 규격자를 총망라한 목록과 이 변환 규격자들의 기능에 대한 완벽한 설명은 22.3 단원을 확인해보라.

**[프로그래밍] printf를 통한 숫자 서식**

다음 프로그램을 통해 printf가 정수나 실수를 다양한 서식으로 출력할 수 있음을 알 수 있다.

**tprintf.c**

```c
/* Prints int and float values in various formats */
#include <stdio.h>
int main(void)
{
    int i;
    float x;
    i = 40;
    x = 839.21f;
    printf("|%d|%5d|%-5d|%5.3d|\n", i, i, i, i);
    printf("|%10.3f|%10.3e|%-10g|\n", x, x, x);
    return 0;
}
```

`printf`의 서식렬 내부에 있는 `|`는 이 서식렬이 출력될 때 얼마나 많은 칸을 소모하는지를 보여주기 위해 사용했다. `%`나 `\`와는 달리, `|`는 `printf`에서 아무런 기능을 갖고 있지 않기에, 마음대로 사용할 수 있다. 위 프로그램을 출력하면 다음과 같을 것이다.

```
|40|   40|40   |  040|
|   839.210| 8.392e+02|839.21    |
```

이 프로그램에서 사용한 변환 규격들에 대해 좀 더 구체적으로 살펴보자.

- **`%d`** ― `i`를 십진수의 형태로 출력하되, 최소한의 공간만을 차지한다.
- **`%5d`** ― `i`를 십진수의 형태로 출력하되, 최소 다섯 칸을 사용한다. `i`는 두 칸을 차지하므로, 추가적으로 빈 칸 세 칸이 더 추가되었다.
- **`%-5d`** ― `i`를 십진수의 형태로 출력하되, 최소 다섯 칸을 사용한다. `i`는 두 칸을 차지하므로, 추가적으로 빈 칸 세 칸이 `i`가 먼저 출력되고 나서 추가되었다. 즉, `i`는 좌측으로 정렬된다.
- **`%5.3d`** ― `i`를 십진수의 형태로 출력하되, 출력은 최소 다섯 칸, 숫자는 최소 세 칸을 사용한다. `i`는 두 칸 밖에 안되므로 세 칸을 채우기 위해 `0`이 추가되었다. 이제 세 칸이 찼으므로 부족한 두 칸을 빈 칸으로 채워 총 다섯칸을 채운다, `i`는 우측으로 정렬된다.
- **`%10.3f`** ― `x`를 고정된 십진수의 형태로 출력하되, 출력은 최소 열 칸, 소수점 이하는 최소 세 칸을 사용한다. `x`는 소수점 이전 세 칸, 소수점 이후 세 칸, 소수점이 한 칸, 총 일곱 칸이 필요하므로 세 칸을 채우기 위해 `x` 좌측에 빈 칸 세 칸이 추가되었다.
- **`%10.3e`** ― `x`를 지수형으로 출력하되, 출력은 최소 열 칸, 소수점 이하는 최소 세 칸을 사용한다. `x`는 지수를 포함하면 총 아홉 칸을 사용하기 때문에 `x` 좌측에 빈 칸 한 칸이 추가되었다.
- **`%-10g`** ― `x`를 고정 십진수 형태나 지수형으로 출력하되, 출력은 최소 열 칸을 사용한다. 위의 경우에선 `printf`은 `x`를 고정 십진수 형태로 출력했다. 앞에 마이너스 기호는 `x`를 좌측으로 정렬하라는 의미이기 때문에 `x` 이후에 빈 칸 네 칸이 추가되었다.

**확장 비트열**

지금까지 서식렬에서 매우 자주 등장한 `\n`와 같은 코드는 확장 비트열escape sequence라고 부른다. 확장 비트열은 문자열로 하여금 컴파일러에서 문제를 일으킬 수도 있는 문자들을 출력할 수 있게 해준다. 이는 프린트 되지 않는 제어 문자들이나 "와 같이 컴파일러가 특별히 다루는 문자들을 의미한다. 우선은 몇 가지의 확장 비트열들을 소개하도록 하겠다. 모든 확장 비트열을 다루는 목록은 지금은 다루지 않겠다.

> 경보 (종소리)  `\a` 
> 백스페이스     `\b`
> 새 줄               `\n` 
> 수평탭            `\t` 

확장 비트열은 `printf`의 서식렬 중에서 가장 먼저 실행이 된다. `\a`를 출력하게 된다면 대부분의 기기에서 비프음을 낼 것이다. `\b`를 출력한다면 커서를 한 칸 뒤로 놓을 것이다. `\n`를 출력한다면 커서가 다음 줄의 첫 부분으로 갈 것이다. **[Q&A]** `\t`를 출력한다면 커서를 한 탭 뒤에 놓을 것이다. 문자열은 여러 개의 확장 비트열을 제한 없이 갖고 있을 수 있다. 다음 `printf` 예시에선 확장 비트열을 총 여섯 가지를 사용하고 있다.

```c
printf("Item\tUnit\tPurchase\n\tPrice\tDate\n");
```

이 프로그램을 실행하게 된다면 다음과 같이 나올 것이다.

> Item	Unit	Purchase
>
> ​	Price	Date

위의 예시 말고도 자주 쓰이는 확장 비트열은 `\"`이고, 이는 `"` 문자를 출력한다. `"`는 문자열의 시작과 끝을 나타내주는 문자이기에 문자열 내에선 확장 비트열을 사용하지 않는 이상 사용할 수 없다. 다음 예시를 보라.

```c
printf("\"Hello!\"");
```

위 구문을 실행한다면 다음과 같이 출력될 것이다.

> "Hello!"

당연하겠지만 문자열 내부엔 `\` 한 개를 사용할 수 없다. 컴파일러는 이를 확장 비트열의 시작으로 인식할 것이기 때문이다. 즉, `\` 문자를 출력해주기 위해선 두 번 연속해서 사용해주면 된다.

```c
printf("\\"); /* 문자 '\'를 하나를 출력한다 */
```



#### 3.2 sacnf 함수

`printf`이 특정 서식에 따라 출력을 하듯, `scanf`은 특정 서식에 따라 입력을 받는다. `printf`의 형식 문자열처럼 `scanf`의 형식 문자열 또한 기본적인 문자들과 변환 규격을 둘 다 포함할 수 있다. `scanf`에서 허용되는 변환들은 전부 `printf`에서 사용되는 변환들과 같다.

대부분의 경우 `scanf`의 형식 문자열은 변환 규격만을 갖고 있는 경우가 많다. 다음 예제를 보라.

```c
int i, j;
float x, y;
scanf("%d%d%f%f", &i, &j, &x, &y);
```

사용자가 다음과 같이 입력했다고 가정해보자.

> 1 -20 .3 -4.0e3

`scanf`은 이 줄을 읽은 다음 각 문자들을 내포하고 있는 숫자로 변환한 다음 `i`, `j`, `x`, `y`에 각각 `1`, `-20`, `.3`, `-4.0e3`을 할당한다. `scanf`을 호출할 때엔 `"%d%d%f%f"`와 같이 "빽빽하게 채워진" 형식 문자열을 자주 사용하게 된다. `printf`은 반면에 변환 규격들끼리 인접해 있지 않는 경우가 많다.

 `printf`처럼 `scanf`은 자신도 모르게 실수할 수 있을 때가 있기에 몇 가지를 주의해야한다. 우선 `scanf`을 사용할 때면 프로그래머들은 반드시 변환 규격의 개수와 입력받는 변수의 개수가 같으며, 각 변환이 해당하는 변수에 알맞는지를 확인해야한다. `printf`처럼 컴파일러는 이에 대해서 확실하게 확인하고 넘어가지 않는다. 또다른 주의할 점은 `scanf`을 호출할 때 시용하는 변수들 앞에 사용되는 `&` 기호이다. `&` 기호는 반드시는 아니지만 보통 꼭 필요하며, 프로그래밍할 때 이를 까먹어서는 안된다. 이것은 프로그래머의 책임이다. 

>  **[!!!]** `scanf`을 사용할 때 `&` 기호를 깜빡하고 적지 않는 경우에 예측할 수 없는 결과가 나오고, 어쩌면 좋지 못한 결과를 불러올 수도 있다. 프로그램이 오류가 나서 종료되는 것이 흔한 결과일 것이다. 만약 변수에 이미 저장되어 있는 다른 값이 있는 경우 입력 때 받은 값을 변수에 저장하지 못하고, 변수는 기존에 갖고 있던 값을 그대로 갖고 있을 것이다. 물론 만약 변수가 초기값을 갖지 않는 상태라면 그러한 결과는 나오지 않을 것이지만 말이다. `&` 기호를 적어주지 않는 행위는 사실 매우 흔한 에러이니, 꼭 주의하길 바란다. 어떤 컴파일러는 이 에러를 파악하고 "서식 입력값이 포인터가 아닙니다format argument is not a pointer"와 같은 경고 메시지를 낼 것이다. 여기서 포인터는 뒤에 나올 11 단원에서 다룰 것이다. `&` 기호가 변수에 포인터를 생성할 때 사용하기 때문이라고만 알아두라. 만약 이러한 경고 메시지를 보게 된다면, `&` 기호가 누락된 것이다. 

 **`scanf`을 호출하는 행위는 매우 강력하지만 데이터를 읽기에는 좋지 못한 방식이다. 대부분의 전문적인 C 프로그래머들은 `scanf`을 사용하지 않고, 모든 데이터를 문자 형식으로 받아 나중에 숫자 형식으로 변환하는 방식을 사용한다.** 우선 이 책에선 `scanf`을 사용하는게 숫자를 읽기엔 훨씬 편해서 초반부에서 자주 사용할 것이다. 주의해야할 점은 이 책에서 다룰 대부분의 프로그램들은 사용자가 제대로 입력하지 않는다면 제대로 작동하지 않을 것이다. 나중에 다루겠지만, 프로그램에서 `scanf`이 제대로 된 데이터를 받았는지 않았는지를 검사하고, 만약 그렇지 않았다면 그걸 복구하는 방법을 작동하게 만들어줄 수 있다. 이러한 방식의 검사는 이 책에서는 사용하지 않을 것이다. 이것을 사용하게 된다면 코드가 너무 길어지기에 예제에서 말하고자 하는 점이 무색해진다. 

**`scanf`의 작동 방식**

`scanf`은 사실 지금까지 서술한 것 그 이상으로 작동할 수 있다. `scanf` 함수는 사실 변환규격과 입력된 문자들을 짝짓는 "짝 맞추기" 함수다.

`printf` 함수와 마찬가지로, `scanf` 함수는 서식 문자열에 의해 제어된다. `scanf` 함수는 호출될 때 문자열을 왼쪽부터 처리하는 것으로 시작한다. `scanf` 함수는 서식 문자열 내 변환규격마다 각각 알맞는 형식의 아이템을 입력되는 변수에 집어넣는다. 이 과정에서 빈 칸은 필요에 따라 무시되기도 한다. 이 다음에 `scanf`은 해당 아이템을 읽고, 해당 아이템과 무관한 문자가 나오면 읽는 것을 멈춘다. 읽기가 완료되면 그 다음엔 남은 나머지 서식문자열을 처리한다. 어떤 아이템이라도 제대로 읽히지 않았다면 `scanf` 함수는 나머지 서식문자열(혹은 남아있는 입력값)은 확인도 하지 않고 즉시 값을 반환한다.

기본적으로 숫자를 입력받는다고 할 때 `scanf` 함수는 공란문자white-space characters(빈칸, 수평/수직 탭, 폼-피드form-feed, 개행문자)를 무시한다. 즉, 숫자는 한 줄에만 있을 수도 있고, 여러 줄에 걸쳐 적혀있을 수도 있다. 다음 함수 호출 예시를 보도록 하자.

```c
scanf("%d%d%f%f", &i, &j, &x, &y);
```

사용자가 본 프로그램에 다음과 같이 세 줄을 입력했다고 가정하자.

>   1
>   -20   .3
>   -4.0e3

`scanf` 함수는 이를 세 줄이 아닌 하나의 연속된 문자로 인식한다.

> ●●1¤-20●●●.3¤●●●-4.0e3¤

(여기서 ●는 빈 칸을, ¤은 개행문자를 의미한다.) `scanf` 함수는 여기서 숫자를 읽어야 하므로 숫자를 찾는 도중에 발견되는 모든 공란문자를 무시한다. 그 결과 `scanf` 함수는 정상적으로 네 숫자를 읽을 수 있게된다. 아래를 보면 `s`는 무시skip한 문자를 의미하고 `r`은 읽은read 문자를 의미한다.

> ●●1¤-20●●●.3¤●●●-4.0e3¤
> s sr srrr sss rrs sss rrrrrr

**`scanf` 함수는 마지막에 있는 개행문자를 읽지는 않지만 인식**은 한다. 이 개행문자는 **다음 `scanf` 함수 호출 때 첫번째 인식될 문자**이다.

`scanf` 함수가 정수 혹은 고정소수를 인식할 때 어떤 규칙을 따를까? 

**정수를 읽을 때엔**

>  `scanf` 함수는 우선 음양을 확인한다. 
>
>  그 이후 숫자가 아닌 문자를 인식할 때까지 값을 읽는다. 

**고정소수를 읽을 땐,** 

> 음양을 확인하고. 
>
> (선택) 연속된 숫자들을 확인하고 
>
> (고정소수점을 포함할 수도 있음) 지수를 확인한다. 
>
> (선택. 언제나 존재하지 않음.) 지수는 `e` (혹은 `E`)로 시작하고, 그 뒤에 한 개 이상의 숫자가 존재할 수 있다.

`%e`. `%f`와 `%g` 변환은 `scanf`과 함께 사용되는 경우 상호변환가능하다. 다시 말해, 이 세가지 변환규격들은 고정소수를 인식하는 규칙을 전부 따른다.

`scanf` 함수가 현재 읽고 있는 아이템에 속할 수 없는 문자를 읽게될 경우 해당 문자는 "뒤로 밀려나"**[Q&A]** 다음 아이템을 찾거나 다음 `scanf` 호출을 기다릴 때까지 대기한다. 다음 네 개의 (솔직히 좀 이상하게 생긴)숫자들을 통해 알아보자.

> 1-20.3-4.0e3¤

위에서 썻던 `scanf` 호출처럼 동일하게 호출을 한다.

```c
scanf("%d%d%f%f", &i, &j, &x, &y);
```

`scanf` 함수는 새로운 입력을 다음과 같이 처리한다.

- **변환규격: `%d`.** 공란문자가 아닌 첫 문자는 `1`이다. 정수는 `1`로 시작할 수 있으므로 `scanf` 함수는 그 다음 문자인 `-`를 읽는다. `-` 문자는 정수에 포함될 수 없으므로 `scanf` 함수는 `1`을 `i`에 저장하고 `-`를 뒤로 미룬다.
- **변환규격: `%d`.** `scanf` 함수는 이제 다시 `-` 문자를 읽고, 순서대로 `2`, `0`, `.`을 읽는다. 정수는 소수점을 갖고 있지 않으므로 `scanf`은 `-20`을 `j`에 저장하고 `.` 문자를 뒤로 미룬다.
- **변환규격: `%f`.** `scanf` 함수는 `.`, `3`, `-`를 읽는다. 고정소수는 숫자 이후에 `-` 기호가 올 수 없으므로 `0.3`을 `x`에 저장하고 `-` 문자는 뒤로 미룬다.
- **변환규격: `%f`.** 마지막으로 `scanf` 함수는 `-`, `4`, `.`, `0`, `e`, `3`과 `¤`(개행문자)를 읽는다. 고정소수는 개행문자를 가질 수 없으므로 -4.0 × 10³을 `y`에 저장하고 개행문자를 뒤로 미룬다.

이 예시에서 `scanf` 함수는 서식문자열의 각 변환규격마다 아이템을 짝 지어줄 수 있었다. 개행문자는 읽히지 않았으므로 다음 `scanf` 호출 때 사용될 것이다.

**형식 문자열에서의 기본적인 문자들**

"짝 맞추기"의 개념은 한 발 더 나아가 서식문자열에 변환규격자 뿐만 아니라 일반적인 문자를 추가해줘도 된다. `scanf`이 서식문자열 내의 일반적인 문자를 처리하는 방식은 그 문자가 공란문자인지 아닌지에 따라 달라진다. 

- **공란문자.** 

서식문자열 내에 하나 혹은 연속된 공란문자가 존재할 경우 `scanf`은 (뒤로 미룰)비공란문자를 찾기 전까지 계속해서 공란문자를 읽는다. 서식문자열에 공란문자가 몇 개가 있는지는 중요하지 않다. 서식문자열 내의 한 개의 공란문자만으로도 입력받은 문자들 내 여러 개의 공란문자를 전부와 짝 지어진다. (구체적으로 설명하자면, 서식문자열에 공란문자를 넣었다고 해서 반드시 입력값에 공란문자가 있어야하는 것은 아니다. 서식문자열 내의 공란문자는 입력값에 몇 개의 공란문자가 있던 전부 짝 지어질 수 있따. 심지어는 공란문자가 0개여도 말이다.)

- **기타 문자들.** 

서식문자열 내의 공백이 아닌 문자를 읽게되면 `scanf`는 이를 다음 입력문자와 비교한다. 만약 이 두 문자들이 짝 지어질 수 있다면 `scanf`는 입력문자를 무시하고 다음 서식문자열을 확인한다. 만약 짝이 지어지지 않는다면 `scanf`는 해당 문자를 다시 입력에 돌려놓고 읽기 과정을 취소하여 서식문자열을 처리하거나 입력 문자들을 더 이상 읽지 않는다.

예를 들어 서식문자열이 `"%d/%d"`라고 가정해보자. 만약 입력이

> ●5/●96

이라면 `scanf`은 우선 정수를 찾아야 하므로 첫번째 빈칸을 무시하고 `%d`를 `5`와 짝 지어준다. 그 다음엔 `/`를 `"%d/%d"`안에 있는 `/`와 짝 지어주고, 또다시 빈칸 무시하고 `%d`와 `96`을 짝 지어준다. 반대로 입력이

> ●5●/●96

이라면 첫 빈 칸을 넘기고, `%d`를 `5`와 짝 지어준다. 그 다음엔 `/`를 짝 지어줘야되는데, 입력문자는 빈 칸이므로 빈 칸을 뒤로 물리고 나머지 `●/●96`은 다음 `scanf` 호출에 의해 읽힐 수 있게 내비둔다. 만약 첫번째 정수 이후에 빈 칸을 허용하려면 서식문자열을 `"%d /%d"`로 해야한다.

**`printf`과 `scanf`의 구분**

`scanf`과 `printf`의 호출이 비슷해보여도 이 둘에는 중요한 차이점이 있다. 이러한 차이점을 숙지하지 않고 프로그램을 짜는 것은 매우 위험한 행동이다.

가장 흔한 실수는 `printf` 함수 호출에 사용되는 변수 앞에 `&`을 붙이는 것이다.

```c
printf("%d %d\n", &i, &j);    /*** WRONG ***/
```

다행히도 이 실수는 비교적 쉽게 찾을 수 있다. 위 코드를 실행하면 `i`와 `j`의 값이 아닌 이상한 숫자 둘 을 생성해 낼 것이다.

`scanf` 함수는 자료 아이템을 읽을 때 공란문자를 무시하기 때문에 서식문자열 내에 변환규격자 외의 문자를 거의 추가하지 않는다. `scanf`의 서식문자열을 `printf`의 서식문자열 대하듯이 대하는 것은 흔히 저지르는 실수 중 하나로, 프로그래머가 예상하지 못한 결과를 일으킬 수 있다. 다음과 같이 `scanf` 함수를 호출하게 되면 어떤 일이 벌어지는지 확인해보자.

```c
scanf("%d, %d", &i, &j);
```

`scanf`은 우선 정수값을 찾을 것이고, 이는 `i` 변수에 저장된다. 그 다음엔 `,`을 짝 지어줘야하기 때문에 다음 입력문자는 쉼표여야한다. 만약 다음 입력문자가 빈 칸이라면 거기서 `j`의 값은 읽지도 않은채로 `scanf`은 종료된다.

> **[!!!]** `printf`의 서식문자열이 `\n`으로 주로 끝난다고 해서 `scanf`의 서식문자열을 `\n`로 끝내는 것은 좋은 생각은 아니다. `scanf`에게 있어 개행문자란 빈 칸과도 동일하다. 즉, 마지막 문자가 `\n`이든 ` `이든 이는 `scanf`으로 하여금 다음 비공란문자를 찾게 만든다. 예를 들어 서식문자열이 `"%d\n"`이라면 `scanf`은 공란문자를 무시하고 정수를 읽을 것이고, 그 다음에 또다른 비공란문자가 나올 때까지 `\n`과 공란문자를 짝 지어줄 것이다. 즉, 해당 서식문자열은 사용자가 비공란문자를 입력할 때까지 `scanf` 함수를 끝내지 않고 기다릴 것이다.

**[프로그래밍] 분수 더하기**

`scanf`의 짝 맞추기 능력을 살펴보기 좋은 예제는 사용자로 하여금 분수를 입력하게 만드는 예제다. 분수는 보통 분수numerator/분모denominator 꼴로 작성된다. 사용자가 각 분수와 분모를 따로 정수형으로 입력하는 것이 아니라, 아예 전체 분수를 입력해도 `scanf`는 이를 인식할 수 있다. 두 개의 분수를 더하는 역할을 하는 프로그램을 짜보자. 해당 프로그램은 `scanf`이 어떤 식으로 분수를 한 번에 입력받을 수 있는지 보여준다.

**addfrac.c**

```c
/* 두 분수를 더해준다 */

#include <stdio.h>

int main(void)
{
    int num1, denom1, num2, denom2, result_num, result_denom;

    printf("첫번째 분수를 입력하세요: ");
    scanf("%d/%d", &num1, &denom1);

    printf("두번째 분수를 입력하세요: ");
    scanf("%d/%d", &num2, &denom2);

    result_num = num1 * denom2 + num2 * denom1;
    result_denom = denom1 * denom2;
    printf("둘의 합은 %d/%d 입니다.\n", result_num, result_denom);

    return 0;
}
```

이 프로그램을 실행해보면 다음과 같을 것이다.

```
첫번째 분수를 입력하세요: 5/6
두번째 분수를 입력하세요: 3/4
둘의 합은 38/24 입니다.
```

결과값은 약분이 되어있지 않다.



#### Q & A

`**%i` 변환이 정수를 입출력받을 때 사용되던 걸 봤는데요, `%d`랑 뭐가 다르죠? [변환규격]**

`printf`의 서식문자열에서는 큰 차이가 없는데요, `scanf`에서는 차이가 있어요. `%d`는 오로지 10진수 정수만 입력받을 수 있는데요, **`%i`는 이와 달리 10진수, 8진수, 16진수를 모두 인식할 수 있어요**. 만약 입력값이 `0`으로 시작한다면 (예를 들어 `056`) `%i`는 해당 입력값을 8진수로 취급해요. 만약 `0x56`처럼 `0x` 혹은 `0X`으로 시작하면 16진수로 취급하죠. 입력 받을 때 `%d`가 아니라 `%i`를 사용했다가 실수로 숫자 앞에 `0`이라도 넣으면 큰일 나겠죠? 이렇게 실수가 나기 쉬워서 전 `%d`을 사용하기를 추천드려요.

**`printf`가 `%`을 변환규격의 시작으로 인식한다면, `%`는 어떻게 출력하죠? [변환규격]**

`%` 두 개를 연이어서 쓰면 돼요.

```c
printf("순이익: %d%%\n", profit);
```

위 구문은

> 순이익: 10%

뭐 이런 식의 결과값을 출력할거예요.

**`\t` 확장비트열을 `printf`에서 사용되면 다음 탭으로 넘어가게 되는데요, 탭 하나에 빈 칸이 몇 개인가요? [확장비트열]**

알 수 없어요. C언어는 `\t`의 효과를 정의하지 않고 프로그래밍을 하는 운영체제에 의해 결정되죠. 주로 8칸이긴 한 수 없어요. C언어는 `\t`의 효과를 정의하지 않고 프로그래밍을 하는 운영체제에 의해 결정되죠. 주로 8칸이긴한데, 전부 그런 건 아니에요.

**`scanf`이 숫자를 읽어야할 때 숫자가 아닌 값을 입력해주면 어떻게 되나요?**

직접 예시로 살펴보죠.

```c
printf("숫자를 입력하세요: );
scanf("%d", &i);
```

사용자가 해당 코드에 다음과 같이 숫자 먼저 입력하고 문자를 입력했다고 해봅시다.

> 숫자를 입력하세요: 23foo

이 경우 `scanf`은 `2`와 `3`을 읽고 이를 `i`에 저장합니다. 나머지 문자들 `foo`는 다음 `scanf` 혹은 기타 다른 입력 함수 호출 때 사용되겠죠? 반대로 애초에 입력값이 문자로 시작한다고 해보죠.

> 숫자를 입력하세요: foo

이 경우 **`i`의 값은 정의되지 않아요**. `foo`는 다음 `scanf`에 맡겨지게 되겠죠.

그러면 `scanf`이 정상적으로 작동했는지 안했는지 어떻게 알까요? 이는 나중 챕터에서 다뤄볼거에요. 만약 호출이 실패하면 프로그램으로 하여금 종료하거나 유저보고 다시 입력해달라고 해서 다시 제대로 시도하게 만들 수 있어요. 이런식으로 원치 않은 입력값을 다루는 방법은 뒤 22 단원의 Q & A 섹션에서 다뤄보도록 해요.

**`scanf` 함수가 문자를 뒤로 "미루고" 나중에 다시 읽힌다는게 무슨 말인지 모르겠어요 [`scanf`의 작동 방식]**

사실 프로그램은 유저가 입력한대로 입력값을 읽지 않아요. 입력값은 사실 우선 `scanf`이 사용할 수 있는 숨겨진 버퍼에 저장이 돼요. `scanf`은 다음에 계속해서 읽기 과정을 진행하기 위해 문자를 다시 이 버퍼에 미루는게 가능해요. 이 입력 버퍼에 대해서는 22 단원에서 구체적으로 다룹니다.

**사용자가 쉼표처럼 구두점을 찍으면 `scanf`은 어떻게 반응하나요?**

간단한 예시를 볼까요? `scanf`을 통해 두 개의 정수짝을 입력받는다고 해봅시다.

```c#
printf("두 개의 숫자를 입력하세요: ");
scanf("%d%d", &i, &j);
```

사용자가 다음과 같이 입력했다고 해봅시다.

> 4, 28

`scanf`은 `4`를 읽고 `i`에 저장하겠죠? 이제 두번째 숫자를 찾아야할텐데, `scanf`은 쉼표를 다음으로 읽게될 거에요. 숫자는 쉼표로 시작하지 않으니까 `scanf`은 즉시 종료되고 반환해요. 쉼표랑 두번째 숫자는 다음 `scanf` 호출을 위해 뒤로 미뤄지게 되죠.

당연히 이러한 문제는 서식문자열에 쉼표를 더해주는 걸로 손쉽게 해결해 줄 수 있어요. 물론, 앞으로는 반드시 쉼표로 입력해줘야 되겠지만요.

```c
printf("두 개의 숫자를 입력하세요: ");
scanf("%d,%d", &i, &j);
```



### 04.Expressions

 C 언어의 특징 중 하나는 바로 구문보다 표현식을 엄청 중시한다는 것이다. 여기서 **표현식이란 어떠한 값을 계산하는 식을 말하는 것이다.** 가장 간단한 형식의 표현식은 바로 **변수와 상수**이다. 변수란 프로그램이 실행되었을 때 계산되는 값을 의미하고, 상수는 변하지 않는 값을 의미한다. 복잡한 표현식에는 피연산자에 연산자를 포함시킨다. 이 때 **피연산자는 자기 자신이 곧 표현식**이다. 표현식 `a + (b * c)`에는 `+` 연산자는 피연산자 `a`와 `(b * c)`에 적용되어있고, 이 **두 피연산자는 자기 자신이 곧 표현식**이기도 하다. **연산자는 표현식을 만드는 기본적인 도구**이다, C 언어는 특이하게도 매우 많은 연산자가 있는 언어이다. 우선 C는 대부분의 프로그래밍 언어가 갖는 기초적인 연산자들이 있다.

- **산술연산자(Arithmetic Operators)** - 덧셈, 뺄셈, 곱셈과 나눗셈을 의미한다.
- **관계연산자(Realtional Operators)**- `i`는 `0`보다 크다"와 같은 **비교** 등을 행할 때 사용하는 연산자이다.
- **논리연산자(Logical Operators)** - `i`는 `0`보다 크고 `i`는 `0`보다 작다"와 같은 **조건을 만드는 데 필요한 연산자**이다.

C는 이 세 가지 이외에도 수많은 연산자들이 있다. 연산자가 너무 많아 이 책의 첫 20단원까지 순서대로 다뤄야할 정도이다. 연산자를 완벽하게 익히는 것은 매우 힘들지만, C를 잘 사용하려면 필수이다.

이 단원에선 C의 가장 중요한 연산자인 산술 연산자(4.1 단원), 할당 연산자(4.2 단원), 증감 연산자(4.3 단원)를 다룰 것이다. 4.1 단원에선 연산자들 사이의 순서 법칙과 결합 법칙을 다룰 것이다. 연산자가 여러 개인 표현식에서 순서와 결합은 매우 중요하다. 4.4 단원에선 C 표현식이 어떻게 평가되는지를 배울 것이다. 마지막으로 4.5 단원에선 표현식 구문을 배울 것이다. 이는 표현식을 구문 취급하는 매우 특이한 기능이다.



#### 4.1 산술연산자

산술 연산자arithmetic operator란 덧셈, 뺄셈, 곱셈, 나눗셈 등을 하는 연산자이다. 산술 연산자는 C를 포함한 대부분의 프로그래밍 언어에서 가장 많이 사용되는 기능 중 하나이다. 표 4.1에서 C의 산술 연산자를 다루고 있다.

| 단항 연산자     | 이항 연산자 |
| :--------- | :----- |
| +  양수임을 강조 | + 덧셈   |
| - 음수 표현    | - 뺄셈   |
|            | * 곱셈   |
|            | / 나눗셈  |
|            | % 나머지  |

**[표 4.1]**

덧셈류와 곱셈류 연산자들은 두 개의 피연산자를 필요로 하기 때문에 이항binary이라고 불린다. 단항unary 연산자는 한 개의 피연산자를 필요로 한다.

```c
i = +1; /* + 는 여기서 단항 연산자로 쓰임 */
j = -1; /* - 는 여기서 단항 연산자로 쓰임 */
```

단항 `+` 연산자는 사실 아무것도 하지 않으며, 사실 K&R C에서도 존재하지 않는다. 이 표현은 그냥 어떤 상수가 **양수임을 강조**하기 위해 사용한다.

이항 연산자는 좀 더 친숙하게 다가올 것이다. 아마 위의 표에서 제일 익숙하지 않은 연산자는 나머지 연산자인 `%` 연산자일 것이다. `i % j`의 값은 `i`를 `j`로 나눴을 때의 나머지이다. 예를 들어 `10 % 3`의 값은 `1`이고 `12 % 4`의 값은 `0`일 것이다.

**[Q&A]** 표 4.1에서 나오는 이항 연산자 중 `%`를 제외하면 정수와 실수형 피연산자를 둘 다 허용하고, 섞어서 사용하는 것 또한 허용한다. 만약 `int`와 `float`형 피연산자가 동시에 사용되었다면 결과는 `float`형으로 나올 것이다. 그렇기 때문에 `9 + 2.5f`의 결과값은 `11.5`이고 `6.7f / 2`의 결과값은 `3.35`이다.

**`/` 연산자와 `%` 연산자는 특수하게 다루어주어야 한다.**

- `/` 연산자는 예상하지 못한 결과를 생성할 수도 있다. 만약 피연산자가 둘 다 정수라면, `/` 연산자는 소수점 부분을 삭제함으로서 결과값을 줄여 정수로 만든다. 즉, `1 / 2`의 값은 `0.5`가 아니라 `0`이 나온다.
- `%` 연산자는 **피연산자가 정수**여야한다. 만약 피연산자가 정수가 아니라면 컴파일되지 않는다.
- `/`이나 `%`를 사용할 때 **`0`을 우항 피연산자**로 사용하는 경우 예상하지 못한 결과가 나올 수 있다.
- **[Q&A]** `/`이나 `%`이 음수 피연산자와 함께 사용하게 되면 결과를 표현해주기가 매우 힘들다. C89 표준에 의하면 두 개의 피연산자 중 하나라도 음수면 나눗셈의 결과값은 반올림 되거나 반내림 될 수 있다고 되어있다. 예를 들면 `-9 / 7`의 값이 `-1`이거나 `-2`가 될 수 있다. 만약 `i`나 `j`가 음수라면 C89에서 `i % j`는 사용하는 방법에 따라 다르다. 예를 들어 `-9 % 7`은 `-2`거나 `5`가 될 수 있다. **[C99]** C99에선 나눗셈의 결과가 언제나 `0`과 가장 가까운 값을 갖는다. 즉 `-9 / 7`의 값은 `-1`이고, `i % j`의 경우 결과값의 부호는 `i`를 따라간다. 즉 `-9 % 7`은 `-2`이다.

> **[시행정의행동]** 시행정의implementation-defined라는 말을 앞으로 많이 듣게 될 것이기에, 이 즈음에서 한 번 다뤄보도록 하겠다. C 표준은 의도적으로 언어의 일부분을 확실하지 않게 남겨두고, "시행implemenation"이라는 것, 즉 소프트웨어가 어떠한 특정 플랫폼에서 컴파일하고, 링크하고, 실행해야할 프로그램을 통해 **그 확실하지 않은 부분을 채운다**. 결과적으로 프로그램의 실행 결과는 시행에 따라 달라질 것이다. C89에서 음수 피연산자를 사용했을 때의 `/`이나 `%`의 결과가 시행으로 정의되는 행동의 예이다.
>
> 언어의 일부를 구체적으로 설명해주지 않는 것은 매우 이상하고 심지어는 위험해보이는 행동이지만, 이는 C의 철학을 보여준다. C 언어의 중요한 목표 중 하나는 효율성이고, 효율성이란 하드웨어에 따라 방법을 맞춰주는 것을 의미하기도 하다. 어떤 CPU는 `-9`가 `7`로 나눠질 때 `-1`를 결과값으로 내보내고, 어떤 CPU는 `-2`로 내보낸다. C89 규격은 그저 인생의 진리를 그대로 보여주고 있을 뿐이다.
>
> 되도록이면 이러한 시행정의행동을 기피하는 것이 좋다. 만약 피할 수 없다면, 적어도 매뉴얼을 잘 살펴보라. C 표준은 시행정의행동을 서류화하고 싶어한다.

**연산자 순서 및 결합 법칙**

한 표현식이 한 개 이상의 연산자를 갖고 있는 경우, 이를 단번에 해석하기란 어려울 수 있다. `i + j * k`라는 구문이 "`i`랑 `j` 더하고, 그 값을 `k`랑 곱하라"는 뜻인지, "`j`랑 `k` 곱하고 거기에 `i`를 더해라"는 뜻인지 어떻게 알 수 있는가? 가장 손쉬운 해결방법은 괄호를 사용하는 것이다. `(i + j) * k`라고 적거나 `i + (j * k)`라고 적어주는 것이다. C 언어는 표현식을 괄호로 묶는 것을 일반적인 규칙으로 허용한다.

만약 괄호를 쓰지 않는다면 어떻게 해야될까? 컴파일러는 `i + j * k`를 `(i + j) * k`로 해석할까 아니면 `i + (j * k)`로 해석할까? 다른 언어들과 마찬가지로 C는 연산자순서 규칙을 정해놓아 이러한 모호함을 해결한다. 산술연산자는 다음과 같은 상대적 순서가 존재한다.

> `순서 높음`

 `+` `-` (단항) 

`*` `/` `%` (이항)

 `+` `-` (이항)

> `순서 낮음`

`+`와 `-`처럼 같은 줄에 있는 연산자들은 동일한 순서이다.

한 표현식에 두 개 이상의 연산자가 존재하는 경우 컴파일러는 높은 순서 연산자부터 시작해서 표현식을 괄호로 계층화해서 해석한다. 다음 예시를 보라.

`i + j * k` 는 `i + (j * k)` 와 같다.

`-i * -j` 는 `(-i) * (-j)` 와 같다. 

`+i + j / k` 는 `(+i) + (j / k)` 와 같다.

연산자 순서 규칙으로는 사실 충분하지 않다. 만약 동일 순서의 연산자들이 여러개가 한 표현식에 존재한다면 어떤식으로 표현식을 처리해야하는가? 이런 상황에서는 연산자의 결합을 사용하게 된다. 왼쪽에서 오른쪽으로 결합한다면 좌향결합적이라고 부른다. 이항산술연산자는 전부 좌향결합적이다. 즉,

`i - j - k` 는 `(i - j) - k` 와 같다. 

`i * j / k` 는 `(i * j) / k` 와 같다.

반대로 오른쪽부터 왼쪽으로 결합한다면 우향결합적이라고 한다. **단항산술연산자가 우향결합**적이다. 즉,

`- + i` 는 `-(+i)`와 동일하다.

순서와 결합 법칙은 물론 많은 언어에서 중요한 개념이지만, 특히나 C 언어에서는 더더욱 중요하다. 단, C 언어엔 50 가지 이상의 연산자가 있어 이에 대한 순서와 결합 법칙을 외우는 프로그래머는 매우 드물다. 차라리 확실하지 않으면 검색을 해서 순서 및 결합 법칙 도표를 참고하거나 괄호를 사용하자.

**[프로그래밍] 세계상품코드(UPC) 검사 기호 계산하기**

몇년간 미국과 캐나다에 제품을 판매하는 제조업자들은 각 제품에 바코드를 찍기 시작했다. 이 코드는 세계상품코드(UPC)라고도 알려져있는데, 제품과 제조업자에 대한 정보를 담고있다. 각 바코드는 12자리의 숫자이며 주로 바코드 선 아래에 적혀있다. 예를 들어 Stouffer's French Bread 페페로니 피자 패키지의 바코드는 다음과 같이 생겼다.

[바코드 사진]

바코드에 적혀있는 숫자인

> 0 13800 15173 5

는 바코드 선 밑에 적혀있다. 첫번째 자리는 제품의 유형을 나타낸다. 대부분의 경우 0 혹은 7이며, 무게를 재야하는 제품의 경우 2, 약이나 건강 관련 제품은 3, 쿠폰은 5이다. 첫 5개의 숫자들은 제조업자를 의미한다. 13800은 네슬리 미국 냉동식품지사를 의미한다. 두번째 5개의 숫자들은 제품을 의미하고, 이는 패키지 사이즈도 포함한다. 마지막 숫자는 "확인자릿수"로, 앞의 11개의 숫자가 제대로 적혀있는지 확인하는 수이다. 만약 UPC가 제대로 스캔이 되지 않았다면 첫 11 개의 숫자들이 마지막 확인자릿수와 무관할 수 있어 상점의 바코드 스캐너는 전체 코드를 인식하지 않을 수 있다.

확인자릿수를 계산하는 방법은 다음과 같다.

1. 홀수번째 숫자를 더한다
2. 짝수번째 숫자를 더한다 (마지막 12번째는 제외)
3. 첫번째 합을 3만큼 곱하고 두번째 합과 더한다
4. 전체 합에서 1을 뺀다
5. 결과값을 10으로 나눴을 때의 나머지를 구한다
6. 9에서 이 나머지를 뺀다

Stouffer's를 이용해 실제 값을 구해보자. 첫번째 합은 0 + 3 + 0 + 1 + 1 + 3 = 8이고, 두번째 합은 1 + 8 + 0 + 5 + 7 = 21이다. 첫번째 합을 3만큼 곱하고 두번째 합과 더하면 45가 나온다. 여기에 1을 빼면 44가 된다. 10으로 나눈 나머지는 4이다. 이 나머지를 9에 빼면 답은 5가 나온다. 아래는 다른 UPC의 예시이다. 만약 직접 확인자릿수를 계산해보고 싶다면 해보라.

Kif Creamy 땅콩버터(18 oz.): 0 51500 24128 ? Ocean Spray 크랜베리젤리소스(8 oz): 0 31200 01005 ?

정답은 8과 6이다.

이제 아무 UPC의 확인자릿수를 계산해주는 프로그램을 작성해보자. 우선 사용자로 하여금 11자리의 숫자를 입력하도록 하고, 이에 해당하는 확인자릿수를 출력해준다. 혼동을 피하기 위해 사용자는 첫번째 숫자, 두번째 5자리 숫자, 세번째 5자리 숫자를 따로따로 세 가지의 값을 입력하게 만든다. 이 프로그램이 다음과 같이 생겼다고 해보자.

> 첫번째 (한자리수) 숫자를 입력해주세요: 첫번째 (한자리수) 숫자를 입력해주세요: 0
> 첫번째 다섯자리 숫자를 입력해주세요: 13800
> 두번째 다섯자리 숫자를 입력해주세요: 15173
> 확인자릿수: 5

두 다섯자리 숫자를 정말로 다섯자리 숫자로 인식하는 것보다는 다섯개의 서로 다른 숫자의 모임으로 인식하도록 하겠다. 숫자를 한 자리 숫자들로 인식하는 것이 사실 더 편하고 다섯자리 숫자는 몇몇 오래된 컴파일러에겐 저장하기에 너무 클 수 있기 때문(정수형이 32,767이 최대일 수도 있다)에 이렇게 해주는 것이 더 좋다. 한 자리만 읽기 위해선 `scanf`와 `%1d` 변환규격을 사용하겠다.

`upc.c`

```c
/* UPC의 확인자릿수를 계산함 */

#include <stdio.h>

int main(void)
{
    int d, i1, i2, i3, i4, i5, j1, j2, j3, j4, j5, 
        first_sum, second_sum, total;

    printf("첫번째 (한자리수) 숫자를 입력해주세요: ");
    scanf("%1d", &d);
    printf("첫번째 다섯자리 숫자를 입력해주세요: ");
    scanf("%1d%1d%1d%1d%1d", &i1, &i2, &i3, &i4, &i5);
    printf("두번째 다섯자리 숫자를 입력해주세요: ");
    scanf(%1d%1d%1d%1d%1d", &j1, &j2, &j3, &j4, &j5);

    first_sum = d + i2 + i4 + j1 + j3 + j5;
    second_sum = i1 + i3 + j2 + j4;
    total = 3 * first_sum + second_sum;

    printf("확인자릿수: %d\n", 9 - ((total - 1) % 10));

    return 0;
}
```

표현식 `9 - ((total - 1) % 10)`을 `9 - (total - 1) % 10`으로 적을 수 있음에도 굳이 괄호를 추가해주었다. 이렇듯 괄호는 가독성을 높여준다.

#### 4.2 할당연산자

표현식의 값이 계산된 다음엔 그 값을 변수에 저장해서 나중에 사용해야한다. C 언어에서 **단순할당simple assignment**을 해주는 `=` 연산자가 여기에 사용된다. 이미 변수에 저장된 값을 바꾸는 데에는 복합할당연산자를 사용하면 된다.

**단순할당**

할당 `v = e`는 표현식 `e`를 처리하고, 그 값을 복사하여 `v`에 저장한다는 의미이다. 아래 예시가 말해주듯 `e`는 상수, 변수, 혹은 복잡한 표현식이 될 수 있다.

```c
i = 5;            /* i의 값은 5이다  */
j = i;            /* j의 값은 5이다  */
k = 10 * i + j;   /* k의 값은 55이다 */
```

만약 `v`와 `e`가 같은 형이 아니라면 할당이 되는 순간 `e`의 값은 `v`의 형에 알맞게 변환한다.

```c
int i;
float f;

i = 72.99f;    /* i의 값은 72이다    */
f = 136;       /* f의 값은 136.0이다 */
```

형변환은 나중에 좀 더 구체적으로 다루겠다.

대부분의 프로그래밍 언어에서 할당은 *구문statement*이다. C 언어에선 이와 달리 할당은 `+`와 같이 연산이다. 즉, 값 두 개를 더하면 그 합이라는 결과가 나오듯 할당도 결과를 만들어 낸다. 할당 `v = e`의 값은 할당 이후의 `v`의 값이다. 즉, `i = 72.99f`의 값은 72.99가 아닌 72이다.

> **부작용**
>
> 보통 연산자를 사용할 때 연산자가 피연산자를 바꾼다고 생각하지는 않는다. 수학에서의 연산이 그러하지 않는가. `i + j`는 `i`나 `j`의 값을 변화시키지 않는다. 그저 `i`와 `j`의 값을 더할 뿐이다.
>
> 대부분의 C언어 연산자들은 피연산자의 값을 변화시키지 않으나, 변화시키는 연산자들도 있다. 이러한 연산자들은 단순히 연산만 하는 것이 아니기 때문에 **부작용side effect**이 있다고 이야기한다. 단순할당연산자가 우리가 첫번째로 만난 부작용이 있는 연산자이다. 단순할당연산자는 왼쪽에 있는 피연산자의 값을 변화시킨다. 표현식 `i = 0`은 0이라는 결과값을 생성하고, 부작용에 일환으로 0을 `i`에 저장한다.

**왼쪽값**

대부분의 C 연산자들은 피연산자가 변수, 상수 혹은 다른 연산자를 포함하고 있는 표현식일 수 있다. 할당연산자는 허나 **왼쪽 값lvalue**라는 것이 좌측 피연산자로서 반드시 존재해야한다. **[Q&A]** 왼쪽값은 컴퓨터 메모리에 저장되는 객체를 의미한다. 즉, 상수도 아니고, 계산의 결과값도 아니다. 변수는 왼쪽값이지만 `10`이나 `2 * i`와 같은 표현식은 왼쪽값이 아니다. 당장 우리가 아는 선에선 변수만이 왼쪽값이다. 변수 이외의 왼쪽값은 추후 단원에서 다룬다.

할당연산자가 좌피연산자로 왼쪽값을 필요로 하기 때문에 왼쪽값이 아닌 표현식을 할당연산자의 좌피연산자로 사용할 수 없다.

```c
12 = i;       /*** 틀림 ***/
i + j = 0;    /*** 틀림 ***/
-i  = j;      /*** 틀림 ***/
```

컴파일러는 이와 같은 에러를 발견하여 "invalid lvalue in assignment"와 같은 에러 메세지를 출력할 것이다.

**복합할당**

한 변수를 그 변수를 이용하여 새로운 값을 변수에 할당하기 위해 사용되는 할당은 C에서 자주 사용되는 할당이다. 다음 구문을 보자. `i`의 값에 2를 더하고 싶다고 하자.

```c
i = i + 2;
```

C의 **복합할당compound assignment** 연산자는 위와 같은 코드를 줄여준다. `+=` 연산자를 통해 위의 코드를 간단하게 다음과 같이 쓸 수 있다.

```
i += 2;    /* i = i + 2 와 같다 */
```

`+=` 연산자는 우피연산자의 값을 왼쪽에 있는 변수에 더해준다.

복합할당연산자는 총 아홉개이며, 아래와 같은 연산자들이 존재한다.

`-=`,  `*=`, `/=`, `%=`

이 이외의 복합할당연산자는 추후 단원에서 다루도록 하겠다. 다른 복합할당연산자들도 위의 예시와 동일한 성격으로 작동한다.

- `v += e` `e`에 `v`를 더하고 그 값을 `v`에 저장한다.
- `v -= e` `v`에서 `e`를 빼고 그 값을 `v`에 저장한다.
- `v *= e` `v`를 `e`만큼 곱하고 그 값을 `v`에 저장한다.
- `v /= e` `v`를 `e`로 나누고 그 값을 `v`에 저장한다.
- `v %= e` `v`를 `e`로 나누었을 때의 나머지를 `v`에 저장한다.

`v += e`와 `v = v + e`는 엄연히 다른 구문이다. 두 구문이 같지 않은 이유는 우선 연산순서 문제가 있다. `i *= j + k`는 `i = i * j + k`가 아니다. 이 뿐만 아니라 `v` 자체에 부작용이 있어 `v += e`와 `v = v + e`가 서로 다른 경우가 있다. 이는 다른 복합할당연산자에도 해당하는 주의점이다. **[Q&A]**

> **[!!!]**
>
> 복합할당연산자를 사용할 때 연산자를 구성하는 두 연산자를 서로 혼동하지 않도록 하자. 두 문자를 바꾸면 컴파일러한테는 상관 없지만 의도한 의미를 잃게 된다. 예를 들어 `i += j`라고 적어야하는데 `i =+ j`라고 적었다고 가정해보자. 프로그램은 정상적으로 컴파일은 될 것이지만 후자 표현식은 `i = (+j)`와 같은 의미이므로 사실상 `i`에 `j`의 값을 할당하는 것이다.

복합할당연산자는 `=` 연산자와 같은 순서를 가진다. 또한 우향결합적이다. 즉, 구문

```
i += j += k;
```

은 다음과 같다.

```
i += (j += k);

```



#### 4.3 증감연산자

변수에 가해지는 가장 흔한 두 가지 연산은 1을 더하는 "증가"과 반대로 1을 빼는 "감소" 연산이다. 물론 이러한 연산을 다음과 같이 행할 수 있다.

```
i = i + 1;
j = j - 1;

```

복합할당연산자를 활용하여 코드를 좀 더 압축할 수 있다.

```
i += 1;
j -= 1;

```

C 언어에서는 이러한 증감을 더 간단하게 표현할 수 있게 해준다. 바로 **증가increment**연산자 `++`와 **감소decrement**연산자 `--`를 통해서이다. **[Q&A]**

한 눈에 증감연산자는 매우 간단하다는 것을 알 수 있다. `++`는 피연산자에 1을 더하고 `--`는 1 을 뺀다. 불행하게도 증감연산자는 그 단순함에 비해 사용하기 까다롭다. 한 가지 복잡함이 발생하는 이유는 `++`와 `--`이 `++i`나 `--j`처럼 **전위prefix**연산자로 쓰이거나 `i++`나 `j--`처럼 **후위postfix**연산자로 사용될 수 있다는 것이다. 알맞은 버전을 찾아야 프로그램의 정확성이 보장된다.

또다른 문제는 할당연산자처럼 `++`와 `--`는 부작용이 있다. 즉 피연산자의 값을 바꾼다. "우선증가"인 표현식 `++i`를 해석해보면 `i + 1`을 `i`로 넘기는데, 부작용에 의해 `i`의 값이 증가된다.

```
i = 1;
printf("i의 값은 %d\n", ++i);    /* "i의 값은 2"를 출력한다. */
printf("i의 값은 %d\n", i);      /* "i의 값은 2"를 출력한다. */

```

"이후증가" 표현식인 `i++`은 결과값 `i`를 내보내지만 이후에 `i`는 증가된다.

```
i = 1;
printf("i의 값은 %d\n", i++);    /* "i의 값은 1"를 출력한다. */
printf("i의 값은 %d\n", i);      /* "i의 값은 2"를 출력한다. */

```

첫번째 `printf`은 `i`가 증가되기 이전 본래 값을 출력했다. 두번째 `printf`은 새 값을 출력했다. 위의 예시들이 보여주듯 `++i`는 "당장 증가해"라는 뜻이고, `i++`는 "지금은 원래 값 쓰고 나중에 증가해"라는 뜻이다. 그렇다면 나중에가 언제일까? C 표준은 정확한 시간을 명시해놓고 있지 않다. 그렇기 때문에 `i`는 다음 구문이 실행되기 이전에 증가된다고 생각하는 것이 안전하다. **[Q&A]**

`--` 연산자는 비슷한 속성을 갖고 있다.

```
i = 1;
printf("i의 값은 %d\n", --i);    /* "i의 값은 0"를 출력한다. */
printf("i의 값은 %d\n", i);      /* "i의 값은 0"를 출력한다. */
i = 1;
printf("i의 값은 %d\n", i--);    /* "i의 값은 1"를 출력한다. */
printf("i의 값은 %d\n", i);      /* "i의 값은 0"를 출력한다. */

```

`++`나 `--`이 같은 표현식에서 여러 번 사용한 결과는 대부분 이해하기가 어렵다. 다음 구문을 예시로 들어보자.

> i = 1;
> j = 2;
> k = ++i + j++;

이 구문이 실행된 이후 `i`, `j`와 `k`의 값은 얼마일까? `i`는 쓰이기 이전에 증가 됐고 `j`는 사용된 다음에 증가되었으므로 다음과 같다.

> i = 1 + 1;
> k = i + j;
> j = j + 1;

즉 `i`, `j`와 `k`의 값은 순서대로 2, 3, 4이다. 반대로 다음 구문을 실행한다고 해보자.

> i = 1;
> j = 2;
> k = i++ + j++;

다음 구문에 의하면 `i`, `j`, `k`는 순서대로 2, 3, 3이다.

연산자의 순서를 확인해보자면 `++`와 `--`의 **후위연산자는 단항연산자보다 더 순서가 삐르며** **좌향결합적**이다. **전위연산자는 단항연산자와 같은 순서를 가지며 우향결합적**이다.

#### 4.4 표현식 평가

| 순서   | 이름           | 기호                                                    | 결합방향 |
| :--- | :----------- | :---------------------------------------------------- | :--- |
| 1    | 증감(후위)       | `++`<br />`--`                                        | 좌향   |
| 2    | 증감(전위), 단항음양 | `++`<br />`--`<br />`+`,<br />`-`                     | 우향   |
| 3    | 곱셈           | `*`,<br />`/`<br />`%`                                | 좌향   |
| 4    | 덧셈           | `+`<br /> `-`                                         | 좌향   |
| 5    | 할당           | `=`<br />`*=`<br />`/=`<br />`%=`<br />`+=`<br />`-=` | 우향   |

[표 4.2] 일부 C 연산자 표

[표 4.2]는 현재까지 다룬 연산자들을 전부 다루고 있다. 부록 A에서 모든 연산자를 다루는 표를 확인해볼 수 있다. 첫번째 열은 연산자 평가 순서를 의미한다. 마지막 열은 각 연산자의 결합 방향을 의미한다.

[표 4.2] 혹은 부록 A의 표를 통하여 연산자를 다양하게 사용해볼 수 있다. 이제 아래의 예시를 한 번 보도록 하자. 아래와 같이 복잡한 표현식을 실행해본다고 하자.

```c
a = b += c++ - d + --e / -f

```

이 표현식은 괄호가 없어 가독성이 상당히 떨어진다. [표 4.2]를 이용하여 이 표현식에 괄호를 붙여보도록 하겠다. 우선 순위가 높은 것부터 시작해서 괄호로 연산자와 피연산자를 묶어주어 마치 하나의 피연산자로 처리하겠다. 이 과정을 표현식이 완벽하게 처리될 때까지 반복하겠다.

본 예시에서 가장 우선 순위를 띠는 연산자는 후위 `++` 연산자이다. 괄호를 추가해주자.

```c
a = b += (c++) - d + --e / -f

```

다음은 전위 `--` 연산자와 단항음수연산자이다.

```c
a = b += (c++) - d + (--e) / (-f)

```

다른 음수 기호는 왼쪽에 피연산자가 있어 단항음수연산자가 아닌 뺄셈연산자임을 인식해야한다.

다음은 `/` 연산자이다.

```c
a = b += (c++) - d + ((--e) / (-f))

```

이 표현식엔 4 순서 연산자 뺄셈과 덧셈 두 개를 포함하고 있다. 두 연산자가 같은 순서를 갖고 한 피연산자를 공유하고 있다면, 결합성에 유의해야한다. 우리의 예제에선 `-`와 `+` 둘 다 `d`를 공유하고 있으므로 결합방향을 고려해야한다. `-`와 `+` 연산자는 왼쪽에서 오른쪽으로 결합을 하므로 괄호는 뺄셈 먼저, 그 뒤에 덧셈을 처리한다.

```
a = b += (((c++) - d) + ((--e) / (-f)))

```

마지막으로 `=`와 `+=`를 처리해주자. 두 연산자는 서로 `b`를 공유하고 있으므로 결합방향을 확인해주자. 할당연산자는 오른쪽에서 왼쪽으로 괄호로 묶으므로 `+=`로 먼저 묶고 다음에 `=`로 묶는다.

```
(a = (b += (((c++) - d) + ((--e) / (-f)))))

```

이제 표현식이 완벽하게 괄호로 묶였다.

**값을 표현할 때의 부분식의 순서**

C 언어에선 연산자 순서 및 결합법칙을 이용하여 표현식을 부분식으로 나눌 수 있다. 이 부분식은 괄호의 위치를 이용하여 생성할 수 있다. 모순적이게도 이 법칙이 언제나 표현식의 값을 결정하지 않는다. 이는 부분식이 어떤 순서로 평가되는지에 따라 달라질 수 있다.

C는 부분식이 어떤 순서로 평가되는지 정의하지 않는다. (이는 논리연산자 and, or, 조건 및 쉼표연산자를 제외한다) 즉 표현식 `(a + b) * (c - d)`의 식에선 `(a + b)`가 먼저 평가되는지 `(c - d)`가 먼저 평가되는지 모른다.

대부분의 표현식은 부분식이 평가되는 순서와 상관없이 같은 값을 갖는다. 허나 부분식이 피연산자를 수정하는 경우 이는 달라질 수 있다. 다음 예시로 확인해보자.

```
a = 5;
c = (b = a + 2) - (a = 1);

```

두번째 구문의 실행은 정의되지 않는다. C 표준을 뒤져봐도 이에 대한 해답은 나오지 않는다. 대부분의 컴파일러의 경우 `c`의 값은 6이거나 2일 것이다. 만약 부분식 `(b = a + 2)`를 먼저 평가했다면 `b`는 7이고 `c`는 6이다. 하지만 `(a = 1)`를 먼저 평가했다면 `b`는 3이고 `c`는 2이다.

> **[!!!]**
>
> 표현식 내에서 변수의 값에 접근하고 수정하는 과정이 일어나는 표현식은 지양하는 것이 좋다. 표현식 `(b = a + 2) - (a = 1)`에서 `(a + 2)`를 처리해주기 위해 `a`의 값에 접근하고 이 뿐만 아니라 `a`에 1을 할당해주어 `a`의 값을 바꾸기가지 한다. 몇몇 컴파일러는 위와 같은 표현식을 받으면 "`a`에 대한 작업이 정의되지 않았을 수도 있다"라는 경고 메세지를 생성해낼 수도 있다.

이러한 문제를 방지하기 위해 부분식에선 할당연산자를 지양하는 것이 좋다. 할당을 한 줄에서 진행하지 않고 여러 줄에 걸쳐 진행하는 것이 좋다. 위의 코드는 다음과 같이 다시 짤 수 있다.

```c
a = 5;
b = a + 2;
a = 1;
c = b - a;

```

본 표현식이 실행되면 `c`의 값은 언제나 6일 것이다.

할당연산자 이외에 피연산자의 값을 수정하는 연산자는 증감연산자다. 이 연산자를 사용할 땐 표현식의 평가가 어떤 특정 순서를 따르지 않는다는 사실을 명심해야한다. 다음 예시에선 `j`의 값이 두 가지가 나올 수 있다.

```c
i = 2;
j = i * i++;

```

`j`의 값이 4라고 생각하기 십상이지만, 구문이 실행될 때의 절차는 정의되지 않았으므로 `j`에 6이 할당될 수도 있다. 6이 나오는 절차는 다음과 같다. (1) 두번째 피연산자인 `i`의 본래 값을 선택하고 `i`를 증가한다. (2) 첫번째 피연산자인 새로운 `i`의 값이 선택되고 본래 `i`값과 곱해진다. (3) 본래 값과 새 값이 곱해지고 결과는 6이 나온다. 변수를 "선택한다Fetching"는 것은 메모리로부터 변수의 값을 갖고 오는 것을 의미한다. 나중에 변수에 가해진 변화는 선택된 값에 영향을 주지 않는다. 여기서 선택된 값은 보통 **레지스터register**라고 불리는 CPU 내의 특수한 공간에 보관된다.

> **정의되지 않은 행동 / 불능행동**
>
> C 표준에 의하면 `c = (b = a + 2) - (a = 1);`와 `j = i * i++;`와 같은 표현식은 **불능행동undefined behavior**을 초래한다고 한다. 여기서 불능행동은 4.1절에서 다뤘던 시행정의행동과는 다르다. 프로그램이 불능행동의 세계로 떠나게 된다면 거기서 벌어질 일들은 예측할 수 없다. 프로그램이 컴파일러마다 서로 다른 결과값을 내놓을 것이다. 헌데 이것만 일어나는 것도 아니다. 애초에 컴파일 자체가 안되거나, 컴파일은 되는데 실행이 안될 수도 있고, 실행이 되더라도 오류로 프로그램이 중단되거나, 이상하게 행동하거나, 의미없는 값만 내보낼 수도 있다. 다시말해 불능행동은 마치 역병처럼 피해야하는 것이다.

#### 4.5 표현문

C에선 모든 표현식은 구문으로 사용될 수 있다는 특이한 규칙이 있다. 즉, 무슨 형식이든, 무슨 값을 처리하든 모든 표현식에 세미콜론`;`을 추가함으로써 구문으로 만들어줄 수 있다는 것이다. 예를 들어 표현식 `++i`를 구문으로 다음과 같이 바꿔줄 수 있다.

```c
++i;

```

이 구문이 실행되면 `i`는 증가되고, 증가된 새로운 `i`의 값이 마치 다음 표현식에 사용되려는 듯이 선택된다. 허나 `++i`는 더 큰 표현식의 부분식이 아니기 때문에 선택된 값은 버려지고 다음 구문이 실행될 것이다. 물론 바뀐 `i`의 값은 그대로 유지될 것이다. **[Q&A]**

`++i`의 선택된 값이 무시되었기 때문에 표현식이 부작용이 있지 않는 한 굳이 표현식을 구문처럼 사용할 필요성이 없다. 다음 세 가지 예시를 살펴보자. 첫번째 예제에선 `i`에 1을 저장해주었다. 그 뒤 `i`의 새로운 값인 1이 선택되지만 아무데도 사용되지 않는다.

```c
i = 1;

```

두번째 예제에선 `i`의 값이 선택되지만 사용되지 않는다. 하지만 `i`는 그 다음에 감소된다.

```c
i--;

```

세번째 예제에선 표현식 `i * j - 1`의 값이 계산되고, 그 이후에 버려진다.

```c
i * j - 1;

```

`i`와 `j`는 바뀌지 않았기 때문에 이 구문은 아무 영향이 없으므로 아무 의미가 없는 구문이다.

> **[!!!]**
>
> 코딩하다가 손가락 잘못 놀리면 "아무 의미 없는" 표현문expression statement이 만들어진다. 예를 들어
>
> ```c
> i = j;
> 
> ```
>
> 라고 작성하지 않고 실수로
>
> ```c
> i + j;
> 
> ```
>
> 라고 실수로 작성할 수도 있다. 이러한 실수는 생각보다 자주 발생한다. `=`와 `+`가 같은 키보드 키이기 때문에 발생하는 실수다. 몇몇 컴파일러는 무의미한 표현문을 감지할 수 있다. "무의미한 구문statement with no effect"이라고 적힌 에러를 발생시킨다.

#### Q & A

**C 언어는 지수연산자가 없던데 그러면 제곱연산을 할 수 있죠?**

정수를 작은 양의 정수만큼 제곱하는 건 쉬워요. 그만큼 곱해주면 되거든요. 예를 들어 `i` 세제곱을 하려면 `i * i * i`를 하면 돼요. 근데 만약 정수가 아닌 숫자만큼 제곱을 할거면 `pow`라는 함수가 필요할거예요.

**`%` 연산자를 고정소수 피연산자에도 적용하고 싶은데 컴파일이 안되네요. 어떻게 해야하죠? [산술연산자]**

`%` 연산자는 정수 피연산자를 필요로 해요. 차라리 `fmod`를 써보는 건 어때요?

**`/`와 `%` 연산자를 음수연산자랑 같이 사용하는 규칙이 왜 그리 복잡한가요? [산술연산자]**

사실 그렇게 복잡하지는 않아요. C89나 C99 둘 다 목표는 `(a / b) * b + a % b`의 값이 언제나 `a`와 같도록 하는거에요. 그리고 두 표준 모두 `a / b`가 정상representable이면 위의 상황은 언제나 성립해요. 문제는 `a / b`랑 `a % b`가 만약 둘 중 하나라도 음수면 위의 항등식을 만족시키는데 두 가지 방법이 있다는 거예요. C89에서 `-9 / 7`는 `-1` 이거나 `-2`이고 `-9 % 7`는 `-2`이거나 `5`이었잖아요? 첫번째 경우 `(-9 / 7) * 7 + -9 % 7`의 값은 -1 × 7 + -2 = -9이고, 두번째 경우엔 `(-9 / 7) * 7 + -9 % 7`가 -2 × 7 + 5 = -9라는 값이 나와요. **[C99]** C99이 나왔을 즈음엔 대부분의 CPU가 위와 같은 상황일 땐 값을 0과 가까운 값으로 선택하게 설계되었어요. 그러므로 C99엔 오로지 한 가지 결과만 나오죠.

**C가 왼쪽값이 있다면, 오른쪽값도 있나요? [왼쪽값]**

암요. 왼쪽값은 할당의 왼쪽에서 나타날 수 있는 표현식을 의미하고, 오른쪽값은 반대로 오른쪽에서 나타날 수 있는 표현식이에요. 즉, 오른쪽값은 변수, 상수, 혹은 좀 더 복잡한 표현식이 될 수 있겠죠? 이 책에서는 C 표준대로 오른쪽값이 아니라 표현식이라는 용어를 사용할 거예요.

**`v`가 부작용이 있으면 `v += e`가 `v = v + e`와 동일하지 않다고 했는데, 이게 무슨 뜻인가요? [복합할당]**

`v += e`를 평가할 때엔 `v`가 딱 한 번 평가가 돼요. 반면에 `v = v + e`에선 `v`를 두 번 평가해야되죠. `v`를 평가할 때 발생하는 모든 부작용은 후자의 경우에 두 번 발생하겠죠? 다음 예시를 볼까요?

```c
a[i++] += 2;

```

`+=` 대신에 `=`를 사용한다면 다음과 같이 코드를 짤 수 있을겁니다.

```c
a[i++] = a[i++] + 2;

```

`i`의 값은 구문에서변형이 되면서 동시에 구문에서 사용되고 있어요. 즉, 구문을 실행한 효과는 정의되지 않았어요. `i`의 값이 두 번 증가될 거라고 예상할 수는 있겠지만, 확실히 무슨 일이 일어날지는 모르는거예요.

**C가 굳이 `++`와 `--` 연산자를 제공하는 이유가 뭐죠? 다른 증감연산보다 더 빠른가요? 아니면 그냥 편의인가요? [증감연산자]**

C의 증감연산자는 켄 톰슨의 B 언어로부터 이식된 거예요. 톰슨이 이러한 연산자를 만든 이유는 B 컴파일러가 `i = i + 1`보다 `++i`에 대해 좀 더 구체적인 번역이 가능해서예요. 이 연산자들은 C에 그대로 이식이 되었죠. 사실 많은 C 관련 관용구들도 여기서 많이 생겼어요. 요즘 컴파일러에서 사실 `++`나 `--`를 쓴다고 해서 컴파일된 프로그램이 더 빨라지거나 용량을 적게 만들어주지는 않아요. 아직도 이 연산자를 사용하는 이유는 사실 사용하기 편해서죠.

**`++`랑 `--`는 `float` 변수에도 적용되나요?**

그럼요. 증감연산자는 정수 뿐만 아니라 고정소수에도 적용돼요. 하지만 실생활에선 `float` 변수를 증감하는 건 그렇게 자주 사용하지는 않아요.

**`++`와 `--`를 후위로 사용할 때 정확하게 언제 증감이 적용되는거죠? [증감연산자]**

엄청 훌륭한 질문이네요! 근데 답하기는 사실 어려운 질문이기도 해요. C 표준에 의하면 C 언어에는 "순서지점sequence point"이라는 개념이 있는데요, 피연산자에 저장된 값을 바꾸는 건 이전 순서 지점이랑 그 다음 순서 지점 중간에 이뤄진다고 해요. C에는 수많은 순서지점들이 있는데요, 한 예로는 표현문의 끝 지점을 들 수 있어요. **표현문이 끝날 때**가 되면 반드시 그 구문에 있는 증감연산은 전부 실행이 되었어야 합니다. 이게 실행이 안되면 그 다음 구문이 실행이 안돼요.

나중에 우리가 다룰 몇가지 연산자들(논리곱, 논리합, 조건, 쉼표) 또한 순서지점을 갖고 있어요. 함수호출도 마찬가지로 갖고 있어요. 함수호출을 할 때 입력변수argument가 완벽하게 평가되지 않는 한 함수호출은 실행되지 않아요. 만약 **입력변수가 `++`나 `--` 같은 연산자가 있는 표현식이라면 증감연산이 실행되기 전까지 함수호출은 실행되지 않아요.**

**표현문의 값이 버려진다는 게 정확히 무슨 뜻인가요? [표현문]**

정의에 의하면 표현식은 값을 나타낸다고 해요. 만약 `i`가 5라는 값을 갖고 있다고 합시다. 그러면 `i + 1`를 평가하면 6이라는 값을 생성해낼거예요. 그럼 이 `i + 1` 뒤에 세미콜론을 넣어서 구문으로 만들어 볼게요.

```c
i + 1;

```

이 구문이 실행이 되면 `i + 1`의 값이 계산이 될거예요. 근데 계산한 이 값을 어디에 저장하지도, 어딘가에 사용하지도 않았으니까 그 값은 버려지겠죠.

**그럼 `i = 1;`와 같은 구문은요? 얘네들도 값이 버려지는건가요?**

C에선 `=`도 연산자라는 것을 까먹으면 안돼요. 즉, 연산자이기 때문에 다른 연산자들이 그러듯, 값을 생성해내요. 예시로 직접 보죠.

```c
i = 1;

```

위 할당에 의하면 `i`에 1을 저장하겠죠? 여기서 전체 구문의 값은 1이 되고, 이 값은 버려지게되죠. 표현식의 값을 버리는 건 크게 문제되는 부분이 아니예요. 애초에 저 구문을 적는 이유는 `i`의 값을 수정하려고 작성한거지, 구문의 값을 어디 써먹으려고 작성한건 아니잖아요?



### 05. Selection Statements

#### 5.1 논리 표현식

- **대소 비교는 좌항결합적이다.**

  C언에서 `i < j < k`와 같은 표현식은 구문상 문제될 것은 없다. 다만 실제로 평가했을 때 우리가 의도했던 의미와는 다른 결과가 나온다. **`<` 연산자가 좌향결합적**이기 때문에 위의 표현식은 다음과 같다.

  ```
  (i < j) < k
  ```

  즉, 이 표현식은 우선 `i`가 `j`보다 작은지 평가한다. 그렇게 되면 이 표현식은 `k`가 0 또는 1보다 큰지를 평가하는 식이 된다. 그렇기 때문에 `j`가 `i`보다 크고 `k`보다는 작다는 것을 위와 같이 표현해줄 수 없다. (추후에 배울 개념을 사용한다면, 올바른 식은 `i < j && j < k`이다.)

- **몇몇 똑똑한 프로그래머들은 관계연산자와 동등연산자가 정수값을 반환한다는 점에서 착안해서 다양한 표현식을 만들어낸다.**

   `(i >= j) + (i == j)`은 `i`가 `j`보다 작거나, 크거나, 같느냐에 따라 순서대로 0, 1이거나 2를 값으로 갖는다. 이런 복잡한 코드는 일반적으로 좋은 생각은 아닐 뿐더러 프로그램의 가독성을 떨어뜨린다.

  또는 ,표현식 i < j == j < k 은 다음과 같다.

  ```
  (i < j) == (j < k)
  ```

  `i < j`와 `j < k` 둘이 동시에 참이거나 거짓이라면 위의 표현식은 참이다.

- **&& 나 ||연산자는 왼쪽 피연산자를 우선 평가 하고 더이상 평가할 의미가 없으면 오른쪽 피연산자를 연산하지 않는다.**

  ```c++
  (i != 0) && (j / i > 0)
  ```

  이 표현식의 값을 알려면 우선 왼쪽 피연산자인 `(i != 0)`을 평가해야한다. `i`가 0과 같지 않다면 `(j / i > 0)`을 평가해서 전체 표현식이 참인지 거짓인지 판별해야한다. 하지만 만약 `i`가 0이라면 전체 표현식은 거짓이므로 오른쪽 피연산자인 `(j / i > 0)`을 평가할 필요가 없다. 단락식 평가는 여러모로 유용하다. 만약 단락식 평가가 아니었다면 위의 표현식에서 오른쪽 피연산자에서는 값을 0으로 나누는 에러가 발생했을 것이다.

  논리표현식을 잘못 사용하면 부작용이 발생할 수도 있다. 다행히도 `&&`과 `||`은 단락성을 가지므로 피연산자에서 발생하는 부작용을 피할 수 있다. 다음 표현식을 예로 들겠다.

  ```
  i > 0 && ++j > 0
  ```

  표현식을 평가할 때의 부작용으로 `j`는 증가되겠지만, 여기선 부작용이 발생하지 않는다. 만약 `i > 0`이 거짓이라면 `++j > 0`은 평가되지 않기에 **`j`는 증가되지 않는다.** 만약 무조건 증가시키고 싶다면 피연산자의 순서를 바꾸어 `++j > 0 && i > 0`로 표현식을 변경하면 된다. 물론, 아예 `j`를 따로 증가시키는게 더 좋은 방법이다.

#### 5.2 if문

- **조건 표현식 ( 비교 ? 참 :  거짓)**

  **조건표현식**은 프로그램을 간결하게 해주지만 가독성을 떨어뜨릴 수 있다. 그렇기 때문에 사용하지 않는 것이 좋지만, 특정 경우에선 사용하는 것이 간편할 수 있다. 대표적인 예시가 `return`문이다.

  ```c
  if (i > j)
      return i;
  else
      return j;
  ```

  대부분의 프로그래머들은 위보다는 아래처럼 코드를 작성한다.

  ```c
  return i > j ? i : j;
  ```

  `printf` 함수 또한 조건표현식을 사용함으로써 상당히 간편하게 코드를 짤 수 있다.

  ```c
  if (i > j)
      printf("%d\n", i);
  else
      printf("%d\n", j);
  ```

  위와 같이 작성하기 보다는 다음과 같이 간단하게 작성할 수 있다.

  ```c
  printf("%d\n", i > j ? i : j);
  ```

  조건표현식은 특정 매크로정의에서도 자주 사용된다.

#### 5.3 Switch문

- **`case` 다음엔 반드시 한 개의 상수식만 올 수 있지만 여러 개의 조건부호들이 다음 예시처럼 같은 구문을 공유할 수 있다.**

  

  ```c
  switch (grade) {
      case 4:
      case 3:
      case 2:
      case 1:  printf("좋지 않아요!");
               break;
      case 0:  printf("좀 더 노력하세요!");
               break;
      default: printf("잘못된 학점입니다");
               break;
  }
  ```

  좀 더 공간을 아끼려고 중복되는 조건부호들을 한 줄에 놓기도 한다.

  ```c
  switch (grade) {
      case 4: case 3: case 2: case 1:
               printf("좋지 않아요!");
               break;
      case 0:  printf("좀 더 노력하세요!");
               break;
      default: printf("잘못된 학점입니다");
               break;
  }
  ```

  아쉽게도 다른 프로그래밍 언어처럼 일정 범위를 조건부호로 나타낼 수는 없다.

#### Q&A

- **제 컴파일러는 `==` 대신 `=`를 써도 경고 메세지를 출력하지 않던데, 컴파일러가 이런 점을 강제로 경고로 알려주게 만들 수 있나요? [if문]**

  몇몇 프로그래머들이 사용하는 방법이 있죠.

  ```c
  if (i == 0) ...
  ```

  이렇게 작성 안하고

  ```c
  if (0 == i) ...
  ```

  이렇게 습관적으로 작성해요. 그 다음에 `==` 연산자를 실수로 `=`로 작성했다고 해봅시다.

  ```c
  if (0 = i) ...
  ```

  이러면 0에 값을 할당할 수 없기에 컴파일러가 에러 메세지를 낼거에요. 사실 전 이 방법을 사용하진 않아요. 프로그램이 상당히 비정상적으로 보이거든요. 그리고 조건의 한 피연산자가 왼쪽값이 아닐 때 밖에 쓸 수 있어요.

  다행히도 대부분의 컴파일러는 `=` 연산자를 `if`문에서 잘못 사용한 경우를 잡아줘요. 예를 들어 GCC 컴파일러는 `-Wparentheses` 기능 혹은 `-Wall`(모든 경고 메세지 표시) 기능으로 위 경우를 잡아줄 수 있어요. GCC를 사용할 때 만약 의도적으로 `=` 연산자를 써준 경우 괄호를 두 번 해주면 경고 메세지가 뜨지 않게 해줄 수 있어요.

  ```c
  if ((i = j)) ...
  ```



### 06. Loops

#### 6.3for문

- **쉼표연산자**

  가끔 프로그래밍을 할 때 `for`문 내에 두 개 (이상)의 표현식을 초기화하거나 루프가 실행될 때마다 여러 변수를 증감시켜야할 때가 있다. 이는 `for`문의 첫번째와 세번째 표현식 내에서 **쉼표연산자**를 통해 구현 가능하다.

  쉼표식은 다음과 같은 구조를 갖는다.

  > ```
  > expr1, expr2
  > ```

  여기서 `expr1`와 `expr2`은 임의의 표현식이다. 쉼표식은 두 가지 과정으로 평가된다. 우선 `expr1`이 평가가 되고 그 값은 버려진다. 그 다음 `expr2`이 평가되며 그 값이 전체 표현식의 값이 된다. `expr1`을 평가할 때엔 언제나 부작용이 발생한다. 부작용이 발생하지 않는다면 애초에 `expr1`은 의미가 없는 표현식이다.

  예를 들어 값이 각각 1과 5인 변수 `i`와 `j`가 있다고 하자. 쉼표식 `++i, i + j`이 평가된다면, 우선 `i`가 증가가 되고 나서 `i + j`이 평가될 것이다. 그렇기 때문에 전체 표현식의 값은 7이다. (당연하겠지만 `i`의 값은 2로 바뀌었을 것이다) 쉼표연산자의 순서는 다른 연산자보다 낮기 때문에 `++i`와 `i + j`를 괄호를 치는 의미가 없다.

  우리가 할당을 여러개 이어 쓰듯 쉼표식들을 이어 쓸 수 있다. 쉼표연산자는 좌향결합적이다. 즉,

  ```
  i = 1, j = 2, k = i + j
  ```

  위의 코드는 아래와 동일하다.

  ```
  ((i = 1), (j = 2)), (k = (i + j ))
  ```

  쉼표식에선 좌측 피연산자가 우측 피연산자보다 먼저 평가되므로, 할당식 `i = 1`, `j = 2`, `k = i + j`은 왼쪽에서 오른쪽 순서로 진행된다.

  쉼표연산자는 C 언어가 형식상 한 개의 표현식만을 요구할 때, 필요에 의해 두 개 이상의 표현식을 사용할 수 있게 해준다. 쉽게 말해 쉼표연산자는 두 개의 표현식을 "붙여서" 하나의 표현식으로 만들어준다. (뭔가 여러 구문들을 하나의 구문으로 취급하게 해주는 복합문과 비슷하게 들리지 않는가?)

  사실 여러 표현식을 하나로 붙이는 상황은 그렇게 자주 생기지 않는다. 몇몇 특정 매크로 정의의 경우 쉼표연산자를 유용하게 사용하기도 한다. 이는 이후 단원에서 다룰 것이다. 사실상 쉼표연산자는 `for`문에서만 등장한다고 생각하는 것이 편하다. 예를 들어 `for`문을 사용할 때 두 개의 변수를 초기화하고 싶을 때, 우리는 보통 다음과 같이 코드를 작성했다.

  ```
  sum = 0;
  for (i = 1; i <= N; i++)
      sum += i;
  ```

  이제는 위와 같이 작성하지 않고 아래와 같이 작성할 수 있다.

  ```
  for (sum = 0, i = 1; i <= N; i++)
      sum += i;
  ```

  표현식 `sum = 0, i = 1`은 우선 `sum`에 0을 할당하고 `i`에 1을 할당한다. 이런식으로 쉼표를 이용해 `for`문에서 두 개 이상의 변수를 초기화시켜줄 수 있다.

#### 6.4루프에서 벗어나기

- **goto문**

  `break`문과 `continue`문은 프로그램의 제어를 다른 줄로 옮기는 도약문이다. 둘의 범위 또한 정해져있다. `break`는 둘러 쌓인 루프의 **밖**으로 도약하고, `continue`는 루프의 끝 바로 **이전**으로 도약한다. `goto`문은 이 둘과는 다르게 해당 구문에 **표식label**이 있는 한 함수 내의 그 어느 구문으로든 도약할 수 있다. (**[C99]** C99의 경우 `goto`문에 약간의 범위를 부여한다. 변수 크기를 갖는 배열의 선언을 우회할 때 사용할 수 없다.)

  표식이란 구문의 시작에 표기한 식별자이다.

  ```c
  identifier : statement
  ```

  구문은 두 개 이상의 식별자를 가질 수 있다. `goto`문 자체는 다음과 같은 구조를 갖는다.

  ```c
  goto identifier ;
  ```

  구문 `goto L;`을 실행한다면 프로그램의 제어를 표식 `L`이 있는 구문으로 옮긴다. 여기서 표식 `L`은 반드시 `goto`문이 있는 함수 내에 있어야한다.

  루프를 도중에 강제로 종료할 때 `break`문이 아니라 `goto`문을 이용할 수도 있다.

  ```c
  for (d = 2; d < n; d++)
      if (n % d == 0)
          goto done
  
  done:
  if (d < n)
      printf("%d is divisible by %d\n", n, d);
  else
      printf("%d is a prime\n", n);
  ```

  `goto`문은 옛날 프로그래밍 언어들의 잔재이기 때문에 사실 C 프로그램에서 자주 사용되지 않는다. **[Q & A]** `goto`문의 일종이라 할 수 있는 `break`, `continue`, `return`과 `exit` 함수들이 사실상 대부분의 경우 `goto`를 대체할 수 있기 때문이다.

  물론, `goto`문이 가끔 유용하게 사용될 때도 있다. 루프 내에 `switch`문이 있는 상황이라면, `switch`문 내부에선 전체 반복문에서 벗어날 수가 없다. `break`문을 사용하면 `switch`문에서 벗어나지, 반복문에서 벗어나지 않는다. 이는 `goto`문을 통해 손쉽게 해결해줄 수 있다.

  ```c
  while   (...)
      switch   (...)   {
          ...
          goto loop_done;    /* 이 상황에선 break가 먹히지 않는다 */
          ...
      }
  }
  loop_done:   ...
  ```

  반복문이 여러겹일 때도 `goto`문은 유용하게 사용된다.

  

#### 6.5 null문

- null문

  구문은 **무형null**의 형태를 띨 수 있다. 이는 즉 세미콜론을 제외하고 아무 기호도 없는 구문을 의미한다. 직접 예시로 들어보겠다.

  `i = 0; ; j = 1`

  이 줄에는 세 개의 구문이 있다. `i` 할당문, null 구문, `j` 할당문.

#### Q&A

- **무한 루프 :  while(1)과 for( ; ; )**

  오래된 컴파일러에서는 for( ; ; ) 이 while(1) 보다 더 효율적이다. while(1)은 계속 1을 체크하기 때문에 효율이 떨어진다. 하지만, 최근 컴파일러에서는 차이가 없다. 

- `goto`는 스파게티 코드를 만들 수 있다. 이는 이해하기 어렵고, 수정하기 어렵다.



### 07. Basic Types

#### 7.1 정수형 타입

- **signed and unsinged**

  부호가 있는 (signed) 정수형에서는 가장 왼쪽에 있는 bit가 부호 비트이다. 부호비트가 0이라면 양수, 1이라면 음수를 나타낸다. 

  예를들면, 32bit의 부호가 있는 정수형에서 나타낼 수 있는 최대 값은 `0111` (2³¹-1)일 것이다. 반대로 부호가 없는(모두 양수인) 정수형에서 나타낼 수 있는 최대값은 `1111`(2³²-1) 이다.

- C의 정수형 종류

  | 구분                                                                   | Signed  `():생략가능`        | Unsinged  `():생략가능`      |
  | -------------------------------------------------------------------- | ------------------------ | ------------------------ |
  | int : 32bit<br />(16bit cpu에서는 16bit)                                | (signed) int             | unsinged int             |
  | short : 16bit<br />(16bit cpu에서는 int와 동일)                            | (signed) short (int)     | unsinged short (int)     |
  | long : 32bit<br />(32bit cpu에서는 int와 동일)<br />(맥,리눅스 64bit에서는 64bit) | (signed) long (int)      | unsigned long (int)      |
  | long long : 64bit                                                    | (signed) long long (int) | unsigned long long (int) |

  ![img](https://dojang.io/pluginfile.php/73/mod_page/content/50/unit7-1.png)

  C 언어의 정수 자료형은 운영체제, CPU(플랫폼)에 따라 같은 short, int, long이라 하더라도 크기가 달라집니다. 다음은 각 데이터 모델별 정수 자료형의 크기(비트)입니다. S는 short, I는 int, L은 long, LL은 long long, P는 포인터를 뜻합니다.

- **데이터 모델** 

  | 데이터 모델        | short | int | long | long long | 포인터 | CPU 및 운영체제                                     |
  | ------------- | ----- | --- | ---- | --------- | --- | ---------------------------------------------- |
  | IP16L32(near) | 16    | 16  | 32   |           | 16  | x86(16비트): MS-DOS                              |
  | I16LP32(far)  | 16    | 16  | 32   |           | 32  | x86(16비트): MS-DOS                              |
  | ILP32         | 16    | 32  | 32   | 64        | 32  | x86(32비트): 유닉스 및 리눅스, 솔라리스, BSD, OS X, Windows |
  | LLP64/IL32P64 | 16    | 32  | 32   | 64        | 64  | x86-64(64비트): Windows                          |
  | LP64/I32LP64  | 16    | 32  | 64   | 64        | 64  | x86-64(64비트): 유닉스 및 리눅스, 솔라리스, BSD, OS X       |
  | ILP64         | 16    | 64  | 64   | 64        | 64  |                                                |
  | SILP64        | 64    | 64  | 64   | 64        | 64  |                                                |

   

  32비트 Windows, 리눅스, OS X에서 사용하는 ILP32는 int, long, pointer의 크기가 32비트라는 뜻입니다.

  64비트 Windows에서 사용하는 LLP64/IL32P64에서 LLP64는 long long과 pointer의 크기가 64비트라는 뜻이고, IL32P64는 int와 long의 크기가 32비트, pointer의 크기가 64비트라는 뜻입니다.

  64비트 리눅스, OS X에서 사용하는 LP64/I32LP64에서 LP64는 long과 pointer의 크기가 64비트라는 뜻이고, I32LP64는 int의 크기가 32비트, long과 pointer의 크기가 64비트라는 뜻입니다.

  

- **<`limits.h`> 헤더는 타입별 최대값과 최소값을 정의하고 있다.**

  | 자료형                | 최솟값       | 최댓값        |
  | ------------------ | --------- | ---------- |
  | char               | CHAR_MIN  | CHAR_MAX   |
  | short              | SHRT_MIN  | SHRT_MAX   |
  | int                | INT_MIN   | INT_MAX    |
  | long               | LONG_MIN  | LONG_MAX   |
  | long long          | LLONG_MIN | LLONG_MAX  |
  | unsigned char      | 0         | UCHAR_MAX  |
  | unsigned short     | 0         | USHRT_MAX  |
  | unsigned int       | 0         | UINT_MAX   |
  | unsigned long      | 0         | ULONG_MAX  |
  | unsigned long long | 0         | ULLONG_MAX |

  ```c
  #include <stdio.h>
  #include <limits.h>    // 자료형의 최댓값과 최솟값이 정의된 헤더 파일
  
  int main()
  {
      char num1 = CHAR_MIN;          // char의 최솟값
      short num2 = SHRT_MIN;         // short의 최솟값
      int num3 = INT_MIN;            // int의 최솟값
      long num4 = LONG_MIN;          // long의 최솟값
      long long num5 = LLONG_MIN;    // long long의 최솟값
  
      // char, short, int는 %d로 출력하고 long은 %ld로 출력, long long은 %lld로 출력
      printf("%d %d %d %ld %lld\n", num1, num2, num3, num4, num5);
      // -128 -32768 -2147483648 -2147483648 -9223372036854775808
  
      return 0;
  }
  ```

  > -128 -32768 -2147483648 -2147483648 -9223372036854775808

  다음과 같이 limits.h에 정의된 최댓값을 넘어서도 오버플로우가 발생합니다.

  integer_max_overflow.c

  ```c
  #include <stdio.h>
  #include <limits.h>    // 자료형의 최댓값과 최솟값이 정의된 헤더 파일
  
  int main()
  {
      char num1 = CHAR_MAX + 1;          // char의 최댓값보다 큰 수를 할당. 오버플로우 발생
      short num2 = SHRT_MAX + 1;         // short의 최댓값보다 큰 수를 할당. 오버플로우 발생
      int num3 = INT_MAX + 1;            // int의 최댓값보다 큰 수를 할당. 오버플로우 발생
      long long num4 = LLONG_MAX + 1;    // long long의 최댓값보다 큰 수를 할당. 오버플로우 발생
  
      // char, short, int는 %d로 출력하고 long long은 %lld로 출력
      // 부호 있는 정수에서 저장할 수 있는 범위를 넘어서면 최솟값부터 다시 시작
      printf("%d %d %d %lld\n", num1, num2, num3, num4);
      // -128 -32768 -2147483648 -9223372036854775808
  
      unsigned char num5 = UCHAR_MAX + 1;          // unsigned char의 최댓값보다 큰 수를 할당
                                                   // 오버플로우 발생
    
      unsigned short num6 = USHRT_MAX + 1;         // unsigned short의 최댓값보다 큰 수를 할당
                                                   // 오버플로우 발생
  
      unsigned int num7 = UINT_MAX + 1;            // unsigned int의 최댓값보다 큰 수를 할당
                                                   // 오버플로우 발생
  
      unsigned long long num8 = ULLONG_MAX + 1;    // unsigned long long의 최댓값보다 큰 수를 할당
                                                   // 오버플로우 발생
  
      // unsigned char, unsigned short, unsigned int는 %u로 출력하고 
      // unsigned long long은 %llu로 출력
      // 부호 없는 정수에서 저장할 수 있는 범위를 넘어서면 최솟값 0부터 다시 시작
      printf("%u %u %u %llu\n", num5, num6, num7, num8); // 0 0 0 0
  
      return 0;
  }
  ```

  실행 결과

  ```
  -128 -32768 -2147483648 -9223372036854775808 0 0 0 0
  ```

  부호 있는 정수는 저장할 수 있는 범위를 넘어서면 최솟값(음수)부터 다시 시작하고, 부호 없는 정수는 범위를 넘어서면 최솟값인 0부터 다시 시작합니다.

  마찬가지로 최솟값보다 작아지면 언더플로우가 발생합니다

  integer_min_underflow.c

  ```c
  #include <stdio.h>
  #include <limits.h>    // 자료형의 최댓값과 최솟값이 정의된 헤더 파일
  
  int main()
  {
      char num1 = CHAR_MIN - 1;          // char의 최솟값보다 작은 수를 할당. 언더플로우 발생
      short num2 = SHRT_MIN - 1;         // short의 최솟값보다 작은 수를 할당. 언더플로우 발생
      int num3 = INT_MIN - 1;            // int의 최솟값보다 작은 수를 할당. 언더플로우 발생
      long long num4 = LLONG_MIN - 1;    // long long의 최솟값보다 작은 수를 할당. 언더플로우 발생
  
      // char, short, int는 %d로 출력하고 long long은 %lld로 출력
      // 부호 있는 정수에서 최솟값보다 작아지면 최댓값부터 다시 시작
      printf("%d %d %d %lld\n", num1, num2, num3, num4);
      // 127 32767 2147483647 9223372036854775807
  
      unsigned char num5 = 0 - 1;         // unsigned char의 최솟값보다 작은 수를 할당
                                          // 언더플로우 발생
  
      unsigned short num6 = 0 - 1;        // unsigned short의 최솟값보다 작은 수를 할당
                                          // 언더플로우 발생
  
      unsigned int num7 = 0 - 1;          // unsigned int의 최솟값보다 작은 수를 할당
                                          // 언더플로우 발생
  
      unsigned long long num8 = 0 - 1;    // unsigned long long의 최솟값보다 작은 수를 할당
                                          // 언더플로우 발생
  
      // unsigned char, unsigned short, unsigned int는 %u로 출력하고
      // unsigned long long은 %llu로 출력
      // 부호 없는 정수에서 최솟값보다 작아지면 최댓값부터 다시 시작
      printf("%u %u %u %llu\n", num5, num6, num7, num8);
      // 255 65535 4294967295 18446744073709551615
  
      return 0;
  }
  ```

  실행 결과

  ```
  127 32767 2147483647 9223372036854775807 255 65535 4294967295 18446744073709551615
  ```

  최솟값에서 1을 빼서 값이 더 작아지면 언더플로우가 발생하여 다시 한 바퀴 돌게 되므로 최댓값이 출력됩니다.

  지금까지 정수 자료형의 오버플로우와 언더플로우를 설명했습니다. 값을 계산하다가 오버플로우나 언더플로우 현상이 발생하면 의도치 않은 결과가 나올 수 있습니다. 따라서 프로그래밍할때는 정수 자료형의 크기를 항상 생각하고, 값이 범위를 넘어서지는 않는지 반드시 확인합니다.

- **정수형 상수**

  C는 10진수, 8진수, 16진수로 정수형 상수를 쓰는 것을 허용한다.

  8진수 : 0으로 시작 (예 : 017, 0977, 07777)

  16진수 : 0x로 시장 (예 : 0xf, 0xff2, 0xab4)

  - 16진수에서 알파벳은 대문자, 소문자 둘다 가능하다.

    0xff == 0xfF == 0Xff = 0xFF = 0XFF = 0XFf

  정수형 상수는 처음 int로 할당되고, 만약 int로 정수형 상수를 담기 힘들다면, long으로 정수형 상수를 담는다. 그래도 부족하다면 unsigned long에 담는다. 이런식으로 수용가능한 자료형을 찾을때까지 탐색을 하는데, 직접 프로그래머가 지정을 해 줄수 있다.

  > long형으로 지정할 떄는 정수형 상수 끝에 L(또는l)을 붙여준다. 예) 15L, 075L,  0x7fffL
  >
  > unsigned int형으로 지정할 떄는 정수형 상수 끝에 U(또는 u)를 붙여준다. 예) 15U, 075L, 0x7fffU
  >
  > unsigned long int형지정할 떄는 정수형 상수 끝에 UL 또는 LU를 붙여준다. 예) 0x7ffffffLU
  >
  > long long 형은 LL(또는 ll) 

  ```c
  /* Decimal Constants */
      int                 dec_int    = 28;
      unsigned            dec_uint   = 4000000024u;
      long                dec_long   = 2000000022l;
      unsigned long       dec_ulong  = 4000000000ul;
      long long           dec_llong  = 9000000000LL;
      unsigned long long  dec_ullong = 900000000001ull;
  
  
  /* Octal Constants */
      int                 oct_int    = 024;
      unsigned            oct_uint   = 04000000024u;
      long                oct_long   = 02000000022l;
      unsigned long       oct_ulong  = 04000000000UL;
      long long           oct_llong  = 044000000000000ll;
      unsigned long long  oct_ullong = 044400000000000001Ull;
  
  
  /* Hexadecimal Constants */
      int                 hex_int    = 0x2a;
      unsigned            hex_uint   = 0XA0000024u;
      long                hex_long   = 0x20000022l;
      unsigned long       hex_ulong  = 0XA0000021uL;
      long long           hex_llong  = 0x8a000000000000ll;
      unsigned long long  hex_ullong = 0x8A40000000000010uLL;
  
  ```

- **Integer Overflow**

  정수형 자료형의 산술연산의 결과가 지정된 자료형이 표현가능한 범위를 넘어가게되는 것을 `오버플로우`라 한다.  오버플로우의 결과는 정수형 자료형이 signed 인지 unsigned 인지에 따라 다르다. (각각의 표현 가능한 최대 값에서 1을 더하면, 부호가 없는 자료형은 0을, 부호가 있는 자료형은 -로 표현 가능한 최소값을 나타낸다.)

- **정수의 입력과 출력**

  만약 `unsigned integer`를 입력 또는 출력하려면, 10진수는 `%u`를,  8진수는 `%o`를, 16진수는 `%x`를 사용한다.

  ```c
  unsigned int u;
  
  scanf("%u", &u); /*10진수 읽기*/
  printf("%u", u); /*10진수 쓰기*/
  scanf("%o", &u); /*8진수 읽기*/
  printf("%o", u); /*8진수 쓰기*/
  scanf("%x", &u); /*16진수 읽기*/
  printf("%x", u); /*16진수 쓰기*/
  ```

  `short`의 입출력은 d,o,u,x 앞에   `h`를 붙인다.

  ```c
  long s;
  
  scanf("%hd", &s);
  printf("%hd", s);
  ```

  `long long`의 입출력은 d,o,u,x 앞에   `ll`를 붙인다.

  ```c
  long long ll;
  
  scanf("%lld", &ll);
  printf("%lld", ll);
  ```

#### 7.2 실수형 타입

- 실수형 종류

  | 자료형          | 크기          | 범위                          | 유효자릿수 | 비고                  |
  | ------------ | ----------- | --------------------------- | ----- | ------------------- |
  | float        | 4바이트,  32비트 | 1.175494e-38~3.402823e+38   | 6     | IEEE 754 단정밀도 부동소수점 |
  | double       | 8바이트,  64비트 | 2.225074e-308~1.797693e+308 | 15    | IEEE 754 배정밀도 부동소수점 |
  | long  double | 8바이트,  64비트 | 2.225074e-308~1.797693e+308 | 15    | IEEE 754 배정밀도 부동소수점 |

  **지수표기법**

  > 아주 큰 숫자나 아주 작은 숫자를 표기할 때는 지수 표기법(exponential notation)을 사용합니다. 지수 표기법은 과학적 표기법(scientific notation)이라고도 부릅니다. 
  >
  > - 실수e+지수: 실수 * 10의 거듭제곱입니다. 2.1e+3이라면 2.1 * 1000 = 2100이 됩니다.    
  >
  > - 실수e-지수: 실수 * (1 / 10의 거듭제곱)입니다. 2.1e-2라면 2.1 * (1/100) = 0.021이 됩니다. 

  **long double**

  long double은 운영체제와 플랫폼마다 크기가 다릅니다.

  | 운영체제    | CPU(플랫폼)     | 바이트 크기 | 비트 크기 |
  | ------- | ------------ | ------ | ----- |
  | Windows | x86(32비트)    | 8      | 64    |
  | Windows | x86-64(64비트) | 8      | 64    |
  | 리눅스     | x86(32비트)    | 12     | 96    |
  | 리눅스     | x86-64(64비트) | 16     | 128   |
  | OS X    | x86(32비트)    | 16     | 128   |
  | OS X    | x86-64(64비트) | 16     | 128   |

  > 64비트 리눅스, OS X에서는 IEEE 754 4배정도 부동소수점을 저장할 수 있습니다(3.362103e-4932~1.189731e+4932).

  **부동소수점**

  컴퓨터에서는 값을 0과 1로 저장합니다. 그래서 실수도 0과 1로 저장해야 하는데 이렇게 실수와 소수점을 2진수로 표현하는 방식을 부동소수점 표현 방식이라고 합니다. 부동소수점 방식은 자료형의 일정 부분을 비트 단위로 나누어 부호, 가수(significand), 기수(base), 지수(exponent)를 저장하여 실수를 표현합니다.

  부동소수점은 다음과 같이 기수(n)를 지수(p)만큼 거듭제곱한 값을 가수(m)와 곱하는 방식을 사용합니다. 단, 컴퓨터는 값을 저장할 때 2진수로 저장하므로 기수(밑수)는 2로 고정되어 있으며 2 자체는 따로 저장하지 않습니다.

  ![img](https://dojang.io/pluginfile.php/95/mod_page/content/42/unit8-1.png)

  | 자료형    | 크기   | 부호  | 지수   | 가수   |
  | ------ | ---- | --- | ---- | ---- |
  | float  | 32비트 | 1비트 | 8비트  | 23비트 |
  | double | 64비트 | 1비트 | 11비트 | 52비트 |

  유효자릿수는 실수를 일정 자릿수만큼만 표현할 수 있다는 뜻입니다. 만약 유효자릿수가 6이라면 0.123456789는 **반올림**하여 0.12346로 표시됩니다. 즉, 정수 부분 1자리와 소수 부분 5자리로 6자리가 표시됩니다.

  단정밀도와 배정밀도 부동소수점은 저장할 수 있는 크기가 다르므로 유효자릿수의 차이가 있습니다. 따라서 배정밀도 부동소수점이 좀 더 긴 자릿수의 소수점을 정밀하게 표현할 수 있습니다.

- **Floating Constants**

  실수형 상수는 다양하게 표현이 가능하다.

  `57.0` `57.` `57.0e0` `57E0` `5.7e1` `5.7e+1` `.57e2` `570.e-1` 

  실수형 상수는 반드시 소수점을 표현하거나 지수(e or E)표기법을 사용해야한다.

  기본적으로 실수형 상수는 배정밀도(double)숫자로 저장된다. 필요하다면 자동으로 float으로 변환된다. 그래도 지정해주기 위해서는 실수형 상수 뒤에, F(or f)나 L(or l)을 붙여줘서 형식을 지정해 줄 수 있다.

- **부동소수점 읽고 쓰기**

  `%e` : 지수형  (예：1.256637e+001)

  `%f` : 일반 실수형 (예：12.566371)

  `%g` : 숫자값의 크기에 따라 f나 e로 출력 (예：12.5664、2.99792e+008). 숫자값의 절대치가 너무 커서 precision의 자리수를 넘는 경우와 숫자값의 절대값이 0.0001보다 작은 경우 e형식이 사용되어짐. 그 외의 경우는 f형식으로 사용됨

  

  `double` 자료형은 `scanf`를 쓸때  e,f,g 앞에 `l`을 붙인다.

  cf)`printf`는 `l`을 붙이지 않아도 된다.

  ```c
  double d;
  
  scanf("%lf", &d); 
  ```

  `long double` 자료형은 double과 다르게 `scanf` 또는 `printf` 모두 e,f,g 앞에 `L`을 붙인다.

  ```c
  long double ld;
  
  scanf("%Lf", &ld);
  printf("%Lf", ld);
  ```

#### 7.3 문자형 타입

- **문자형의 기본 타입은 `char`이다. 컴퓨터 마다 character sets이 다를 수 있다.**

- **문자형에 연산자를 쓰면?**

  문자형도 비트단위의 숫자로 저장되기 때문에 숫자처럼 다룰수도 있다.

  ```c
  char ch;
  int i ;
  i = 'a';    // i is now 97  ('a' == 97)
  ch = 65;    // ch is now 'A'  ('A' == 65)
  ch = ch + 1; // ch is now 'B'  ('B' == 66)
  ch++;       // ch is now 'C'  ('C' == 67)
  ```
  비교 연산자도 사용 할 수 있다.

  ```c
  if( 'a' <= ch && ch <= 'z')
     ch = ch - 'a' +'A';
  ```

  ```c
  for( ch = 'A'; ch <= 'Z'; ch++)
  {
      ...
  }
  ```

- **signed and unsigned 문자형**

  C는 signed char과 unsigned char를 제공한다. signed char는  -128~127 까지, unsigned char는 0~ 255까지 표현 가능한 작은 단위의 정수형 처럼 사용 가능하다.

  ```c
  signed char sch;
  unsigned char uch;
  ```

  이때, signed와 unsigned를 반드시 지정해주는 것이 바람직하다.

- **Arithmetic Types**

  - Integral Types
    - char
    - singned integer types ( signed char, short int, int , long int)
    - unsigned integer types ( unsigned char, unsigned  short int, unsigned  int , unsigned long int)
    - Enumerated types
  - Floating types
    - Real Floating types(float, double, long double)
    - Complex type (float_Complex, double_Complex, long double_Complex )

- **Escape Sequences**

  | Escape sequence | Hex value in ASCII |                                                              Character represented                                                               |
  | :-------------: | :----------------: | :----------------------------------------------------------------------------------------------------------------------------------------------: |
  |       \a        |         07         |                                [Alert (Beep, Bell)](https://en.wikipedia.org/wiki/Bell_character) (added in C89)                                 |
  |       \b        |         08         |                                               [Backspace](https://en.wikipedia.org/wiki/Backspace)                                               |
  |       \e        |         1B         |                                        [Escape character](https://en.wikipedia.org/wiki/Escape_character)                                        |
  |       \f        |         0C         |                    [Formfeed](https://en.wikipedia.org/wiki/Formfeed) [Page Break](https://en.wikipedia.org/wiki/Page_Break)                     |
  |       \n        |         0A         |                                  [Newline](https://en.wikipedia.org/wiki/Newline) (Line Feed); see notes below                                   |
  |       \r        |         0D         |                                         [Carriage Return](https://en.wikipedia.org/wiki/Carriage_Return)                                         |
  |       \t        |         09         |                                          [Horizontal Tab](https://en.wikipedia.org/wiki/Horizontal_Tab)                                          |
  |       \v        |         0B         |                                            [Vertical Tab](https://en.wikipedia.org/wiki/Vertical_Tab)                                            |
  |       \\\       |         5C         |                                               [Backslash](https://en.wikipedia.org/wiki/Backslash)                                               |
  |       \\'       |         27         |                                 [Apostrophe](https://en.wikipedia.org/wiki/Apostrophe) or single quotation mark                                  |
  |       \\"       |         22         |                                      Double [quotation mark](https://en.wikipedia.org/wiki/Quotation_mark)                                       |
  |       \?        |         3F         | [Question mark](https://en.wikipedia.org/wiki/Question_mark) (used to avoid [trigraphs](https://en.wikipedia.org/wiki/Digraphs_and_trigraphs#C)) |

  `\ooo` 시퀀스는 ASCII 문자 집합의 문자를 세 자리 8진수 문자 코드로 지정할 수 있음을 의미합니다. 8진수 정수의 숫자 값은 원하는 문자 또는 와이드 문자의 값을 지정합니다. 마찬가지로 `\xhhh` 시퀀스를 사용하면 ASCII 문자를 16진수 문자 코드로 지정할 수 있습니다. 예를 들어, ASCII 백스페이스 문자를 표준 C 이스케이프 시퀀스(**\b**)로 지정하거나 **\010**(8진수) 또는 **\x008**(16진수)로 코딩할 수 있습니다.

  8진수 이스케이프 시퀀스에 0부터 7까지의 숫자만 사용할 수 있습니다. 8진수 이스케이프 시퀀스는 길이가 3자리 이내여야 하며 8진수가 아닌 첫 번째 문자로 끝납니다. 3자리 숫자를 모두 사용할 필요는 없지만 하나 이상 사용해야 합니다. 예를 들어, 8진수 표현은 ASCII 차트에 지정된 대로 ASCII 백스페이스 문자에 대해 **\10**이고 문자 A에 대해 **\101**입니다.

  마찬가지로 16진수 이스케이프 시퀀스에 대해 하나 이상의 숫자를 사용해야 하지만 두 번째 숫자와 세 번째 숫자를 생략할 수 있습니다. 따라서 백스페이스 문자의 16진수 이스케이프 시퀀스를 **\x8**, **\x08** 또는 **\x008**로 지정할 수 있습니다. 이때 x는 반드시 소문자여야 합니다.

  또한, 단독으로 쓰일 경우에는 반드시 `' '`(따옴표)를 사용해주어야 합니다.

  ```c
  #define ESC '\33'
  ```

  문자열 내부에서도 사용이 가능합니다.

- **문자 취급 함수**

  소문자를 대문자로 바꾸는 코드는 아래와 같다.

  ```c
  if( 'a' <= ch && ch <= 'z')
     ch = ch - 'a' +'A';
  ```

  하지만, C는 더 간편한 방수를 제공한다.

  ```c
  #include <ctype.h>
  
  ch = toupper(ch);
  ```

- **scanf와 printf**

  하나의 문자를 읽거나 쓸때, scanf와 printf를 사용할 수 있다.

  ```c
  char ch;
  
  scnaf("%c", &ch);
  printf("%c", ch);
  ```

  scanf는 공백을 스킵하지 않고 읽는다. 만약 공백을 스킵하고 싶다면, `%c`이전에 공백을 추가한다.

  ```c
  scnaf(" %c", &ch);
  ```

  개행문자를 체크해서, 한줄을 읽어 올 수 있다.

  ```c
  do{
  	scanf("%c", &ch);
  }while(ch!='\n');
  ```

- **getchar과 putchar**

  putchar는 하나의 문자를 쓰는 함수이다. `putchar(ch);`

  getchar는 문자 하나를 읽어와 반환해준다.`ch = getchar();`

  getchar와 putchar는 scanf와 printf보다 빠르다

  	1. 더 단순한 구조이다. (scanf와 printf는 다양한 자료형을 목적으로 만들어짐)
   	2. getchar와 putchar는 속도를 내기위해 매크로를 수반한다.

  getchar가 scanf보다 좋은 점

  - 그 자체로 값을 리턴해주기 때문에 아래와 같이 사용이 가능하다.

    ```c
    //해당 줄의 남은 문자skip 
    
    do{
    	ch = getchar();
    }while(ch!='\n');
    //또는
    while((ch=getchar())!='\n')
        ;
    //또는
    while(getchar() !='\n')
        ;
    ```

    ```c
    //공백 스킵
    while((ch = getchar()) ==' ')
        ;
    //반복문이 끝나면 ch는 처음으로 공백이 아닌 글자를 가지고 있다
    ```

  **getchar와 scanf를 같은 프로그램에서 혼용해서 사용할때 주의 점**

   scanf는 버퍼에 개행문자나 쓰레기 값을 남기게 된다. 그렇기 때문에 scanf를 사용하고 나서 `fflush(stdin)`을 해주는 것이 좋다.
  
  

#### 7.4 형변환

- 연산적인 부분에 있어 컴퓨터는 C보다 더 제한적인 경향을 보인다. 컴퓨터가 연산을 할 때 피연산자는 같은 사이즈여야 하고 저장도 같은방식으로 된다. 하지만 C는 기본타입의 형을 섞어서 연산하는것을 허용한다. 하나의 표현식에서 int,float,char을 혼용할 수 있다. C컴파일러는 서로 다른 타입을 전환해주어 하드웨어가 연산이 가능하도록 해준다. 

  예를들어, `short`(16bit) 와 `int`(32bit)형을 더하면, 컴파일러는 short를 int로 변환하여 연산한다. 만약, int와 float을 연산하면 int를 float으로 바꿔 연산한다. 이 변환은 int와 float이 다른 형식으로 저장되어 있기 때문에 생각보다 복잡하다. 

  **묵시적 형변환**

  프로그래머가 관여하지 않고, 컴파일러가 자동으로 형변환 시켜주는 것

  컴파일러가 묵시적으로 형변환 하는 것은 복잡하다.(많은 Type이 존재하기 때문에)

  - 묵시적 형변환이 실행되는 경우들

  1. 논리 또는 산술 연산의 피연산자가 다른 타입을 가질 때 (**The usual Arithmetic conversios**)
  2. 변수에 값을 할당할 때 우측값이 좌측변수의 타입과 다를 때
  3. 함수 호출 시 아규먼트와, 파라미터의 타입이 매칭 되지 않을 때
  4. 리턴 값의 자료형과 함수의 리턴 타입이 일치 하지 않을 때

- **The usual Arithmetic conversios**  

  `int + float`의 경우 int를 float으로 형변환하여 계산
  
  기본적으로 usual Arithmetic conversios은 피연산자를 연산 할 때 **모든 피연산자에게 적용가능한 타입 중에** 가장 바이트수가 작은 타입으로 형변환 한다. 
  
  **Promotion** : 피연산자의 타입이 피연산자 중 더 바이트 수가 적은 타입이 바이트가 큰 피연산자의 타입으로 형 변환되는 것
  
  **Integral promotions**  :  cahr이나 short를 int로 형변환 하는 것 (가끔은 unsigned int로 형변환 된다.)
  
  **규칙**
  
  1. 피연산자 중에 floating type이 있는 경우
  
     - **promotion** : float → double → long double
  
     - integer(정수형) 타입과 floating type이 만나면 floating type으로 형변환 된다.
  
       예) long int + double => long int는 double 형으로 형변환 된다.
  
  2. 피연산자 중에 floating type이 없는 경우
  
     - 먼저, 두 피연산자는 모두 **Integral promotions** 이 적용되어 char이나 short형이 있다면 모두 int로 변환 신킨다.
     - 그후 일반적인 **promotion** 을 적용한다.
     - **promotion** : int → unsigned int → long int → unsigned long int 
  
     - **주의!!** unsigned int + long int 의 경우 (모두 32bit) long int와 unsigned int 모두 unsigned long int로 promotion 된다!
  
     - **주의!! **signed와 unsigned 피연산자가 연산되면 signed  타입이 unsigned 타입으로 변환된다.
  
       이 경우, 음수의 값이 unsigned로 프로모션 되면 제대로 된 값을 표현 할 수 없기때문에 오류가 발생한다. 예를 들면 signed int 타입의 -10이  unsigned int로 프로모션 되면 4,294,967,2967,296이된다.
  
       ```c
       int a=-10;
       unsigned int b=5;
       
       if ( a < b ) 
           // false가 나온다..
           // 4,294,967,2967,296 < 5
       ```
  
       몇몇 컴파일러는 에러메세지를 띄우기도 한다. 두 타입을 같이 섞어서 쓰는것은 위험하기 때문에 지양해야한다.

- **할당 시 형변환** 

  assignment를 할때에는 arithmetic conversions이 적용 되지 않는다. 오른쪽에 있는 expression(변수, 상수 또는 연산의 결과)이 왼쪽에 있는 변수의 타입으로 형변환 된다. 만약 좌측 변수의 타입의 바이트 크기가 오른쪽 expression보다 크거나 같다면 별 문제 없이 형변환 되지만, 우측 expression의 크기가 더 크다면 문제가 된다.

  - 아래의 경우는 문제 없이 우측항이 좌측항으로 형변환 된다.

    `int = char;` `float = int;` `double = float;`

  - 정수형으로 부동소수점이 형변환 되면, 소수점 아래는 버림한다. (842.97 => 842  ,  -842.97 => -842)

  - 만약 좌측 변수의 타입의 범위를 벗어나는 수를 할당하면, 의미 없는 결과가 나온다.
  - `float f = 3.14159;`라고 할당하면, 3.14159는 double 타입을 가질 수 있기 때문에, 왼쪽 타입이 더 작기 때문에 에러 메세지를 띄울 수 있다.  

- **C99에서 묵시적 형변환**

  **integer conversion rank:**

  1. long long int, unsigned long long int
  2. long int, unsigned long int
  3. int, unsigned int
  4. short int, unsigned short int
  5. char, signed char, unsigned char
  6. _Bool

  **부동 소수점 타입이 피연산자로 있을 경우는 C89와 같다.**

  **부동소수점 타입이 없을 경우**

  1. 먼저 integer promotion 을 하여, int 타입보다 작은 타입을 int나 unsigned int로 형변환 된다. 두 피연산자의 타입이 같아 졌다면, 형변환은 끝난다. 

  2. 그렇지 않다면, 두 타입이 unsigned 타입인지 unsigned 타입인지 확인하고, 두개가 부호타입이 같다면, **integer conversion rank**를 따라서 사이즈가 큰 것으로 캐스팅 된다.

  3. 만약, 두개가 각각 unsigned와 signed일 경우, unsigned가 signed의 랭크보다 높거나 같을 경우 signed 타입을 unsigned타입으로 변경한다.

     예) unsigned long long int와 long int 의 경우, unsigned long long int로 변환된다.

     예) int와 unsigned int의 경우, unsigned int로 변환된다.

  4. 만약, signed이 unsigned타입의 모든 값을 표현 가능한 범위(보통 사이즈가 더 크다면)라면 unsigned타입을 signed으로 변환한다. 

     예) long long int와 unsigned long int 의 경우, long long int로 변환된다.

  5. 그렇지 않으면, 두 피연산자를 모두 signed 타입의 피연산자에 상응하는 unsigned타입으로 형변환 된다.

     예) long int와 unsigned int 의 경우, unsigned int로 변환된다.

  cf) 모든 타입은 bool 타입으로 형변환 될 수 있는데,  원래의 값이 0이면 형변환 후 0으로, 0이아니라면 1로 된다.

- **Casting**

  묵시적 형변한은 편하지만, 가끔은 명시적 형변환이 필요한 경우가 있다.

  캐스팅 : `(TYPE) EXPRESSION`

  만약, 정수형 끼리의 나눗셈을 하고 결과를 실수형으로 받고 싶다고 가정해보자

  ```c
  float quotient;
  int dividend, divisor;
  
  quotient = dividend / divisor;
  //이경우는 quotient에 소수점 아래 자리의 결과는 저장되지 않는다. 우측항의 결과가 정수형이기 때문
  quotient = (float) dividend / divisor;
  //dividend float으로 캐스팅해주면 divisor는 묵시적으로 float으로 형변환 된다. 
  ```

  캐스팅에서 (TYPE)은 단일 연산자로, binary 연산자보다 우선순위가 높다.

  즉, `(float) dividend / divisor;`는 `( (float) dividend ) / divisor; `와 같다.

  가끔씩 overflow를 피하기 위해 casting을 하기도 한다. 

  ```c
  long i;
  int j=1000;
  
  int j * j;
  i = j * j;  // 오버 플로우!
  i = (long) j*j; // OK
  i = (long) (j*j)  // 틀림!! j*j를 먼저 수행하기 때문에
  ```

#### 7.5 타입 정의

- **typedef** 

  타입을 정의하는 방법으로 `#define BOOL int`을 사용했었지만, `typedef`를 이훃하는 것이 더 좋은 방법이다. 

  `typedef int Bool`

  ```c
  typedef int Bool;
  Bool flag; // int flag;와 같음
  ```

- **타입 정의의 이점**

  1. 프로그램을 이해하기 쉽다. 

     ```c
     typedef float Dollars;
     Dollars cash_in, cash_out;
     ```

  2. 프로그램 수정이 쉽다.

- **C99  <stdint.h>**

  stdint.h를 이용해서 특정한 bit수의 int를 사용 할 수 있다. 예를 들면, `int32_t`는 32bit의 정수형을 의미한다.



#### 7.6 sizeof 연산자

- `sizeof (type-name)`을 쓰면 타입의 바이트 크기가 나온다.

- sizeof의 결과인 size_t자료형을 출력할 때는 문제가 있다. 어떠한 타입인지 사용자가 알기 어렵기 때문에 캐스팅을 통해 형변환하여 출력하는 것이 좋다.

  ```c
  printf("%lu", (unsigned long) sizeof (int) );
  ```

- **C99에서는 size_t 값을 바로  캐스팅을 하지 않아도  z를 써주면 된다.**

### 08. Array

c는 배열과 구조체라는 두개의 집합 변수를 지원한다.

#### 8.1 1차원 배열

- 한 줄로 원소를 나열하는것

- 배열을 선언하기 위해 배열 사이즈와 자료형을 지정해줘야 함

  - `int a [10];`

- 원소의 자료형은 어떤 타입이나 가능함

- 상수로 배열의 길이를 지정 가능

- 추후에, 배열의 길이를 수정해야 할 수도 있기 떄문에, define을 사용해서 배열의 길이를 지정해주는 것이 좋음

  ```c
  #define N 10
  
  int a[N];
  ```

- 배열의 이름과 대괄호안에 인덱스를 넣어 특정 원소에 접근 가능하다
- 길이가 n인 배열의 원소의 인덱스는 0번부터 n-1까지 존재한다.
  - 배열의 길이가 10일때
    - `a[0]` `a[1]` . . . `a[8]` `a[9]`

- 배열의 원소는 다른 변수와 마찬가지로 취급 할 수 있다.
  
- `a[0]=1` `++a[i]` `printf("d\n", a[5])`
  
- for를 활용하여 배열을 잘 활용할 수 있음, for루프로 배열의 모든 원소를 접근하여 연산할 수 있음

  ```c
  for(int i =0; i<N;i++){
      a[i]=0;
  } //clear
  
  for(int i =0; i<N;i++){
      scanf("%d", &a[i]);
  } // read data into a
  
  for(int i =0; i<N;i++){
      sum += a[i];
  } //sum
  ```

- C는 배열의 범위를 체크하지 않는다. 배열의 범위를 넘어서면 프로그램은 비정의행동을 한다.  몇몇 컴파일러는 아래의 예시에서 무한 루프를 만들어낸다. a[9] 다음에 i가 정의 되어 있을때, a[10]=0;을 실행하면 i=0이 되기 때문이다.

  ```c
  int a[10],i;
  for(i =0; i<N;i++){
      a[i]=0;
  }
  ```

- 아래의 코드는 비정의 행동을 한다. 4.4에서 본것 같이 증감연산자는 표현식이 끝나기전까지 실행이 되지만, 그게 언제인지는 명확하지 않다. 아래의 코드에서 a[i] 와 b[i++]의 i가 같지 않을 수 있다.

  ```c
  i=0;
  while (i<N){
      a[i]=b[i++];
  }
  ```

- 배열 초기화

  일반적인 방법은 중괄호 안에 콤마로 구분지어 선언과 동시에 배열을 초기화 해주는 방법이다.

  `int a[10] = {1,2,3,4,5,6,7,8,9,10}`;

  만약, 전체를 다 초기화하지 않고 일부만 초기화 할경우, 나머지 값은 모두 0으로 초기화 된다.

  `int a[10] = {1,2,3,4,5,6}`; => a : 1 2 3 4 5 6 0 0 0 0

  이 특성을 이용하여, 모두 0으로 초기화하는 쉬운방법이 있다

  `int a[10] = {0}`;  //중괄호 안에 아무것도 안쓰는 것은 허용되지 않음

  배열의 길이를 쓰지않고 초기화하는 방법이 있다. 이 경우 컴파일러가 배열의 길이를 지정해준다.

  `int a[] = {1,2,3,4,5,6,7,8,9,10}`

- `C99` 만약 특정 원소만 특정정값을 가지고 나머지 원소는 0으로 만들고 싶으면 C99버전부터는 아래와 같은 식을 허용한다.

  ```c
  // a : 0 0 29 0 7 0 0 0 0 48 
  
  
  //지정자는 반드시 정수형 상수여야 한다.
  int a[10] = { [2] = 29, [4] = 7, [9] = 48 };
  //또는 순서에 상관없이도 지정이 가능하다
  int a[10] = { [4] = 7, [9] =48, [2] = 29 };
  
  ```

- 만약 길이가 지정이 안된다면, 내부에서 가장 큰 값을 배열의 길이로 갖는다. 아래의 배열의 초기화 괄호 내부의 가장큰 지정자 값이 30이므로, 배열의 크기는 31이다.

  ```c
  int a[] = { [2] = 29, [4] = 7, [9] = 48, [30] = 1 };
  ```

- 아래와 같이 혼용해서 사용도 가능하다.

  ```c
  int a[10] = {1, 2, [4] = 7, 8, 9, [9] = 48 };
  // 1 2 0 0 7 8 9 0 0 48
  ```

  1과 2는 처음에 나오고, 4번째 원소는 7, 4번쨰 원소 뒤 8, 9가 순서대로 오고, 다시 9번째 원소는 48이 온다. 이때 나머지 원소는 모두 0이 된다.

- bool과 true와 false는 `stdbool.h`에 포함되어있다. 만약 컴파일러가 이를 지원하지 않는다면 직접 define을 사용해서 선언해 주어야 한다

  ```c
  #define true 1;
  #define true 0;
  #define bool int;
  ```

- sizeof 연산자를 이용해 배열의 사이즈를 구할 수 있다.

  배열의 길이가 10인 int형 배열 `int a[10]`의 sizeof(a)는 40이 나온다. 이는 int형 자료형 4byte가 10개가 있어 40이 나오는 것이다. 즉 sizeof는 byte의 크기를 반환한다.

  만약 배열의 길이를 구하고 싶다면 `sizeof(a) / sizeof(a[0])`을 사용하면 된다. (10이 나옴)

  만약 배열의 길이를 모를 경우, for문을 사용할 때 sizeof를 활용 할 수 있다. 이때  배열의 길이가 달라져도 코드를 수정할 필요가 없다. 이는 매크로를 사용한 결과와 비슷하지만, sizeof를 활용한 방법은 매크로이름을 기억할 필요가 없기 때문에 오류의 확률을 줄여준다.

  ```c
  for(i=0; i< sizeof(a) / sizeof(a[0]); i++){
      a[i]=0;
  }
  ```

  하지만, 몇몇 컴파일러는 `i< sizeof(a) / sizeof(a[0])`표현식에 에러를 띄운다. i는 int 타입(signed)이지만, sizeof의 결과는 size_t 타입(unsigned) 이기때문이다. signed 타입과 unsigend 타입을 비교하는 것은 위험하다. (물론 이경우에는 `i`와 `i< sizeof(a) / sizeof(a[0])`모두 음수가 나올 일이 업기 때문에 위험하진 않다. ) 에러를 피하기 위해 형변환을 해줄 수 있다.

  ```c
  for(i=0; i< (int) (sizeof(a) / sizeof(a[0])); i++){
      a[i]=0;
  }
  ```

  하지만, `(int) (sizeof(a) / sizeof(a[0]))`는 너무 긴 표현식이기 때문에 매크로를 이용하여 간략화 해주는 것이 좋다.

  ```c
  #define SIZE_a (int) (sizeof(a) / sizeof(a[0]))
  
  for(i=0; i< SIZE_a ; i++){
      a[i]=0;
  }
  ```

#### 8.2 다차원 배열

- 배열은 어떤 수의 차원이든 가질 수 있다. 행렬과 같이 2차원 배열도 가능하다

  `int m[5][9]`는 5개의 행과 9개의 열을 가진 배열이다.

- `m[i][j]`와 `m[i,j]`는 다르다. 여기서 ,는 연산자로 취급되어 m[i,j]는 m[j]와 같다. 
- 우리는 테이블 형태로 2차원배열을 시각화하지만, 사실 메모리에는 일렬로 저장된다. 

- 다중 배열의 초기화 `m[2][3]` 배열을 초기화 할때, 중괄호의 집합을 또 중괄호의 집합으로 묶어주어 표현해준다.

  ```c
  int m[2][3]={{1, 1, 1},
               {1, 1, 1}};
  ```

- 초기화시 비워둔 열이나 행이 있다면 0으로 해당 부분은 0으로 초기화 된다.

- 실제로는, 내부 중괄호를 생략 가능하다. 이때 열단위로 먼저채우고 나머지는 0 으로 초기화된다. (비추)

- 2차원 배열을 아래와 같이 초기화하면 모든 원소를 0으로 만들 수 있다.

  ```c
  bool ABC[10][10]={false};
  int I[10][10]={0};
  ```

  

- 1차원 배열과 마찬가지로, 초기화시 원하는 원소만 원하는 값으로 초기화하고 나머지는 다 0으로 초기화가 가능하다.

  ```c
  double ident[2][2]={[0][0]=1.0, [1][1]=1.0};
  ```

- 상수 배열

  const를 붙여 1차원 배열이나 다차원배열에서 상수 배열을 만들수 있다.

  ```c
  const char hex_chars[]={'0','1','2','3','4','5','6','7','8','9','A', 'B','C','D','E','F'};
  ```

  상수 배열은 프로그램에의해 수정되지 말아야하며, 컴파일러에 의해 감시된다. 즉, 변화하지 않는 자료라는 것을 컴파일러에게 알려주는 것이다.

#### 8.3 가변길이 배열 

(가변길이 배열 : 비주얼스튜디어에서는 불가, gcc컴파일러에서는 가능)

C99버전 부터 가변길이 배열 사용이 가능하다. 보통 상수에 의해 배열의 길이가 정해지지만, 아닌 경우도 존재한다. 아래와 같이 길이가 프로그램이 실행될 때 결정이 될 수있다.

```c
int i,n;

scanf("%d", &n);

int a[n];
```

VLA(variable-length array)는 배열을 너무 길거나 짧게 선언하는 문제에 대해서 효과적이다. VLA를 사용할때는 초기화를 사용해서는 안되며, 정적인 저장소를 가질 수 없다. 그리고, VLA는 메인문보다는 함수에 사용하기 유용하다. 함수가 호출될때마다 다른 길이의 배열을 사용 할 수 있기 때문이다.

또한, 연산자를 포함한 선언도 가능하다.

```c
int a[3*n+i];
```

#### Q&A

- 아래의 경우 초기화를 여러번 할 수 있다.

```c
int a[] ={4,9,1,8,[0]=5,7};
```

이 경우 a는 5, 7, 1, 8의 원소가 들어가는 길이 4의 배열이 된다.

- 배열의 복사는 원소단위로 해야한다.

  `a=b`는 허용되지 않는다.

  다른 방법으로는, `string.h`에 있는  `memcpy`함수를 이용하는 것이다. 이 방법은 low레벨에서 메모리를 바이트 단위로 카피하는 역할을 한다.

  `memcpy(a, b, sizeof(a));`

  큰 배열의 경우 원소단위로 복사하는 것 보다. memcpy 함수가 더 빠르다.

- goto를 이용하여 VLA에 접근할 수 없다. 만약, goto를 이용하여 VLA에 접근하게 하려고한다면, VLA는 아직 메모리가 할당되지 않은 상태이기 때문에 주소가 존재하지 않기 때문에 불가능하다.

### 09. 함수

#### 9.1 함수의 정의와 호출

- 리턴타입
- 파라미터 : 함수에서 실제 사용되는 변수 (아규먼트를 받는 변수)
- body
- 아규먼트 : 함수를 호출하는 곳에서 사용되는 자료(상수, 변수 등)

- 함수 정의

  ```
  return type 함수 이름 (파라미터)
  {
  	선언문(declarations)
  	statements
  }
  ```

- 함수는 배열을 리턴 할 수 없음

- 리턴 타입이 없으면 void

- C89에서 리턴타입이 생략되면 int 값을 리턴하는것으로 가정한다.

- C99에서는 리턴타입이 없으면 illegal이다

- 파라미터는 각각 자료형을 써주어야 한다.

  ```c
  double avg (double a,b){     //Wrong
  
  }
  
  double avg (double a, double b){     //OK
  
  }
  ```

- 함수 안에서 선언된 변수는 그 함수내에서 만 사용된다.

- C89에서 변수의 선언이 앞에온 다음 statements가 와야 한다.

- C99 부터는 변수 선언과 statements가 섞일 수 있다.

- 리턴 타입이 void인 함수의 body는 비어있을 수 있다. body가 비어 있으면 시간이 소요되지 않고 호출된 자리로 다시 돌아간다.

  ```c
  void emptyFunc(void){
  
  }
  ```

  

-  함수 호출

  함수 명과 괄호 안에 아규먼트를 써서 호출 한다.

  ```c
  avg (x,y);
  print_count(i);
  print_pun();
  ```

  괄호는 필수이다. 괄호가 없어도 실행은 되지만 아무런 결과를 보여주지 않는다. 몇몇 컴파일러는 경고를 하기도 한다.

- nov void 리턴 함수의 결과는 사용하지 않으면 버려질 수 있다.

- 사실 printf 함수는 char의 갯수를 리턴하지만, 보통 리턴값은 무시하고 사용된다,

  ```c
  num_char = printf("hi, mom!\n");
  printf("hi, mom!\n");
  ```

  리턴을 버리는것을 명확하게 명시하기 위해 함수 앞에 void를 써줄 수 있다.

  ```c
  (void) printf("hi, mom!\n");
  ```

  이 방법은 형변환 캐스팅을 해주는 것이다. printf의 리턴 타입을 void로 형변환 해주는 것이다. 

#### 9.2 함수의 선언

- 함수가 호출되기전의 위치에 함수가 정의 되어야하지만, 사실 C는 함수의 정의가 함수가 호출되는 위치의 뒤에 와도 된다. 예를 들어 메인함수에서 어떤 함수를 호출한다고 하면, 그 함수가 메인문이 끝난 후에 정의 되어도 된다. 컴파일러가 처음 함수의 호출을 만나면, 그 함수에 대한 정보(파라미터의 타입, 리턴 타입 등)가 없기 때문에 컴파일러는 함수의 리턴 타입을 **int 타입(디폴트)으로 가정**한다. (실제로는 다른 타입이라고 하더라도) 이것을 컴파일러가 함수의 **묵시적 선언**을 했다고 한다. 또한, 컴파일러는 파라미터의 수와 아규먼트의 수가 동일한지 모른다. 후에 컴파일러가 함수의 정의를 만났을 때 컴파일러는 **함수의 리턴타입이 int가 아닌 다른 타입인걸 알아채면** **에러 메세지**를 보낸다.

- 위와 같은 문제를 피하기 위해, 함수가 호출 되기 이전에 함수를 정의하는 것이다. 하지만, 함수의 정의를 전체다가 호출되기 이전에 놓으면, 더러운 코드가 된다. C는 함수의 선언을 함수가 호출 되기 이전에 하는 것을 허용해준다.  함수의 선언을 통해 함수에 대한 정보를 컴파일러에게 미리 제공해 줄 수 있다.

- 함수의 선언 == **function prototypes**

  ```c
  #전처리
  
  리턴타입 fn1 (파라미터);  /*함수의 선언or function prototypes*/
  
  int main(){
      statemesnts;
  }
  
  리턴타입 fn1 (파라미터){
      return (a+b) / 2;
  }
  ```

  함수의 선언(function prototypes)을 할때에는 파라미터의 정확한 변수 이름을 쓰지 않아도 되고, 자료형만 쓰거나 쓰고 싶은 이름을 마음대로 써도 괜찮다. `double avg (double, double)`

- C99부터는 함수의 정의 또는 선언이 호출되기 이전에 나오지 않으면 int형으로 묵시적으로 컴파일러가 판단하지 않고 바로 에러를 띄운다.

#### 9.3 Arguments

- 파라미터와 아규먼트의 차이점.
  - 파라미터 : 함수의 정의에 있음
  - 아규먼트 : 함수의 호출에 있음

- Passed by value : 각 아규먼트가 각 파라미터로 매칭이되어 할당 되는 방식, 아규먼트의 값을 파라미터로 카피한다. 함수내에서 파라미터의 값이 바뀌어도, 아규먼트에는 영향을 주지 않는다.

  하지만, 두개 이상의 값을 리턴 받고 싶을 때 유용하지 않다.

- **아규먼트 conversion(형변환)**

  파라미터와 아규먼트의 타입이 일치하지 않을 때 함수의 선언이 호출 전에 있는지 아닌지에 따라 형변환이 일어난다.

  **함수 호출 전에 함수 프로토 타입이 있는 경우 :**  아규먼트들은 묵시적으로 파라미터로 형변환 된다.(할당과 비슷)

  **함수 호출 후에 함수 선언이 있는 경우 :**  아규먼트들은 **defalut argument promotions**를 수행한다. float 타입의 아규먼트는 double로, char 타입이나 short 타입의 아규먼트는 int로 변환된다.

- 함수를 호출 할 때, `avg((int)x,(int)y);`와 같이 명시적 형변환을 해 줄 수 있다.

- **배열 아규먼트**

  배열을 아규먼트로 사용할 수 있는데, 이때 파라미터는 길이를 생략할 수 있다.

  ```c
  int f (int a[])
  {
  ...
  }
  ```

  이때, 아규먼트는 길이에 상관없이 1차원 배열이면 가능하다. 이때, 문제는 아규먼트 배열의 길이가 얼마나 될지 함수가 어떻게 아냐는 건데, 파라미터를 하나더 추가해서 배열의 길이 까지 전달해주면 문제를 해결 할 수 있다.

  **참고로, 함수내에서 a 배열의 길이를 구하는 sizeof()함수를 써도 아규먼트 였던 배열의 길이는 알 수 없다.** 

  파라미터 명을 생략한 프로토 타입의 경우는 이렇게 사용할 수 있다.

  ```c
  int sum_arr (int [], int);
  ```

  함수를 호출 할 때에는 아규먼트에는 `[]`를 써주지 않는다.

  ```c
  sum_arr(arr, n);   //OK
  sum_arr(arr[], n);   //WRONG
  ```

  **★배열을 파라미터로 사용 할 때 가장 중요한 포인트는, 함수내에서 변화된 파라미터는 아규먼트에도 그대로 반영이 된다는 점이다.**

- **다중 배열 파라미터**

  배열의 가장 처음 길이만 생략한다.

  ```c
  int f (int a[][4])  //2차원 배열을 파라미터로 받을 때 예
  {
  ...
  }
  ```

- **VLA 파라미터**

  C99, VLA 배열의 경우 n을 명시적으로 적어 줄 수 있다.

  하지만, 이때 n이 먼저 선언이 되어야 하기 때문에, 파라미터 선언 순서에 주의 하자. 컴파일 에러 발생! (n을 선언 후 int a[n] 선언)

  ```c
  int sum_arr (int n, int a[n]){
  
   ...
  
  }
  //OK
  int sum_arr (int n, int m, int a[n+m], int b[n]){
  
   ...
  
  }
  //OK
  int sum_arr (int n, int m, int a[n][m]){
  
   ...
  
  }
  //OK
  ```

- 2차원 배열을 선언 할 때 가능한 방법 들

  ```c
  int sum_arry(int n, int m, int a[n][m]);
  int sum_arry(int n, int m, int a[*][*]);
  int sum_arry(int n, int m, int a[][m]);
  int sum_arry(int n, int m, int a[][*]);
  ```
  

배열을 선언 할 때 가능한 방법 들

  ```c
  int sum_arry(int n, int a[n]);
  int sum_arry(int n, int a[*]); // 선언 할 때에는 *로 어떠한 값이 함수를 정으할때 들어 가는 것을 암시적으로 표현 가능하다.
  int sum_arry(int, int [*]);
  int sum_arry(int n, int a[]);
  int sum_arry(int , int []);
  ```

- C99 배열 파라미터 선언에서 static 사용

  static keyword는 array의 길이의 최솟값을 보장한다. 이것은 프로그램 자체에 영향을 주진않지만 컴파일러의 속도 향상에 도움이된다. 메모리에서 해당요소를 미리 가져올수(prefetch)할 수 있기 때문에. 단 2차원이상 배열에서는 row(첫번째)에만 static keyword를 사용할 수 있다.

  ```c
  int sum_arr(int a[static 3], int n){
  ...
  }
  ```

- C99 compound literal 

  Compound literal 은 유용하다.

  배열이 함수 호출 외에 다른 목적으로는 쓰이지 않을 경우, 배열을 선언하지 않고 compound literal 을 이용해서 함수를 호출 할 수 있는 방법이다.

  ```c
  sum_array((int []) {1,2,3}, 3);
  sum_array((int [8]) {2,2 }, 8); // 나머진 0으로 초기화
  sum_array((int []) {2 * i, i + j, j * k}, 3);
  ```

  (const int[]) {5, 4} 는 array를 read_only로 만들수 있다. 수정불가

#### 9.4 retrun

- 함수의 리턴 타입과 `return ~~~`의 `~~~`타입이 다르다면 함수의 리턴 타입으로 자료형이 묵시적 형변환 된다.

- void 타입 retrun

  return 뒤에 아무것도 쓰지 않는 것.

  void 타입의 함수에는 return; 을 써주거나 아예 리턴을 생략해도 무방하다.

- 만약 void형이 아닌 함수에서 리턴이 존재하지 않을 경우, 몇몇 컴파일러에서는 경고를 해주지만, 아닌 경우도 존재한다. 이경우 비정의 행동을 하기 때문에 어떤 값이 나올지 모른다.

- return문에 3항 연산자도 사용 가능하다.

  non-void function에서 아무것도 리턴하지 않을경우 compiler에 따라 에러를 발생 시킬수 있다. 주의하자.

#### 9.5 프로그램 종료

- c99 부터 main함수의 return type을 생략하는것은 안된다.
- main 함수의 void parameter도 생략할 수 있지만, 생략하는것을 비추천한다.

- **exit**

  normal termination

  - exit(EXIT_SUCCESS) == exit(0) == return 0

  abnormal termination

  - exit(EXIT_FAILURE) == return 1

- EXIT_SUCCESS와 EXIT_FAILURE는 <stdlib.h>에 #define 형태로 존재한다.

  return 문은 main안에서 실행됬을 경우만 프로그램이 종료되지만, exit문은 어떤 함수에서 호출되어도 프로그램을 종료한다.

#### 9.6 재귀

- 재귀문은 termination condition(탈출 조건)에 신경 써야한다. 재귀문은 분할정복, 퀵소트 등에 쓰인다.

#### Q&A

- 함수안에서 함수를 선언할 수 있다. 다만 그 함수는 선언된 함수안에서만 사용될 수 있다.

- 함수의 프로토 타입을 선언 할 때, 리턴타입이 같다면 같이 선언 가능하다.

  ```c
  void print_pun(void), print_count(int n ); 
  ```

  심지어 함수와 변수 선언을 같이 할 수 있다.( 좋은 방법 아님)

  ```c
  double X, Y, average ( double n ); 
  ```

- 함수의 배열 파라미터에서 가장 왼쪽 값만 지정되지 않는 이유

### 10. Program Organization

#### 10.1 Loal variable

함수 안에 정의된 변수

```c
int example(int n) 
{
    int a = n; // a는 지역 변수   
    return a;
}
```

1. **Automatic Storage Duration**
   1. 자동적으로 변수의 저장공간이 할당되고, 해제됨
2. **Block scope**
   1. 변수가 참조될 수 있는 영역
   2. 블록 안에서만 참조할 수 있다.

**Static Local Virable**

static을 넣는다는 건, **static storage duration**(not Automatic  Storage Duration)임을 뜻함.
 프로그램 실행될 때 저장공간을 무조건 유지함.

```c
void f(void) 
{
    static int i;
}
```

여전히 **block scope**를 가짐. (not visible from outside).
 함수가 한 번 또 호출됐을 때, **이전의 변수 값**을 가지고 있음.



**Parameter**

매개변수는 지역변수와 같은 속성을 갖는다.

1. autobatic storage duration
2. block scope



#### 10.2 External(global) Variable

함수 바깥에 선언된 변수.
 함수는 external variable과 communicate할 수 있다.

> 스택을 구현할 때, 전역 변수를 쓸 수 있다.

1. **static storage duration**
2. File Scope
   1. 파일 내부에서만 통용 됨



**전역변수의 장단점**

함수 쓸 때 전역변수 말고 인자로 넘겨받는게 대개 더 낫다

- 장점

1. 다양한 함수가 같은 변수를 사용하는게 간편함

- 단점

1. 프로그램 수정 시, 지속적으로 전역변수를 체크해야 함
2. 디버깅할 때 어려움
3. 프로그램을 재사용하기 어려움 (전역변수도 같이 옮겨줘야 함)

#### 10.3 Blocks

```c
int func(int a)
{
    int b = 0;
    if (a > b) 
    {
        int temp = a;
        a = b;
        b = temp;
    }
}
```

- C언어는 **compound Statements**를 허용한다.
- block안에 선언한 변수는 **Local variable** (automatic storage duration & block scope)
- block안에 따로 변수를 선언하면
  - 가독성이 좋아진다. (부모 블록 변수와 자식 블록 변수가 나뉘어 선언됨)
  - 이름 충돌이 방지됨

#### 10.4 Scope

동일한 식별자라도 위치에 따라서 여러 개의 값일 수 있다.

```c
int i;

void f(int i) 
{
    i = 1;
}

void g(void)
{
    int i = 2;

    if (i > 0)
    {
        int i;
        i = 3;
    }

    i = 4;
}

void h(void)
{
    i = 5;
}
```



#### 10.5 Organizing a C Program

여러 파일을 통해 프로그램을 짤 수도 있다.
 아직까진 단일 파일에서 코딩하는 것만 배웠음.

**싱글 파일 프로그램 짜는 순서**

```
1. #include 하기
2. #define 하기
3. 사용자 타입 정의
4. 전역 변수 선언
5. 사용할 함수 이름만 작성
6. 메인 함수 작성
7. 사용할 함수 body 작성
```



#### QnA

1. 재귀함수에서 static 지역변수를 사용하면 어떻게 되나요?
   - 재귀로 호출되는 모든 함수들은 같은 static 변수를 참조하게 된다.
2. 전역변수 i가 있는데, 바로 아래 선언된 함수에 i가 지역변수로 또 선언됐다. 괜찮나.
   - 괜찮다. scope를 봐라

### 11. 포인터

#### 11.1 포인터 변수

포인터는 변수의 첫번쨰 주소를 가리킴

```c
int *p; //int 형만 포인팅 가능하다.
double *q; //double 형만 포인팅 가능하다
char *r; //char 형만 포인팅 가능하다
```



#### 11.2 Address & Indirction Operators

`& : Address Operators`

`*: Indirction Operators`



변수에 & 붙이면 주소

포인터에 * 붙이면 포인터가 가리키는 변수의 값

```c
int i,j;
j=*&i;   // i의 주소가 가리키는 값을 j에 할당 : j==i
```

*& 는 상쇄 된다.

> *& + 변수  :  변수의 주소에 있는 값, 즉 변수에 저장된 값 그 자체
>
> &* + 포인터 : 포인터가 가리키는 변수의 주소, 즉 포인터에 저장된 변수의 주소 그 자체

초기화 되지 않은 포인터를 사용하는 것은 위험하다.



#### 11.3 포인터 할당

```c
int i,j,*p,*q;
p = &i;
q=p;
```

한 변수를 두개의 포인터가 가리키는 것도 가능하다.



#### 11.4 Argument 로서의 포인터

포인터를 이용하면, 함수에서 파라미터의 값을 바꿀때 아규먼트도 바꿔줄 수 있다.

```c
void fn(int * a){
    
}
int main(){
	int p*;
	int i;
    p=&i;
    ...
	fn(p);
    fn(&i);
	...
}
```

포인터에 저장된 주소를 전달해 주기 떄문에 값을 공유함.

- 포인터를 이용해서 입력 받는 법

```c
scanf("%d", &p) // 틀림	
scanf("%d", p) // 맞음	
```

#### 11.5 return 값으로의 포인터

```c
int *fn(int * a){
    int *p;
    int i;
   	...
    return a;
    //return p; 안됨!!
    //return &i; 안됨!!
}
int main(){
	int p*;
	int i;
    ...
    p=fn(&i);
	...
}
```

주의!!!

위 코드에서  `return p;
`나 `return &i;`  이코드가 위험한 이유는, 함수가 끝나면 해당 변수들은 존재하지 않게 되기 때문에 위험하다. 몇몇 컴파일러는 에러를 띄운다. 이 경우, static을 쓰거나 파라미터로 받은 포인터를 리턴하면 된다.

#### Q&A

- 포인터는 주소인가?

  대체로 그렇지만, 항상은 아니다. 몇몇 컴퓨터에서 포인터는 offset으로 보는게 더 적절한 경우도 있다.

- `int * const p;` vs `const int *p;`

  `int * const p;` 는 p의 값을 바꾸는 것을 방지한다. (P가 가리키는 대상을 변경하는 것)

  `const int *p;`는 P가 가리키는 대상의 값을 변경하는 것을 방지한다.

  ```C
  void f(const int *p){
      int j;
      *p=0;  // 불가능
      p=&j;  // 가능
  }
  
  void f(int * const p){
      int j;
      *p=0;  // 가능
      p=&j;  // 불가능
  }
  
  ```

  

### 12. 포인터와 배열

#### 12.1 Pointer Arithmetic

```c
int a[10], *p;

p=&a[0]; // 배열a의 첫번째 인자를 가리키는 포인터 p
```

그러나 배열의 한 가지 값만이 아니라 배열의 다른 인자들도 접근할 수 있게 해주는 것이 바로 포인터 연산(pointer arithmetic)이다.

포인터 연산은 다음 세 가지가 있다.

1. 포인터에 정수 더하기
2. 포인터에서 정수 빼기
3. 포인터에서 포인터 빼기

이 세 가지는 다음 선언을 기준으로 설명될 예정이다.

```c
int a[10], *p, *q, i;
```



**Adding an Integer to a Pointer 포인터에 정수 더하기**

포인터에 정수를 더하면 배열에서 해당 숫자만큼 뒤에 있는 공간을 가리키는 포인터가 된다. 이건 어디까지나 배열에 해당 인자가 있다는 전제 하의 예시이다.

```c
p=&a[2];
q=p+3; // q=&a[5]
p+=6; // p=&a[8]
```

**Subtracting an Integer from a Pointer 포인터에서 정수 빼기**

위와 마찬가지로 배열에서 해당 숫자만큼 앞에 있는 공간을 가리키는 포인터가 된다.

```c
p=&a[8];
q=p-3; // q=&a[5]
p -= 6; // p=&a[2]
```

**Subtracting One Pointer from Another 포인터에서 포인터 빼기**

포인터에서 포인터를 빼면 두 포인터 사이의 거리를 의미한다.

```c
p=a[i];
q=a[j];
p-q == i-j
```

**주의점**

- 배열의 인자를 가리키지 않는 포인터로 연산을 할 수 없다.
- 포인터에서 포인터를 빼는 경우 두 포인터는 반드시 같은 배열의 인자를 가리키고 있어야 한다.

**Comparing Pointer 포인터 비교하기**

포인터끼리도 관계 연산자와 같음 연산자로 비교될 수 있다. 이 또한 두 포인터가 같은 배열 속의 인자를 가리키고 있을 때만 해당된다.

```c
p=&a[5];
q=&a[1];

p<=q // false 이기에 0
p>=q // true 이기에 1
```

**Pointers to Compound Literals**

Compound Literals(복합 리터럴) - 이름 없는 배열을 만들 수 있게 해주는 C99의 특성 중 하나.

포인터는 복합 리터럴을 가리키는 것도 가능하다.

```c
int *p = (int[]){3, 0, 3, 4, 1}
// p는 위에서 생성된 배열의 첫번째 인자를 가리키는 포인터가 된다. 
```

#### 12.2 Using Pointers for Array Processing

위에서 살펴본 연산을 사용해서 배열에 들어있는 인자들을 순차적으로 접근할 수 있다. 아래는 for문을 이용하여 배열의 인자들을 모두 더하는 코드다.

```c
#define N 10
...
int a[N], sum, *p;
...
sum = 0;
for(p = &a[0]; p < &a[N]; p++)
{
    sum += *p;
}
```

**p < &a[N]?**

물론 a 배열의 N번째 인자는 존재하지 않기 때문에 해당 형태로 작성해도 되는지 의구심이 들 수 있겠으나, 해당 형태로 작성하는 것은 전혀 문제가 없다고 한다. p가 &a[N]이 되면 루프문은 종료된다.

굳이 포인터가 아니라 subscripting, 즉 a[1], a[2], ...의 형태로 불러와도 상관은 없다. 단 컴파일러에 따라 포인터로 접근하는 것이 실행 속도가 빠르다는 이야기가 있으니 참고하자.

**Combining the * and ++ Operators 포인터* 와 증감연산자 ++ 합치기**

증감연산자 `++, -—`는 포인터에 사용되는 *와 함께 쓰일 때 위치나 괄호에 따라 그 의미가 많이 달라질 수 있으니 주의해야 한다.

배열의 인자를 순차적으로 접근하고자 한다면 우리는 포인터 변수에 1씩 증가를 시키는 방법을 택하게 되는데 이는 아래처럼 작성된다.

```c
a[i++] = j; // a의 i번째 인자에 j를 대입하고 i는 1 증가한다.

p = &a[i];
*p++ = j; // p가 가리키는 a의 i번째 인자에 j를 대입하고 포인터 변수 p에 1을 더한다. 
*(p++) = j; // 위의 문장은 아래처럼 괄호를 묶어 생각하면 된다. 증감연산자는 컴파일러가 가장 먼저 인식하기 때문임을 기억하자. 
```

그 외의 조합도 있는데 조금씩 다른 의미이기 때문에 참고하자.

```c
*p++ // *(p++)과 동일. p가 가리키는 값을 출력하고 p + 1
(*p)++ // p가 가리키는 값을 출력하고 해당 값에 1을 더한다.
*++p // *(++p) p의 값을 1 증가시킨 뒤 p가 가리키는 값을 출력한다.
++*p // ++(*p) p가 가리키는 값을 1 증가시키고 해당 값을 출력한다.
```

#### 12.3 Using an Array Name as a Pointer 배열 이름을 포인터로 사용하기

배열의 이름은 그 자체로 해당 배열의 첫번째 인자를 가리키는 포인터로 활용될 수 있다.

```c
int a[10];

*a = 7 // a[0]에 7이라는 값을 대입한다.
*(a+1) = 12; // a[1]에 12라는 값을 대입한다.

// a+i == &a[i]
// *(a+i) == a[i]

for (p = &a[0]; p < &a[N]; p++)
{
    sum += *p;
}

// 위의 반복문은 배열 이름이 포인터가 되는 점을 활용하여 다음과도 같이 쓸 수 있다. 

for (p = a; p < a+N; p++)
{
    sum += *p;
}
```

**주의점**

배열의 이름은 포인터로 사용할 순 있지만 새로운 값을 대입해주는 것은 불가능하다. 새로운 값이나 연산을 통해 가리키는 곳을 바꾸고 싶다면 포인터 변수 하나를 새로 만들어 그 변수가 참조할 수 있도록 해준 뒤, 해당 변수에 연산을 하거나 대입을 하자.

**Using a Pointer as an Array Name 포인터를 배열의 이름으로 쓰기**

배열의 이름이 포인터가 되듯, 포인터를 배열의 이름으로 쓸 수도 있다. 아래를 참고하자.

```c
#define N 10
...
int a[N], i, sum = 0, *p = a;
...
for(i = 0; i < N; i++)
{
    sum += p[i];
}
```

#### 12.4 다차원 배열과 포인터

일차원 배열과 마찬가지로 다차원 배열의 원소도 포인팅 할 수 있음.

- **다차원 배열에서 원소를 처리하는 법**

  다차원 배열도 행단위의 배열이 메모리 상에 일렬로 나열되어 있는 형태이기 때문에 포인터를 이용하여 순차적으로 접근이 가능하다. (267페이지)

  ```c
  /*모든 원소 0으로 초기화*/
  
  /*이중포문*/
  int row, col;
  for( row = 0; row < NUM_ROWS; row++)
  	for( col = 0; col <NUM_COLS; col++)
          a[row][col] = 0;
  /*---------------------------------------*/
  
  /*포인터를 이용(하나의 포문)*/
  int *p;
  
  for(p = &a[0][0]; p <= &a[NUM_ROWS-1][NUM_COLS-1]; p++)
      *p = 0;
  ```

  다차원 배열을 마치 일차원 배열 처럼 다룰 수 있다. 

  &a\[0][0]은 배열의 가장 첫 주소를 나타낸다.

  오래된 컴파일러에서는 일차원 배열처럼 다루는 것이 효율적인 측면에서 이점이 있지만, 최신 컴파일러에서는 거의 차이가 없다.

  

- **다차원 배열에서 행을 처리하는 법**

  `p = &a[i][0]` 은 i행의 첫 번째 원소의 주소를 포인터에 담는 것

  `p = &a[i][0]` 은 `p=&a[i]` 로 표현 가능하다. ( 1차원 배열에서 `a[i]` 는 `*(a+i)`와 동일하다. 그러므로, 2차원 배열에서는 `&a[i][0]`은 `&( *( a[i] + 0 ) )`와 동일하고  `&*a[i]` 이렇게 변형이 가능하다. *와 &는 상쇄가 되어 `a[i]`로 표현이 가능하다)

  ```c
  /*i번째 행을 0으로 초기화 하는 법*/
  
  int *p, i, a[NUM_ROWS][NUM_COLS];
  ...
  for(p = &a[i]; p < a[i] + NUM_COLS; p++)
      *p = 0;
  ```

   한 행을 1차원 배열 처럼 함수의 아규먼트로 활용 할 수 있다.

  ```CQL
  largest = find_largest(a[i], NUM_COLS);
  ```

  

- **배열에서 열을 처리하는 법**

  ```c
  /*i번째 열을 0으로 초기화 하는 법*/
  
  int i, a[NUM_ROWS][NUM_COLS], (*p)[NUM_COLS];
  ...
  for(p = &a[0]; p < &a[NUM_ROWS]; p++)
      (*p)[i] = 0;
  ```

  변수 선언에서 `int (*p)[NUM_COLS]`는 길이가 int형 배열의 길이가 NUM_COLS 인 배열을 가리키는 포인터를 의미한다. 이때 ()를 생략하면 안된다.(괄호를 생략하게 되면 배열의 포인터가 아닌, 포인터의 배열로 인식함) 

  `p++`은 p를 다음 행의 첫 번째 원소의 주소로 증가시켜준다.

  `(*p)[i]` 은 각 행의 i번째 원소에 접근한는 방법이다. (이때 `*p`자체는 하나의 배열을 의미 한다. 즉 *p는 길이가 NUM_COLS인 1차원 배열의 이름과 같다고 볼 수 있다.) 이때 괄호를 생략하면 안된다.( *p[i]를 *( p[i] )로 해석하기 때문에 )

  

- **다중 배열의 이름을 포인터로 활용는 법**

  `int a[NUM_ROWS][NUM_COLS];` 의 배열의 `a`는 `a[0][0]`의 포인터가 아니라 `a[0]`의 포인터라고 생각하는 게 좋다. `a`의 타입은 `int (*) [NUM_COLS]` (길이가 NUM_COLS인 int형 배열을 가리키는 포인터)
  
  a[0] 는 2차원 배열의 처리를 하는 간단한 방법이다.
  
  ```c
  /*i번 째 열을 초기화 하는 방법*/
  for(p= &a[0]; p<&a[NUM_ROWS]; p++){
      (*p)[i] = 0;
  }
  //아래 방법도 사용가능하다.
  for(p= &a[0]; p< a + NUM_ROWS; p++){
      (*p)[i] = 0;
  }
  ```
  
  다차원 배열을 1차원 배열처럼 사용할 때 주의 해야할 점이 있다.
  
  a와 a[0]의 차이를 먼저 이해해야 한다.
  
  a의 자료형은 `int (*) [NUM_COLS]`으로 a+1을 하면 배열의 길이만큼 메모리를 점프한다.
  
  a[0]의 자료형은 `int(*)`으로 a[0]+1을 하면 int 하나만큼의 길이를 점프한다.
  
  따라서 `largest = find_largest(a, NUM_ROWS * NUM_ COLS)`는 잘못되었다.
  
   `largest = find_largest(a[0], NUM_ROWS * NUM_ COLS)`이 맞는 표현이다.



포인터.. #include <typeinfo>

#### 12.5 포인터와 VLA

- C99에서 가변 길이 배열 

  ```c
  void f(int n)
  {
  	int a[n], *p;
  	p=a;
      ....
  }
  ```

- 다중배열 VLA

  ```c
  void f(int m, int n)
  {
  	int a[m][n], (*p)[n];
  	p=a;
      ....
  }
  ```

  p는 n의 크기에 따라 결정되고  n은 상수가 아니기 때문에, p는 v**ariably modified type** 이라고 불린다. p=a;의 가능여부는 컴파일러에 의해 결정되지 않는다. 예를 들어

  ```c
  int a[m][n], (*p)[m];   // (*p)[n]이 아님..
  p=a;
  ```

  위의 경우 m과 n이 같은 값이 아니라면 비정의 행동을 할 것이다. 따라서 m과 n이 같을 때에만 정상 동작하게 된다.

  VLA처럼 **variably modified type**은 특정한 제약에 지배를 당한다. 가장 중요한 제약은 variably modified type은 함수의 body나 prototype에 선언이 되어야 한다는 것이다.  

  VLA의 Pointer arithmetic은 일반적인 배열의 방식과 동일하게 동작한다.

  ```c
  int a[m][n];
  int (p*)[n];
  
  for (p=a; p<a+m; p++)
      (*p)[i] = 0;
  ```

#### Q&A

- 포인터의 연산은 포인터의 자료형에 의해 결정됨. 포인터에 +1 을하면 int형 포인터는 +4 가된다. double형 포인터는 +8이 된다.



### 13. 스트링

#### 13.1 String Literals 문자 리터럴

*string literals* (문자 리터럴)이란 "큰 따옴표 안에 들어가있는 문자들"을 의미한다.

```c
"이것은 문자 리터럴입니다."
"This is what string literals look like."
```



- Escape Sequences in String Literals 스트링 리터럴 속 이스케이프 시퀀스

Escape sequence는 `\`(역슬래시)뒤에 캐릭터를 붙여서 개행이나 여백 등 특정한 형태의 모양을 출력해준다. `\` 뒤에 8진수, 16진수의 코드가 와도 무방하나 잘 사용하지는 않는다.

**주의점**

`\` 뒤에 8진수가 오는 경우 최대 세자리까지만 입력할 수 있다.

16진수 코드는 16진수 문자가 아닌 것을 만나면 코드가 끝인 것을 인식한다.

```c
"\1234" // \123에 문자 4가 붙은 형태로 이해하면 된다.
"\xfcber" // \xfc에서 보통은 끊어주겠지만 c나 b도 16진수라 컴파일러 따라 다르게 나올 수 있는 점 주의
// "\xfc""ber"라고 표기하면 된다고 한다.
```



- Counting a String Literal 스트링 리터럴 카운팅

`\` 를 이용해서 코드 작성 단계에서 줄바꿈을 표시해줄 수 있다 (실제 출력창 개행이 아님). 단 역슬래시 뒤에 다른 문자가 오면 안 되고 해당 줄의 마지막 문자여야 한다.

```c
printf("Hello world. \
This is a new line but not printed as a new line.");
```

역슬래시를 활용한 코드 작성 단계의 개행은 꼭 String에만 한정된 것은 아니다. 다만 String의 경우 편의를 위해 두 개의 string literal이 나란히 적혀있다면, 중간에 공백은 무시하고 그 둘을 하나로 이어준다. 그렇기에 아래와 같이 작성해도 무방하다.

```c
printf("Hello world."
			 "This is a new line but not printed as a new line.");
```



- How String Literals Are Stored 스트링 리터럴이 저장되는 방식

`String`은 단순히 요약하자면 `character`의 배열이다.

C 파일러가 `n`의 길이를 갖는 스트링 리터럴을 만나면 메모리에 `n+1` 바이트의 공간을 확보한다. +1의 공간은 `null character`가 담기는 공간으로 스트링 리터럴의 끝을 의미한다.

`null character`는 비트가 모두 0인 바이트로 `\0`으로 표현되기도 한다.

**주의점**

`null character` `\0` 와 `0`은 다른 것을 기억하자. null character의 코드는 0이지만 '0'은 아스키 기준 48번이다.

**결국 스트링 리터럴은 `char` type의 배열에 들어가있기 때문에 컴파일러는 스트링 리터럴을 `char`타입의 포인터로 취급한다.**

```c
printf("abc");
```

→ printf 함수가 호출되면 "abc"의 주소를 넘겨주는 것이다 (문자 'a'가 담겨있는 공간을 가리키는 포인터)



-  Operations on String Literals

```c
char *p;

p = "abc";
// p에 문자 a, b, c가 복사되어 들어가는 것이 아니라 a, b, c가 담긴 배열을 가리키는 포인터

char ch;
ch = "abc"[1]; // ch는 'b'라는 char타입의 값이 담긴다.
```

**주의점**

스트링 리터럴은 포인터지만 간접 참조로 값을 바꾸려고 하면 오류가 발생한다.

```c
char *p = "abc";

*p = 'd';  // 오류
```



- String Literals versus Character Constants 문자 리터럴 vs 문자형 상수

"a"라는 한 개짜리 문자가 담겨있는 문자 리터럴과 'a'라는 character가 담긴 문자형 상수는 엄연히 다른 개념이다.

전자는 character 'a'가 담겨있는 메모리 위치를 가리키는 포인터의 개념이고,

후자는 'a'에 해당하는 정수값이 담긴 개념이다

**주의점**

```c
printf("\n"); // printf는 포인터를 인자로 받기 때문에 올바른 문법
printf('\n'); // 잘못된 사용법. 문자형은 포인터가 아니기 때문.
```



#### 13.2 String Variables 스트링 변수

스트링은 null character를 마지막 인자로 가지는 character의 배열이다. 만약 char의 배열을 만들어놓고 여기에 string을 담고 싶다면  null character를 빼먹지 않도록 조심해야 한다.



```c
#define  STR_LEN 80
...
char str[STR_LEN+1]; 
```



→ 길이 80의 char 배열을 생성하는 코드. 단, +1은 마지막 null character위해 작성하는 것으로 스트링을 담을 char의 배열은 항상 길이보다 +1로 생성해주는 것이 좋다.



→ 길이가 81이라고 해서 무조건 해당 배열이 81의 길이를 갖는 것은 아니다. 스트링의 길이는 어디까지나 null character를 기준으로 판단되기 때문이다.



- **Initializing a String Variable 스트링 변수 초기화하기**

```c
char date1[8] = "June 14";
```

→ "June 14" 자체가 문자 리터럴이라기보다, C의 입장에선 배열 선언을 위한 축약된 문구로 인식된다고 이해하면 편하다. 위의 코드는 다음과도 같기 때문이다.

```c
char date1[8] = {'J', 'u', 'n', 'e', ' ', '1', '4' , '\0'};
```

만약 배열의 길이가 문자 리터럴보다 길다면 남는 공간은 `\0` 으로 채워준다.

**주의점** 

배열의 길이가 짧은 경우, 채울 수 있는 데까지만 채우고 뒤에 와야할 `\0`을 누락해버리니 주의!

문자 리터럴은 길이를 늘 파악하기가 힘들기 때문에 편의를 위해 배열의 길이를 비워두고 선언할 수도 있다.

```c
char date4[] = "June 14";
// 컴파일러가 알아서 8칸을 생성하고 값을 넣어준다.
// 단, 길이가 가변적인 것이 아니라 생성 시에 알아서 길이를 고정시키는 것 뿐.
```



- Character Arrays vs Character Pointers

문자 리터럴을 `char`배열을 선언해서 넣어주는 것과, 포인터 변수를 선언하여 대입해주는 것은 차이가 있다.

```c
char date[] = "June 14"; // date는 배열
// vs
char *date = "June 14"; // date는 포인터
```

단순히 `char`배열의 포인터를 넘겨주는 상황이라면 두 형식 모두 `date`를 넘겨주면 된다.

그러나 두 선언이 같은 의미인 것은 아니다.



**`date[]` 선언**

- **date 배열 안에 담긴 값들이 수정될 수 있다.**
- date는 배열의 이름이다.



**`*date` 선언**

- 13.1에서 본 것처럼 포인터 변수로 선언된 문자 리터럴은 수정할 수 없다. 아래는 위에서 보았던 예시이다.

  ```c
    char *p = "abc";
    *p = 'd'; // 오류
  ```

- 포인터의 경우 나중에 다른 strings를 가리키게 할 수도 있다.

  char *p; // 이렇게만 하면 string을 가리키는 포인터로 사용 불가

  p[0] = 'a'; // 오류. p가 어딜 가리키고 있는지 알 수가 없기 때문.

  char str[STR_LEN+1], *p; // STR_LEN+1길이의 문자배열 및 포인터 변수 p 선언 
  
  p=str; // 포인터 p는 str배열의 첫번째를 가리키게 된다.
  
  → 이렇게 선언한다면 p를 스트링처럼 사용할 수 있게 된다.



#### 13.3 Reading and Writing Strings 스트링 읽기와 입력

- Writing Strings Using `printf`and `puts`



```c
char str[] = "Are we having fun yet?";
printf("%s\n", str);

// Are we having fun yet? 이 출력된다.
```



→ `printf`의 원리는 `string`에 담긴 문자를 하나하나 출력하다가 null character를 만나면 멈추는 것이다. (만약 null character가 없다면 메모리를 계속 뒤져가며 null character가 언젠가 나오면 멈춘다고 한다)



부분만 출력하고 싶다면 아래처럼 쓸 수 있다.



```c
pritnf("%.6s\n", str);

// Are we 라고 출력된다. %.ps에서 p가 출력할 문자의 개수를 의미한다. 

char str[] = "AAAAAA";
printf("%10.3s\n", str);

//"       AAA" 형태로 터미널에 출력된다.
```



`printf` 말고도 문자열을 출력할 수 있는 함수로는 `puts`가 있다.



```c
char str[] = "AAAAAA";
puts(str);
puts(str);

// AAAAAA
	 AAAAAA
	 형태로 출력된다.
```



- Reading Strings Using `scanf` and `gets`



```
char str[10];
scanf("%s", str);
// str은 이미 배열이기에 저 자체로 포인터라 &가 필요하지 않다.
// 저 한 줄만 실행하면 입력할 때마다 str[0]의 값으로 넣게 된다.
gets(Str);
```



`string`을 읽어오는 경우(문자를 읽어오는 것과는 다르다. 문자는 `%c`로 읽어오고 스트링은 `%s`로 읽어오며 함수 내에서 취급 방법이 다르다)



**공통점**



`scanf`와 `gets`함수 모두 마지막에 null character를 저장한다.



**차이점**



**`scanf`**



- white space를 읽지 않는다. 즉, 개행이나 여백을 만나면 그 뒤는 읽어오지 않고 멈춘다.



**`gets`**

- white space를 포함해서 읽는다 (스킵하지 않는다).

- 개행 기호를 만나면 멈춘다. (개행 기호 자리에 null character를 대체시킨다)

  // "Hello My name is Grace"를 입력하면

  char str[30]; 

  scanf("%s", str); 

  printf("%s", str); 
  
  // "Hello"만 출력한다. 첫 공백 뒤가 담기지 않은 것.
  
  gets(str); 
  
  printf("%s", str); 
  
  // "Hello My name is Grace"를 출력한다.



***cf) white space란?***



컴퓨터에서 콘솔이나 프린터로 찍었을 때 공백을 표현하는 문자들을 의미한다. (Alternatively referred to as spacing or white space, white space is any section of a document that is unused or space around an object.)



```c
' '      space 
'\t'     horizontal tab 
'\n'     newline
'\v'     vertical tab 
'\f'     feed 
'\r'     carriage return
```



특정 기호가 화이트 스페이스인지 아닌지 확인하고자 한다면 `ctype.h` 라이브러리의 `isspace` 함수를 활용하는 방법이 있다.



**주의점**



`scanf`도 `gets`도 입력받은 string이 배열의 길이를 초과하는지 자동으로 파악할 수는 없다.

`scanf`의 경우는 입력받을 때 길이를 정해두기 위해 `%ns`라고 적어서 n개의 문자만을 저장하게 강제할 수 있다.

gets는 이런 안정 장치가 없기 때문에 `fgets`라는 것을 사용하는 걸 추천하고 있다.



- Reading Strings Character by Character



`scanf`와 `gets`는 위험 요소가 있기 때문에 개발자들은 종종 input을 위한 함수를 직접 만들기도 한다. 이런 함수를 만들 때 고려해봄직한 부분들은 아래와 같다.



- 화이트스페이스를 스킵할 것인가?
- 읽어오는 동작이 어떤 문자를 만나면 정지할 것인가? 또 이 문자를 스트링에 저장할 것인가 말 것인가?
- 입력받은 내용이 너무 길면 어떻게 처리할 것인가? 남은 문자는 버릴 것인가 아니면 다음에 입력받도록 남겨둘 것인가?



책에서는 아래의 예시를 코드로 나타내는 법을 설명해준다:



화이트스페이스를 무시하지 않고, 개행 기호를 만나면 입력받는 것을 정지하며, 읽지 않은 나머지 문자들은 버리는 함수.



```c
// prototype 선언
int read_line(char str[], int n);

// 메인 함수
int main(void){
  char a[10];

  read_line(a, 10); // abcdefghijklmnop 를 입력하면
  printf("%s", a); // abcdefghij 까지만 출력된다.
}

// 본 함수
int read_line(char str[], int n) {
	int ch, i = 0;

	while ((ch = getchar()) != '\n') {
		if (i < n) {
			str[i++] = ch;
		}
	}

	str[i] = '\0';  /* 스트링 종료 */
	return i;  /* 담긴 문자의 개수 */
}
```



***cf) `getchar` 함수***



- 단 하나의 문자를 입력받는 함수

- 함수를 사용할 때 인자를 따로 넘겨주지 않아도 된다.

- 입력받은 문자를 int로 반환해준다.

  char a; a=getchar(); //asdfj라고 입력해도 a만 넣어진다.

#### 13.4 Accessing the Characters in a String 스트링 안의 문자 접근하기

문자열 또한 배열의 형태를 띄고 있기에 subscription으로 접근이 가능하다.

문자열 안에 공백의 개수를 알고 싶다면?

```c
int count_spaces(const char s[]) {
// const를 표기하여 배열이 변경되지 않는 걸 명시
// s는 문자열이라 컴파일러가 길이를 알기에 길이를 인자로 받을 필요가 없다.
	int count = 0, i;

	for (i = 0; s[i] != '\0'; i++) {
		if (s[i] == ' ') {
			count++;
		}
	}

	return count;
}
```

위의 코드는 포인터 연산을 활용하여 변수 `i`를 제거하고 다시 작성할 수 있다.

```c
int count_spaces(const char *s) {
	int count = 0;

	for (; s != '\0'; s++) {
		if (*s == ' ') {
			count++;
		}
	}

	return count;
}
```



→ 여기서 `const`가 붙어있는 이유는 함수가 포인터`s`가 담는 주소를 변경시키지 못하게 하기 위함이 아니라, **포인터`s`가 가리키는 값을 변경하지 못하도록 적어준 부분이다**. (아래와 동일. 참고) 함수 안의 **`s`는 그저 인자로 받은 포인터가 복사된 것에 불과하기 때문에 얼마든지 변경 가능.**s

```c
int f(const int *p){
	*p = 0;  // 불가
}
```

위의 두 가지 예시 중 어느 것이 더 효율적이거나 올바른 건 아니기에 둘 다 사용해도 무방하다. 단 전통적인 C 프로그래밍에선 배열은 포인터로 접근하는 편이라고 설명하고 있다.

파라미터에 `s[]`, `*s` 둘 중 어떤 형태이든 호출 시 배열 이름, 포인터, 문자 리터럴 모두 인자로 적을 수 있다. 모두 일종의 포인터 개념이라 차이가 없기 때문.



#### 13.5 Using the C String Library

문자열은 연산자를 활용해 복사나 비교가 불가하다. 배열의 이름은 lvalue가 될 수 없기 때문.

```c
char str1[10], str2[10];

str1 = "abc"; // 불가
str2 = str1; // 불가
```



단, 선언 `=`를 사용할 수 있다. 이런 경우, `=`가 대입연산자는 아니라고 한다.



```c
char str1[10] = "abc";
```



관계 연산자로 문자열을 비교할 수는 있으나, 두 배열의 내용을 비교하는 것이 아니라 포인터로서의 비교만 실행된다. 만약, 같은 내용을 가지있어도, 다른주소를 가지고 있다면 0을 출력할 것이다.



```c
if (str1 == str2) ... // 결과는 0이다. 둘은 다른 포인터이다.
```



문자열은 여러가지로 까다롭기 때문에 C에선 `string.h` 라이브러리를 제공해주고 있다.



- 라이브러리

```c
#inclue <string.h>
```



string 라이브러리 안의 대부분의 함수는 보통 인자로 하나 이상의 문자열을 받도록 되어있다. 문자열은 보통 `char *` 형태로 선언되기 때문에 문자배열이든, `char *` 타입의 변수든 문자 리터럴이든 관계는 없다.



**✔`strcpy` 함수**



문자열s2를 s1에 복사하는 함수. (정확히는 s2가 가리키는 배열을 s1이 가리키는 배열에 복사하는 것) s2의 첫번째 null character가 있는 지점까지 복사하게 된다 (null character도 복사된다)



```c
char *strcpy(char *s1, const char *s2);
```



→ s1을 return한다. (s1이 가리키는 내용)

→ s2가 가리키는 배열은 변형되지 않기 때문에 const를 붙여준다.



배열에는 대입 연산자가 불가하기 때문에 이미 선언된 배열, 혹은 문자열의 내용을 변경하고 싶을 때 사용하면 좋은 함수



```c
char str1[10];
char str2[5]="Hello";

strcpy(str1, str2);
strcpy(str1, "abcd");
```



리턴값이 s1인 걸 활용해서 중첩해서도 활용이 가능하다.

```c
strcpy(str1, strcpy(str2, "abcd"));
// str1, str2 모두 "abcd"로 변경된다. 
// strcpy(str2, "abcd")의 리턴값이 "abcd"이기 때문.
```



**주의점**

`strcpy`함수는 두 배열의 길이를 자동으로 파악하지 못한다. 복사되는 값이 배열의 길이를 초과하면 알 수 없는 오류가 일어날 수 있다.



**✔`strncpy`함수**



`strcpy`와 비슷하나 복사할 문자의 개수를 한정하는 인자가 추가된다.

```c
strncpy(str1, str2, sizeof(str1));
// sizeof를 이용해서 str1의 길이가 허용하는 만큼만 복사.
// char 하나의 크기는 sizeof함수를 쓰면 1이다. 1byte이기 때문
```

길이를 str1의 사이즈로 지정해중저도 str2의 길이가 더 길다면 마지막 문자로 null character를 복사해주는 것은 아니기 때문에 조금 더 안전하게 복사하자면 아래와 같이 쓸 수 있다.

```c
strncpy(str1, str2, sizeof(str1) - 1);
str1[sizeof(str1)-1] = '\0';
```



**✔`strlen`(String Length) 함수**



**문자열 `s`의 길이를 반환한다. null character는 길이에 포함하지 않는다. (`sizeof`로 접근하면 null character를 포함한다)**



```c
size_t strlen(const char *s);
// size_t는 unsigned integer를 나타내는 typedef이다.
// 리턴되는 값은 결국 정수라고 생각하면 된다.

int len;
len = strlen("abc");  // len 은 3이다.
len = strlen("");  // len은 0이다.
```



**✔`strcat`(String Concatenation) 함수**



`s2` 문자열을 `s1` 문자열 뒤에 이어준다. 호출하면 이어붙인 s1이 return된다.



```c
char *strcat(char *s1, const char *s2);

strcpy(str1, "abc");
strcat(str1, "def");  // str1은 "abcdef"
```



그러나 `strcat`함수 또한 s1의 길이를 초과하여 이어붙이게 되면 오류가 된다.



**✔`strncat` 함수**



strncpy와 마찬가지로 길이와 관계된 인자가 추가된 함수. 복사할 문자의 개수를 지정해준다.



```c
strncat(str1, str2, sizeof(str1)-strlen(str1)-1);
str1[sizeof(str1)-1] = '\0';
// str1의 길이에서 str1이 담고있는 문자열의 길이를 빼고
// null character공간을 위해 1을 빼주면 남은 공간이 나온다.
// 해당 공간의 크기를 세번재로 인자로 넘겨주면 넘치지 않게 이어붙여준다.
```



**✔`strcmp` (String Comparison) 함수**



문자열간의 비교를 가능하게 해주는 함수. 관계연산자(`<, ≤, <, ≤`)와 동등연산자(`==, !=`)를 활용하여 비교를 할 수 있도록 해준다.

리턴값은 s1과 s2가 처음으로 다른 문자열일 경우 해당 문자(char)의 차이를 리턴한다.

같으면 0을 리턴

```c
// prototype 선언
int strcmp(const char *s1, const char *s2);

// str1 < str2?
if (strcmp(str1, str2) < 0)

// str1 <= str2?
if (strcmp(str1, str2) <= 0)
```



**문자열을 비교하는 기준이란?**



두 문자열을 앞에서부터 비교해나가면서 같은 위치에 동일한 값이 아닌 경우, 아스키코드상 작은 값이 작다고 판단된다. 내용이 겹치고 길이만 다르다면 긴 것이 더 크다.



```c
"abd" < "abe"
"abc" < "abcd"
```



**ASCII 관련**



- 순서가 있는 문자들은 모두 순차적인 코드를 갖는다.  (A~~Z, a~~z 등등)
- 대문자는 소문자보다 작다 (코드에서 앞에 있기 때문)
- 숫자는 문자들보다 앞이다.
- space는 모든 문자들보다 앞선다 (아스키코드 32번)



#### 13.6 String Idioms

`strlen`과 `strcat` 재구현해보자. 단, str 관련 함수들은 이름이 이미 정해진 게 많으니 `my_strlen` 아니면 아예 다른 이름으로 지정하는 게 좋음.



- Searching for the End of a String



`strlen` 함수를 풀어 써보면 아래와 같다.



```c
size_t strlen(const char *s){
   size_t n;

   for (n=0; *s != '0'; s++){
      n++;
   }

   return n;
}
```



조금 더 속도를 위해 함수를 변경해본다면 아래와 같다.



```c
size_t strlen(const char *s){
   size_t n=0;

   while(*s++){
      n++;
   }

   return n;
}
```



포인터-포인터=길이 개념을 이용해서 아래와 같은 식으로 속도를 올리는 코드를 작성해볼 수도 있다.



```c
size_t strlen(const char *s){
   const char *p = s;

   while (*s){
      s++;
   }
 
   return s-p; // 위치를 이동한 만큼을 길이로 뱉어준다.
}
```



→ 해당 형태가 속도가 빨라질 수 있는 건 `while`문 안에서 `n`을 증가시켜주지 않아도 되기 때문이다.



```c
while(*s){
  s++;
}
// s가 null character가 있는 위치를 가리키게 된다. 
// 아래처럼도 쓸 수 있다.
// 단, 아래 형식은 null character 다음 공간을 가리키게 된다.

while(*s++){
  ;
}
```



위의 표현은 "문자열 끝의 null character를 찾기" 의 idiom이다.



- **Copying a String**



s1에 s2를 이어주는 함수 `strcat`은 아래와 같이 풀어 쓸 수 있다.

```c
char *strcat(char *s1, const char *s2){
  char *p = s1;

  while(*p != '\0'){
    p++;
  }
  while(*s2 != '\0'){
    *p = *s2;
    p++;
    s2++;
  }
 
  *p = '\0';
  return s1;
}
```



위의 예시처럼 해당 코드도 포인터 개념과 while문의 특성을 활용하여 조금 더 단축시킬 수 있다.

```c
char *strcat(char *s1, const char *s2){
  char *p = s1;
  
  while(*p){
    p++;
  }
  while(*p++ = *s2++){ // while문의 조건문에 대입이 발생한다면 대입되는 값을 넘겨준다고 보면 된다.
  // *s2가 0이라도 대입은 먼저 발생하고 그 뒤에 while문에 0을 대입하기 때문에 null character도 자동으로 복사가 된다.
  // 컴파일러따라 오류가 날 수도 있는데 그 때는 while((*p++ = *s2++) != 0) 혹은 while((*p++ = *s2++)) 로 적어줄 수 있다고 한다. 
    ;
  }

  return s1;
}
```



#### 13.7 Array of Strings



```c
char planets[][8] = {"Mercury", "Venus",
                     "Mars", "Jupiter"};

// 문자열의 배열은 배열을 배열 안에 넣어두는 형태이기 때문에 2차원 배열로 정의한다.
// 행의 개수는 자동으로 들어간 문자열의 개수가 되기 때문에 굳이 명시하지 않아도 무방하다.
// 단 최대 길이 때문에 열의 개수를 명시해야 한다.
```



위의 형태로 문자열의 배열을 만든다면 직관이지만 모든 문자열의 길이가 8로 고정된다는 단점이 있다. 이렇게 되면 "Mars" 같이 짧은 문자열은 여백이 많이 남아 메모리를 비효율적으로 사용하게 된다. 이 때 적용할 수 있는 것이 포인터 배열이다.



```c
char *planets[] = {"Mercury", "Venus",
                     "Mars", "Jupiter"};

// 배열의 칸마다 각각의 문자열이 들어있는 배열을 가리키는 포인터가 담기게 된다.

planets[0][0]=='M' // true
planets[1][2]=='n' // true

// M으로 시작하는 문자열만을 출력하려면?
for(i=0; i<4; i++){
  if(planets[i][0]=='M'){ // "M" 이 아니라 'M'
    printf("%s begins with M\n", planets[i]);
  }
}
```



- Command-Line Arguments



C의 main 함수에 파라미터를 표기하여 실제 컴파일 단계에서 커맨드 창을 통해 값을 받아와 활용할 수 있다.



```c
int main(int argc, char *argv[])
{
  ...
}

// argc는 커맨드 창에 입력할 문자열 개수 (프로그램명 포함), 즉 argv 배열의 길이-1
// argv[]는 입력한 문자열들을 가리키는 포인터 배열
// argv[0]은 프로그램명을 가리키는 포인터, argv[1] ~ argv[argc-1]는 나머지 입력값, argv[argc]는 null pointer

// argc, argv라는 작명은 convention(관례)일뿐, 원한다면 다른 걸로 적어도 작동한다. 
```



입력받은 내용들을 출력하고 싶다면 아래처럼 접근할 수 있다.



```c
int main(int argc, char *argv[])
{
	char **p;

	for(p=&argv[1]; *p != NULL; p++){
  		printf("%s\n", *p);
	}
    ...
}

// argv[1]은 풀어보면 argv배열의 2번째 인자인 문자열의 첫번째 인자, 즉 첫번째 문자를 가리킨다. 입력창에 프로그램명 뒤 Jupiter라고 입력했다면 'J'를 가리킨다.
// &argv[1]는 위에서 설명한 포인터를 가리키는 포인터. 즉 p는 이중포인터이다.
// *p도 결국 포인터이고 NULL이라는 것도 포인터기 때문에 비교가 가능한 것이다. *p가 빈 것을 가리키면 for 문은 종료된다.
```



#### Q&A



- `Printf`의 인자가 문자 포인터라면 해당 자리에 문자 리터럴 대신에 문자열이 담긴 변수를 적어도 되나요?

넵

```c
char fmt[] = "%d\n";
int i;
...
printf(fmt, i);

// printf("%d\n", i); 와 똑같은 형태이나 왼편에 적어준 문자 리터럴을 배열에 담아두고 배열 이름을 대신 적은 것.
```



- `Printf`로 `str`문자열을 출력하고 싶을 때 그냥 `printf(str);`이라고 해도 되나요?



```
가능하지만 만약 문자열이 '%'를 포함하고 있다면 원치 않는 형태로 작동할 수 있기 때문에 위험이 있다.
```



- `**argv` 와 `*argv[]`는 같나요?



```
파라미터를 선언할 때는 아래 두 개는 같은 의미이다.
*a == a[] // 둘 다 결국 포인터를 받겠다는 소리. 배열의 이름이 그 자체로 포인터인 점을 참고하자.

// 다만 이는 어디까지나 a가 배열의 이름일 때만 컴파일러가 알아서 해독해준다. 
// *a[]는 포인터들을 인자로 갖는 배열, 즉 포인터 배열 선언인 걸 잊지말자.
```



### 14. 전처리기

#### 14.1 how the preprocessor works

\#표시가 붙은 것들을 처리하는게 전처리기가 하는 일

- \#define: 매크로, 어떤 값을 대신하는 이름을 정의함. 사전에 정의된 값을 매크로와 바꿔줌
- \#include: 특정한 파일을 열어서, 해당 내용을 불러오는 파일의 일부로 포함한다.
  [![img](https://camo.githubusercontent.com/034f37a1bf9d966d1bdbbe4f6a75657720c33635/68747470733a2f2f726567756c6172636f6465732e636f6d2f696d616765732f7069636b2f632d70726570726f636573736f722e706e67)](https://camo.githubusercontent.com/034f37a1bf9d966d1bdbbe4f6a75657720c33635/68747470733a2f2f726567756c6172636f6465732e636f6d2f696d616765732f7069636b2f632d70726570726f636573736f722e706e67)
  - 전처리기는 지시어가 포함된 C프로그램을 입력받아, 지시어를 처리한 c프로그램을 출력한다.
  - 출력된 c프로그램은 에러 검사 후 object코드로 바꾸기 위해 컴파일러로 보낸다.
- 전처리기는 **주석**도 공백으로 치환함.
- 요즘 전처리기는 컴파일러의 일부로 포함되어 있다.
- 전처리기는 에러검사를 하지 않기에, 에러가 발생할 여지가 있다. 그리고 이 경우 디버깅이 어려울 수 있음.

#### 14.2 general rules of Directives

- 지시어는 주로 세 가지로 분류됨.

1. Macro definition 
   - \#define(매크로 정의), #undef(매크로 해제)
2. File inclusion 
   - \#include
3. Conditional compilation 
   - \#if, #ifdef, #ifndef, #elif, #else, #endif : 조건에 따라 코드 블록을 포함함.
4. 나머지는 #error, #line, #pragma

- general rule

- always begin with the '#'
- 내용 구분에 사용되는 공백은 여러 개 써도 상관없음
  `#         define           N         100 `
- 라인피드로 구분됨 (여러 줄을 작성하고 싶다면 `\\'를 사용할 것)

```c
# define SEVERAL_LINE (SIDES * \
                        TRACKS * \
                        SECTORS * )
```

- 어느 위치에서든 선언 가능

#### 14.3 Macro Definitions

- Simple macro (non-parameter)

```c
#define 식별자 정의
```

- 값에는 식별자, 키워드, 숫자, 문자, 문자열, 연산자, 구두점이 올 수 있다.

- 코드 가독성에 좋다.

- 수정하기 쉽다. (전체 값이 아닌 매크로에 정의된 값 하나만 고치면 되므로)

- 오타를 잡아내기 쉽다. (숫자는 오타내도 알아보기 힘들다.)

- C의 문법을 커스텀할 수 있다. 

  ```c
  #define BEGIN {
  #define END }
  ```

- 타입의 이름을 바꿀 수 있다. 

  ```
  #define BOOL int
  ```

- 조건 컴파일을 제어한다. 

  ```
  #define DEBUG //디버깅 모드
  ```

- 상수로 사용할 땐 대문자로 쓴다. (다른 용도로 사용할 때에 대해선 합의가 없음.)

- Parameterized Macro

```c
#define 식별자 (x, y, z, ... , k) 정의
#define MAX(x,y) ((x) > (y) ? (x) : (y))
#define IS_EVEN(n) ((n) % 2 == 0)
```

- 간단한 함수로 사용된다.

- 인자가 없을 수도 있다.

- 퍼포먼스가 향상 됨. (런타임 오버헤드:함수는 인자를 카피해야함. inline function은 매크로 사용없이 오버헤드를 제거함. )

- '제네릭'하다. => 인자 타입을 체크하지 않음(여러 타입을 하나의 매크로로 사용 가능)

- 컴파일 된 코드 사이즈가 크다.

- 매크로를 가리키는 포인터 사용 불가

- **매크로는 인자를 한 번 이상 평가할 수 있음. (함수는 한 번인데)** 

  주의!!
  
  ```c
  //전처리 전 코드
  n = MAX(i++, j)
  //전처리 후 코드
  n = ((i++)>(j)? (i++) : (j)) //i가 참일 시에, 두 번 평가됨
  ```

-중복되는 코드를 축약해 사용할 수 있다.(snippet)

```c
#define PRINT_INT(n) print("%\n", n)
```

- **\# Operator**

> 매크로의 값 부분에는 #과 ##연산자를 사용할 수 있다.

​	\#연산자는 macro의 인자를 string으로 변환시킨다.(stringization) 

```c
#define PRINT_INT(n) printf(#n " = %d\n", n)
PRINT_INT(i/j);
//아래와 같이 치환됨 (문자열로 바뀜)
printf("i/j" " = %d\n", i/j); // 이건 자동으로 합쳐짐(13.1)
```

- **\## Operator**

  \##연산자는 두 개의 토큰을 하나의 토큰으로 만들 수 있다. (잘 사용되진 않음) 

  다른 문자나 숫자와 연속으로 연결되어 사용될때 구분자 역할을 해줌

  ```c
  #define MK_ID(n) i##n
  
  //전처리 전 코드
  int MK_ID(1), MK_ID(2)
  //전처리 후 코드
  int i1, i2
  ```

- General Properties of Macros
  
  - 매크로의 값은 다른 매크로를 불러올 수도 있다.

```c
  #define PI 3.14159
  #define PIPI (2*PI) //rescan 대상
```

- 매크로를 부르려면 토큰 전부가 매크로의 식별자여야 한다.
- 매크로는 파일 끝까지 효과가 지속된다.
- **중복되게 매크로를 정의하지 말아라.**
- \#undef를 사용하면 매크로를 해제할 수 있다.

매크로의 정의 속 괄호

- 매크로가 잘못된 결과를 출력할 수 있기에, 적절하게 괄호를 넣어주어라. (컴파일러가 연산자 우선순위를 헷갈릴 수 있음)
- 괄호를 넣는 규칙 2가지 
  - 매크로 정의에 연산자가 들어있을 경우
  
  - 매크로가 인자를 가지고 있을 경우
  
    ```c
    #define TWO_PI 2*3.14159
    
    conversion = 360/TWO_PI;
    =>치환 결과
    360/2*3.14159;
    =>의도와 다름..
        
    #define TWO_PI (2*3.14159)
    
    conversion = 360/TWO_PI;
    =>치환 결과
    360/(2*3.14159);
    
    ----
        
    #define SCALE (x*10)
    
    SCALE(i+1)
    =>치환 결과
    (i+1*10)
    =>의도와 다름..
        
    #define SCALE ((x)*10)
    
    conversion = 360/TWO_PI;
    =>치환 결과
    ((i+1)*10)
    ```
  
    

**creating Longer Macros**

- 콤마(,) 연산자를 사용한다. 

  ```c
  #define ECHO(s) (gets(s), puts(s))
  ```

**predefined Macros**

- 먼저 정의된 매크로는 문자열이나 정수를 나타냄
- `__DATE__`, `__TIME__`:버전 관리할 때 용이함.
- `__LINE__`, `__FILE__`:디버깅할 때 용이함.

| name       | Description                            |
| ---------- | -------------------------------------- |
| `__LINE__` | 컴파일 된 파일의 해당 코드의 라인 넘버 |
| `__FILE__` | 컴파일 된 파일의 이름                  |
| `__DATE__` | 컴파일 날짜                            |
| `__TIME__` | 컴파일 시간                            |
| `__STDC__` | 컴파일러가 C스탠다드를 준수하면 1출력  |

**Empty Macro Arguments**

- c99는 인자를 생략해도 된다.

```c
#define ADD(x,y) (x+y)
i = ADD(,k)
```

**Macros with a Varable Number of arguments**

- ...연산자를 사용해서 인자를 여러개 받을 수 있다.

- ...연산자로 받은 인자를 나타낼 때는 `__VA_ARGS__` 매크로를 활용함

  ```c
  #define TEST (condition, ...)	((condition) ? printf("test : %s\n", #condition) : print(__VA_ARGS__))
  
  TEST(voltage <=max_voltage, "Voltage %d exceeds %d\n", voltage, max_voltage);
  
  //결과
  //test : voltage <= max_voltage
  //Volatge 125 exceeds 120
  ```

  

**The func Identifier**

- 이 식별자는 실행 중인 함수의 이름을 string으로 반환한다.

- 전처리기에서는 아무 것도 안함.

- 디버깅에 유용하다.

- 모든 함수는 `__func__`식별자에 접근할 수 있다.

  ```c
  #define FUNCTION_CALLED() printf("%s called\n", __func__);
  
  void f(void)
  {
      FUNCTION_CALLED();
  }
  //결과
  //f called
  ```

  

#### 14.4 Conditional Compilation

- 프로그램 코드를 포함할 것인가 제외하고 컴파일할 것인가.
- 전처리기가 테스트를 수행한 결과에 따라 결정

**#if & #endif**

```c
#if 상수표현식// 상수표현식이 0이면 false, 그렇지 않으면 true 
...
#endif
//----------------------------------------//
//디버깅 상황
#define DEBUG 1

#if DEBUG //디버깅 중이라면
printf("value of i: %d", i)
#endif
```

**defined Operator**

- 매크로 식별자 앞에 `defined`를 붙여주면 정의된 매크로이다 => 1

- 정의되지 않은 매크로식별자이다 => 0을 반환

- 보통 #if와 같이 쓰임 

  ```c
  #if defined(DEBUG) //괄호는 써도되고 안써도됨
  ..
  #endif
  ```

**#ifdef & #ifndef**

- \#ifdef = #if + defined

  ```c
  #ifdef identifier
  ...
  #endif
  //아래와 같은 의미
  #if defined (identifier)
      ...
  #endif
  ```

  

- \#ifndef = #if + !defined

  ```c
  #ifndef identifier
  ...
  #endif
  //아래와 같은 의미
  #if !defined (identifier)
      ...
  #endif
  ```

  

**#elif & #else**

- elif : else if 

  ```c
  #if expression1
  ~~~~~
  #elif expression2 //expression1이 0인데, expression2는 0이 아니라면
  ~~~~~
  #else //위에 expresion들이 모두 0이라면 
  ~~~~~
  #endif
  ```

  

**uses of conditional compilation**

- 여러 머신에서 써야할 때, 기계마다 코드를 다르게 가져감

- 여러 컴파일러를 사용할 때, 컴파일러마다 코드를 다르게 가져감

- 매크로에 디폴트값을 줌(매크로가 선언이 안되어있다면, 조건부 컴파일로 매크로에 디폴트값 할당)

  ```c
  #if defined (WIN32)
  ...
  #elif defined (MAC_OS)
  ..
  #elif defiend (LINUX)
  ..
  #endif
  ```

  

#### **14.5 Miscellaneous Directives**

\#error: 예외처리시 사용함, 전처리기가 #error를 만나면 #error의 값을 출력하고 종료 #line: `__line__`과 같이 사용, 전처리기가 #line을 만나면 그 다음 줄 번호는 #line의 값으로 초기화 됨 

#line

#pragma: 컴파일러가 특정한 동작을 하도록 요청함.



#### QnA

```
q: 한 행에 #만 쓰여 있는 것도 가능?  
a: 가능, null directive임. 지시어 영역을 한눈에 알아보기 편하게 해줌.

q: 어떤 상수를 매크로로 사용 할지 모르겠다. 가이드라인 있음?
a: 0, 1 빼고 모든 숫자 상수를 매크로로 써라  
   문자, 문자열은 문제의 여지가 있는데, 이것들은 매크로로 쓴다고 항상 가독성이 올라가지가 않음.
   내가 제안하는건 
   1. 상수가 한 번 이상 사용되면
   2. 상수가 수정될 수도 있을거 같으면 정도다. 
   
q: #연산자로 stringize한다고 했는데, 인자가 `"` 나 `\` 이면 어떻게 되냐
a: `"`는 `\"`로 `\`는 `\\`로 바뀐다.
```



### 15. Writing Large Programs

#### 15.1 Source Files

- 프로그램은 여러개의 소스파일로 쪼개져 저장 될 수 있다.



#### 15.2 Header Files

- **include directive**

    1. \#include \<filename>  주로 c 표준 라이브러리를 가져올 때 사용 시스템 헤더 폴더 (UNIX의 경우 /usr/include/)에서 가져옴

    2. \#include "filename" 현재 폴더에서 가져옴, 현재 폴더에서 못찾을 경우 시스템 헤더 폴더를 탐색

       ```c
       # include "\cprogs\include\utils.h" /* 비추천 */
       # include "..\include\utils.h" // 추천
       ```

       절대경로 보단 상대 경로를 추천. preprocessor가 오류가 날수 있기 때문.

       ```c
       //유닉스 경로  '/'
       #include "/cprogs/utils.h"
       //윈도우 경로 '\'  (escape sequence가 될 수 있으니 주의)
       #include "c:\cprogs\utils.h"
       ```





    3. #include tokens
    
       매크로를 이용해서 맞는 헤더파일을 인클루드 할 수 있음
    
       ```c
       #if defined(IA32)
        #define CPU_FILE "ia32.h"
       #elif defined(IA64)
        #define CPU_FILE "ia64.h"
       #elif defined(AMD64)
        #define CPU_FILE "amd64.h"
       #endif
    
       #include CPU_FILE
       ```




- **sharing macro definitions and type definitions**

    ```c
    #define BOOL int
    #define TRUE 1
    #define FALSE 0
    ```

    macro와 type을 정의한 헤더파일을 만드는 것은 편하다

    - 소스파일마다 type과 macro를 정의하는 시간을 아낄 수 있다.
    - type과 macro를 수정하기에 유용하다.  헤더파일 하나만 바꾸면 되기 때문
    - 어떤 macro나 type에 대해 서로 다른 소스파일에서 다르게 정의하는 것을 막을 수 있다.

- **sharing Function Prototypes**

    헤더파일에서 선언된 함수 프로토타입을 각기 다른 파일에서 공유 가능.

    stack.h에서 함수를 선언한다.

    calc.c에서는 함수를 호출하고, stack.c에서는 함수를 정의함.

    함수를 호출할 때, 함수의 선언(프로토타입)이 앞서 있어야하기 때문에, calc.c는 stack.h를 인클루드하고, 정의는 stack.에서 해도 서로 연동된다.

    <img src="https://i.imgur.com/W3ZA4HW.png" alt="img" style="zoom: 80%;" />

    

- **sharing  variable Declarations**

    보통 변수를 선언할 때 정의(공간의 할당)도 같이 이루어지게 된다.
    
    정의 없이 (새로운 공간의 할당 없이) 변수를 선언하는 방법은 extern 키워드를 선언 앞에 쓰는 것이다. 이것은 선언한 변수가 프로그램의 어딘가에 정의 되어 있다는 것을 의미해준다.
    
    ```c
    extern int i;
    ```
    
    extern을 이용하여 배열을 선언하게 될 때는 배여르이 길이를 생략할 수 있다.
    
    ```c
    extern int a[];
    ```
    
    만약 i라는 변수를 여러 파일에서 사용하고 싶으면, 먼저 한 파일에서 i의 정의와 선언을 하고, 다른 파일에서는 extern을 이용해 선언만 해준다.
    
    
    
    컴파일러는 extern 과 원래 변수의 타입을 체크하지 않기 때문에, 아래의 경우 컴파일 에러가 나지는 않지만, 예상치 못한 결과가 나올 수 있다.
    
    > 'file 1'
    >
    > int i;
    
    > 'file2'
    >
    > extern long i;



- **Nested Includes**

  만약 1.h 을 2.h에서 include 했을 때, 3.c에 2.h를 include하면 3.c에서 1.h와 2.h를 모두 접근 가능하다.



- **protecting header files**

<img src="https://i.imgur.com/wp5G09a.png" alt="img" style="zoom:80%;" />

​	위의 경우, prog.c에서는 file3.h가 중복해서 include 된다.

​	헤더파일이 중복으로 컴파일 되는것을 막기위해 #ifndef 를 사용한다.

```c
#ifndef BOOLEAN_H   // BOOLEAN_H 매크로가 정의가 안되어 있으면
#define BOOLEAN_H  // 정의해라

#define TRUE 1
#define FALSE 0
typedef int Bool;

#endif
```



이렇게하면 중복으로 매크로가 정의되는 것을 막을 수 있다.



- **#error directives**



```c
#ifndef __STDC__
#error THIS header require standart c compiler
#endif
```



헤더파일이 비표준 컴파일러와 함께 사용되지 않도록 #ifndef directive와 함께 **STDC** 정의 여부를 따짐

#### 

#### 15.3 dividing a Program into Files



#### 15.4 Building a Multiple-File Program

- 컴파일링

- 링킹

- **Makefiles**

- **Errors During Linking**

- **Rebuilding a Program**

- **Defining Macros Outside a Program**

  gcc 는 -D 옵션으로 macro를 정의할수 있다.

  ```c
  gcc -DDEBUG=1 foo.c
  ```

  



#### QNA



1. 왜 소스파일마다 헤더파일을 만들어야하나? 그냥 큰 하나의 헤더파일 만들면 안되나? 헤더파일을 하나만 만들면 편집하기 쉽다는 장점이 있지만, 다른 프로그래머가 읽을 때 불편하다.



### 16. Structures, Unions, and Enumerations

- structure(구조체)는 변수(멤버)의 집합이다. 

- union은 structure와 비슷하지만, 유니온의 멤버들은 같은 저장 공간을 공유한다. 즉, 한번에 하나의 멤버만 저장할 수 있다. 동시에 모든 멤버들을 저장할 수 없다.
- enumeration은 정수형 타입으로 값들은 프로그래머가 값들에 이름을 지정해준다.

#### 16.1 Structure Variables

- 데이터의 집합을 다루는 방법 중 배열을 사용하기 위해서는2가지 조건이 있다.
  1. 모든 데이터가 같은 타입
  2. 하나의 element에 접근하기 위해서는 위치를 알아야 한다.

- structure는 배열과 차이가 있다. 구조체의 변수(멤버)는 타입이 달라도 되고, 이름으로 접근하기 때문에 위치를 기억하지 않아도 된다.

- **structure 변수 선언**

  ```c
  struct { 
  	int number;
      char name[NAME_LEN+1];
      int on_hand;
  } part1, part2  ;
  ```

  part1, part2는 각각 struct 타입의 변수이다. 각각의 struct 변수는 3개의 멤버를 가지고 각각의 멤버는 이름을 가지고 있다. 

  만약 part1이 2000번 주소에 있다면 아래 처럼 순서대로 메모리에 저장된다.

  <img src="https://i.imgur.com/ZDxrpjx.png" alt="img" style="zoom: 67%;" />

- 선언시에 struct { ... } ...; 내부에서만 scope를 가지기 때문에, 한 struct에서 사용된 멤버 이름을 struct 외부에서 선언하여 사용 할 수 있다.

  ```c
  struct { 
  	int number;
      char name[NAME_LEN+1];
      int on_hand;
  } part1, part2  ;
  
  struct { 
      char name[NAME_LEN+1];
      int number;
  } emp1, emp2  ;
  
  int on_hand;
  ```

- **구조체 변수의 초기화**

  구조체 변수에 선언된 멤버 변수 순서대로 각각의 값을 {}안에 넣어 할당하면 선언과 동시에 초기화 할 수 있다.

  ```c
  struct { 
  	int number;
      char name[NAME_LEN+1];
      int on_hand;
  } part1 = {528, "Disk drive", 10}
    part2 = {914, "Printer cable", 5};
  ```

  배열과 마찬가지로, 모든 값을 초기화 하지 않을 수 있다. 그때 초기화되지 않은 멤버들에게는 0이 할당 된다.

  변수를 할당( `part1 = { i , "Disk drive", 10}`)하는 것은 원래 불가능했지만 c99부터는 가능

  **c99 **아래와 같이 멤버 이름을 이용하여 할당도 가능하다. (designated initalizer) 아래의 경우 할당하는 순서는 바뀌어도 상관 없다. 멤버의 이름은 **designator** 라고 불린다.

  ```c
  struct { 
  	int number;
      char name[NAME_LEN+1];
      int on_hand;
  } part1 = {.number = 528, .name = "Disk drive", .on_hand = 10};
  ```

- **구조체 연산**

  이름을 이용해 각 멤버에 접근 가능 (구조체 변수명.멤버 변수명)  예) `part.number`

  ```c
  printf("%d\n", part1.number);
  printf("%s\n", part1.name);
  printf("%d\n", part1.on_hand);
  
  part1.number++;
  part1.number = 258;
  
  scanf("%d", &part1.number);
  ```

  같은 타입의 구조체 끼리 할당 연산도 가능하다.

  ```c
  part2 = part1
  ```

  이렇게 하면, part1의 모든 멤버값이 part2의 멤버 같에 대입된다.

  이 특성은, 배열을 복사 할 때 편하게 사용할 수 있다.

  ```c
  struct { int a[ 10 ]; } a1, a2;
  ...
  a1 = a2;
  ```

  **할당연산을 제외하고 구조체 변수끼리 다른 연산은 불가능하다.**



#### 16.2 구조체 타입

- 동일한 구조의 스트럭쳐를 여러번 다른 곳에서 선언해야 할 경우 아래 코드처럼한다면, 코드가 복잡해지고 수정하기도 힘들다.  그리고 part1에 part2를 할당하는 일도 불가능하다. 또한, 구조체의 이름이 없기 때문에 함수를 호출 할 때 part1과 part2를 아규먼트로 사용할 수 없다.

  ```c
  struct { 
  	int number;
      char name[NAME_LEN+1];
      int on_hand;
  } part1;
  
  ...
  
  struct { 
  	int number;
      char name[NAME_LEN+1];
      int on_hand;
  } part;
  ```

  위와 같은 문제를 피하는 방법은 structure의 타입에 이름을 지정해 주는 것이다. structure 타입의 이름을 지정해주는 방법은 두가지가 있다. 한 가지 방법은 Structure Tag를 사용하는 것이고 다른 하나는 typedef를 이용하는 방법이다. 

- **Declaring a Structure Tag**

  ```c
  struct Part{
      nt number;
      char name[NAME_LEN+1];
      int on_hand;
  };
  ```

  위와 같이 structure의 타입에 part라는 이름을 붙일 수 있다. 마지막에 있는 ' ; ' 는 필수이다. 

  한번 tag를 만들면, tag이름을 이용하여 구조체 변수를 선언할 수 있다.

  ```c
  struct Part{
      nt number;
      char name[NAME_LEN+1];
      int on_hand;
  };
  ...
  struct Part part1, part2;
  Part part1, part2;  // WRONG  참고로 C++에서는 가능
  ```

  part 태그는  타입이 아니다. struct 없이는 아무의미가 없다. 

  structure 변수와 tag를 동시에 선언 할 수도 있다.

  ```c
  struct Part{
      nt number;
      char name[NAME_LEN+1];
      int on_hand;
  } part1, part2;
  ```

  

- **Defining a Structure Type**

  ```c
  typedef struct {
      nt number;
      char name[NAME_LEN+1];
      int on_hand;
  } Part;
  ...
  
  Part part1, part2;
  ```

  typedef는 struct Part를 사용할 수 없고, tag는 사용할 수 있다. 

  linked list를 사용 할 때에는 tag를 사용해야 한다.



- **Structures as Agruments and Retrun Values**

  함수 호출

  ```c
  void print_part (struct part p)
  {
       printf("part number: %d\n", p.number);
       printf("part name: %s\n", p.name);
       printf("Quantity on hand: %d\n", p.on_hand);
  }
  
  ....
  
  print_part(part1);
  ```

  리턴 값

  ```c
  struct part build_part (int numver, const char *name, int on_hand)
  {
      struct part p;
      strcpy(p.name, name);
      p.on_hand = on_hand;
      return p;
  }
  
  ...
      
  part1 = build_part(528, "Disk drive", 10);
  ```

  구조체를 리턴하거나 파라미터로 전달 할 때 모든 멤버를 copy하게 된다. 만약 구조체가 크다면, 복사를 하기 때문에 시간이 오래 걸릴 것이다. 

  모든 멤버의 값을 복사하는 것을 피하기 위해서 포인터를 활용 할 수 있다. (17.5에서 다룰 예정)

- FILE structure

  <stdio.h> 에 FILE 구조체가 포함되어 있고 FILE 구조체는 open file의 상태를 저장한다. 그렇기 때문에 FILE 구조체는 unique 해야한다. 그리고, open file에서 수행되는 모든 함수는 FILE구조체를 포인터 타입의 아규먼트가 사용되어 호출 된다.

- ```c
  void f(struct part part1)
  {
      struct part part2 = part1;
      ...
  }
  ```

  함수안에 위와 같이 초기화도 가능하다.

- C99 Compound Literals

  1. 함수르르 호출 할 때 아규먼트로 사용 가능

  ```c
  print_part((struct part) {528, "Disk drive", 10});
  
  //또는
  
  print_part((struct part) {.on_hand = 10,
                            .name = "Disk drive", 
                            .number = 528});
  ```
  
  2. 구조체를 초기화 할 때
  
  ```c
  part1 = (struct part) {528, "Disk drive", 10};
  ```
  
  위의 예제는 tag를 사용 했을 경우이다.
  
  만약, typedef를 사용했다면 struct를 사용하지 않고 (part)를 이용해서 사용할 수 있다.

  

#### 16.3 Nested Arrays and Structures

- 배열과 구조체는 서로 제한없이 결합하여 사용할 수 있다. 배열을 구조체의 멤버로 가지는 것과 구조체를 배열로 사용하는 것 모두 가능하다.

- **Nested Structure**

  ```c
  struct person_name {
      char first [First_NAME_LEN+1];
      char middle_initial;
      char last [LAST_NAME_LEN+1];
  };
  
  ...
  
  //구조체 내부에 구조체를 멤버로 가질 수 있다.
  struct student {
      struct person_name name;
      int id, age;
      char sex;
  } student1, student2;
  
  ...
  
  strcpy (student1.name.first, "Fred");
  
  //구조체를 내부 멤버로 가질 때 유용한 점은, 구조체를 한번에 처리 할 수 있다는 것이다. 예를 들면 함수를 호출 할 경우 아래와 같이 표현 가능하다.
  diplay_name(student1.name);
  
  //비슷하게 할당도 가능하다.
  struct person_name new_name;
  ...
  student1.name = new_name;
  ```

- **Arrays of Structures**

  ```c
  //구조체 배열 선언
  struct part inventory[100];
  ...
  //함수의 아규먼트로 사용
  print_part(inventory[i]);
  //멤버 연산
  inventory[i].number=883;
  ```

- **Initializing an Array of Structures**

  ```c
  struct dialing code{
      char *country;
      int code;
  };
  
  const struct dialing_code country_codes[]=
  { {"Korea", 82}, {"Germany", 49}, {"China", 55} };
  ```

  만약 const가 아닌 변수로 사용했다면, country가  포인터이기 때문에 문제가 된다.  내부 {} 는 생략해도 되지만, {}을 넣어주면 가독성이 좋다. 

-  **C99**

  ```c
  struct part inventory[100] = 
  {[0].number = 528, [0].on_hand = 10, [0].name[0]='\0'};
  ```

#### 16.4 Unions

- 구조체와 비슷하지만,  모든 멤버가 메모리에 동시에 저장될 수 없다. union의 메모리 크기는 멤버 중 가장 사이즈가 큰 멤버의 크기로 정해진다.

-  한 번에 하나의 멤버 값만 저장되기 때문에, 다른 멤버에 값을 할당하면 원래 있던 멤버의 값이 사라지고 그 위에 값을 덮어 씌운다.

- ```c
  union {
      int i ;
      double d;
  } u;
  ```

  구조체와 비슷하지만 데이터가 저장되는 형태에서 차이가 있다. 

  <img src="https://i.imgur.com/6few24H.png" alt="img" style="zoom: 80%;" />

  구조체는 12바이트, 유니온은 8바이트

  구조체는 각각의 멤버가 고유한 공간을 가지고, 유니온은 공유

  구조체는 각각의 멤버가 고유의 주소값을 가지고, 유니온은 주소가 같다

  ```c
  u.i=82;
  u.d = 74.8
  ```

  아래와 같이 초기화도 가능하다. 

  ```c
  //첫 번째 멤버인 i가 초기화 된다.
  union {
      int i;
      double d;
  } u = { 0 };
  
  // c99부터는 다른 멤버를 designated initializer를 사용하여 초기화 할 수 있다.
  union {
      int i;
      double d;
  } u = { .d =10.1 };
  ```

- **Using unions to save space**

  동시에 사용할 필요가 없는 변수들이 있을 경우

  ```c
  struct catalog_item {
      
      int stock_number;
      double price;
      int item_type;
      union {
          struct {
              char title [ TITLE_LEN + 1];
              char title [ TITLE_LEN + 1];
              int num_page;
          } book;
          struct {
              char design [DESIGN_LEN+1];
          } mug;
          struct {
              char design [DESIGN_LEN+1];
              int size;
              int colors;
          } shirts;
      } item;
  };
  
  struct catalog_item c;
      
  ...
  
  printf("%s", c.item.book.title);
  ```

   유니온 멤버에 값을 할 당 할 경우, 다른 멤버를 통해서 그 값에 접근 하는 것도 가능하다.

  ```c
  strcpy(c.item.mug.design, "Cats");
  
  printf("%s", c.item.shirts.design);  // 결과가 Cats이 나옴
  ```

  위 경우, mug멤버의 design에 cats을 할당했지만, shirts의 design과 메모리를 공유하고 같은 사이즈 이기 때문에 shirt.design을 출력하면 cats이 나온다.



- **Build Mixed Data Structures**

  ```c
  typedef union {
      int i;
      double d;
  } Number;
  
  Number number_arry[1000];
  
  number_arry[0].i=5;
  number_arry[1].i=8.395;
  ```

  위와 같이 각각 원소의 타입이 다른 배열로 활용 가능하다.

  아래와 같이 각각의 원소 타입에 따라 원소를 처리할 수 있다.

  ```c
  //불가능한 방법
  typedef union {
      int i;
      double d;
  } Number;
  
  void print_number (Number n){
      if (n contains an integer)  // 구분할 방법이 없다.
          printf("&d", n.i);
      else
          printf("%g", n.d);
  }
  
  // tag field 사용
  #define INT_KIND 0
  #define DOUBLE_KIND 1
  
  typedef struct {
      int kind;   /*tag field*/
      union {s
          int i;
          double d;
      } u;
  }Number;
  
  void print_number (Number n){
      if (n.kind == INT_KIND )
          printf("&d", n.u.i);
      else
          printf("%g", n.u.d);
  }
  ```

  

#### 16.5 Enumerations

- 의미 있는 작은 집합의 값들을 표현할 때 Enumeration이 유용하다.

  - ture / false
  - clubs / diamonds / hearts / spades

- 매크로를 이용할 수 있지만, 매크로는 같은 타입인지를 나타내지 않는다. 

- 또한, 매크로는 값으로 대치되기 때문에 디버깅시에  불편하다

- enum

  ```c
  enum {CLUBS, DIAMONDS, HEARTS, SPADES} s1,s2;
  ```

  각 멤버는 상수이고 s1,s2는 변수이다. enum은 함수내부에서 정의 되었으면, 그함수 내부에서만 사용 할 수 있다.

- enum tag

  ```c
  enum suit {CLUBS, DIAMONDS, HEARTS, SPADES};
  enum suit s1, s2;
  ```

- typedef

  ```c
  typedef enum {CLUBS, DIAMONDS, HEARTS, SPADES} Suit;
  Suit s1, s2;
  ```

- enum 멤버는 정수로 처리된다. 기본적으로, C컴파일러는 0부터 순차적으로 각 멤버에 값을 할당한다. (0, 1, 2, 3, ...)

  suit는 CLUBS == 0, DIAMONDS ==1, HEARTS ==2, SPADES ==3 으로 매칭된다.

- ```c
  enum suit {CLUBS=1, DIAMONDS=2, HEARTS=3, SPADES=4};
  enum dept {RESEARCH =20, PRODUCTION = 10, SALES =25};
  ```

  위와 같이 값을 직접 할당하는 것도 가능하다. 

- 두 개 이상의 멤버에 같은 값을 할당하는 것도 가능

- 값을 지정해 주지 않을 경우, 직전 멤버의 값보다 1큰 값이 할당 된다.

  ```C
  enum color {BLACK, GRAY = 7, RED, WHITE = 15};
  //각각 0, 7, 8, 15
  ```

- 활용

  ```c
  int i ;
  enum {CLUBS, DIAMONDS, HEARTS, SPADES} s;
  
  i = DIAMONDS;  //i는 1
  s = 0;    // s는 0(CLUBS)
  s++;      // s는 1(DIAMONDS)
  i = s+2;  // i는 3
  ```

  enumeration value를 쓰는 것이 편리하긴 하지만, 위험한 경우가 있다. 만약에 s=4; 라고 할 경우 s안에 4에 매칭되는 값이 없다.

- ```c
  typedef struct{
      enum {InT_KIN, DOUBLE_KIND} kind;
      union {
          int i;
          double d;
      } u;
  } Number ;
  ```

  매크로를 사용하지 않고, 타입이 다른 배열을 사용 하는 방법, 이 방법이 매크로보다 더 명확하게 타입을 보여준다.

#### Q&A

- sizeof 함수를 썼을 때 멤버의 전체 사이즈를 더한 것보다 큰 결과가 나오는 이유

  - ```c
    struct {
    	char a;
    	int b;
    }s;
    ```

    위 코드의 경우 s는 5바이트가 나와야 하지만, 몇몇 컴퓨터는 특정 숫자의 배수의 간격만큼 주소를 가진다. 이러한 요구를 만족시키기 위해 컴파일러는 구조체의 멤버들을 정렬하는데, 이때 두 멤버사이에 사용되지 않는 바이트가 존재 할 수 있다.

    만약, 데이터가 4의 배수로 시작해야 된다면, 위의 코드는 3개의 사용되지 않는 바이트를 가졌기 때문에 총 8바이트가 된다.

- 구조체를 다른 파일에서 공유하려면, 헤더파일에 구조체를 선언하고 다른파일에서 include하면 된다.
- 구조체는 ==로 왜 비교 못하는가
  
- hole이 있기 때문에
  
- compound literal도 포인터를 가질 수 있나요?
  
- 네 `print_part(&(struct part) {528, "Disk", 10});`
  
- enum 값들은 subscript로 사용될 수 있다. 