# 1. 알고리즘적 사고 : 극대값(Peak) 찾기

### **1차원의 경우**

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a    | b    | c    | d    | e    | f    | g    | h    | i    |

- 극대값(Peak)의 조건
  - 중간 요소 : b ≥ a이고 b ≥ c 이면 2번 위치가 극댓값이다. 
  - 끝 요소 : i ≥ h 이면 9번 위치가 극댓값이다.

**문제 : 극대값이 존재할 경우 그 값을 찾아라. (그리고 항상 극대값이 존재하는지 증명하라)**

| 1    | 2    | ...  | n/2 - 1 | n/2  | n/2 +1 | ...  | n-1  | n    |
| ---- | ---- | ---- | ------- | ---- | ------ | ---- | ---- | ---- |
|      |      |      |         |      |        |      |      |      |

- 풀이 방법 1 : 왼쪽부터 순차적으로 확인
  - 최악의 경우 **O(n)**의 복잡도를 가진다.
- 풀이 방법 2 : 가운데 값부터 가운데 보다 큰 쪽으로 순차적으로 탐색
  - **T(n/2)**의 복잡도를 가진다.
- 풀이 방법 3 : 이진검색을 통해 분할 정복 방식으로, 가운데 값을 선택하고 좌우 값을 비교하여 가운데 값 보다 큰쪽 방향을 선택한다.
  - 최악의 경우 **O(log2(n))**의 복잡도를 가진다.
  - a[n/2] < a[n/2 - 1] 이면 왼쪽 절반인 1부터 n/2-1까지 보고 극댓값을 찾는다. 
  - 그게 아니고 a[n/2] < a[n/2 + 1] 이면 오른쪽 절반인 n/2 + 1부터 n까지 보고 극댓값을
    찾는다. 
  - 그것도 아니면 n/2 위치가 극댓값이다: 왜일까?
    - a[n/2] ≥ a[n/2 − 1] 
    - a[n/2] ≥ a[n/2 + 1]

### 2차원의 경우

**세로 : n rows / 가로 : m columns**

|      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- |
|      | c    |      |      |      |
| b    | a    | d    |      |      |
|      | e    |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |

- 극대값 조건
  - a ≥ b, a ≥ d, a ≥ c, a ≥ e이면 a는 2차원 극댓값이다.

**문제 : 극대값이 존재할 경우 그 값을 찾아라. (그리고 항상 극대값이 존재하는지 증명하라)**

- 풀이 1 : 탐욕 상승 알고리즘 

  - O(2n) 복잡도를 가짐 (n*m을 다 탐색해야 하고 n=m인 경우)

  ![img](https://i.imgur.com/kj8on3G.png)

- 풀이 2 

  - 중앙 열 j = 2/m 선택한다.

  - j열에서 **최대** 값인 (i, j)를 찾는다.

  - (i, j − 1), (i, j), (i, j + 1)를 비교한다.

  - (i, j − 1) > (i, j)이면 왼쪽 열을 선택한다. 

  - 오른쪽도 똑같이 진행한다. 

  - 두 조건 모두 만족하지 않으면, (i, j)가 2차원 극댓값이다 ← 왜일까? 

  - 열 개수가 절반으로 줄어든 새로운 문제를 푼다. 

  - 열이 1개 남으면, 최댓값을 찾고 끝난다.

  - 결국, 마지막엔 peak를 찾지 못한다면 결국 전체 배열의 최대값까지 탐색하게 되므로 결국 피크를 찾게 된다. 

    ![img](https://i.imgur.com/gpt6KFy.png)

  - 복잡도
    - n개의 행과 m개의 열이 있는 문제를 해결하기 위해 요구되는 일의 양을 T (n, m)라고 하면,
    - T(n,m) = T(n, m/2) + O(n) // O(n)은 최대값을 찾는 작업
    - T(n,m) = O(n) + ... +  O(n)  = O(n log m)
    - if(n=m) : T(n,m) = O( n log n)

# 2. 정렬 & 트리: 이벤트 시뮬레이션 



# 3. 해싱: 게놈 비교



# 4. 수: RSA 암호 



# 5. 그래프: 루빅 큐브



# 6. 최단 경로: Caltech → MIT 



# 7. 동적 프로그래밍: 이미지 압축 



# 8. 심화 주제

