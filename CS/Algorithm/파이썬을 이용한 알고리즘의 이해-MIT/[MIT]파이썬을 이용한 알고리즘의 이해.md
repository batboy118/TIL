# 1. 알고리즘적 사고

## 극대값(Peak) 찾기

### **1차원의 경우**

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a    | b    | c    | d    | e    | f    | g    | h    | i    |

- 극대값(Peak)의 조건
  - 중간 요소 : b ≥ a이고 b ≥ c 이면 2번 위치가 극댓값이다. 
  - 끝 요소 : i ≥ h 이면 9번 위치가 극댓값이다.

**문제 : 극대값이 존재할 경우 그 값을 찾아라. (그리고 항상 극대값이 존재하는지 증명하라)**

| 1    | 2    | ...  | n/2 - 1 | n/2  | n/2 +1 | ...  | n-1  | n    |
| ---- | ---- | ---- | ------- | ---- | ------ | ---- | ---- | ---- |
|      |      |      |         |      |        |      |      |      |

- 풀이 방법 1 : 왼쪽부터 순차적으로 확인
  - 최악의 경우 **O(n)**의 복잡도를 가진다.
- 풀이 방법 2 : 가운데 값부터 가운데 보다 큰 쪽으로 순차적으로 탐색
  - **T(n/2)**의 복잡도를 가진다.
- 풀이 방법 3 : 이진검색을 통해 분할 정복 방식으로, 가운데 값을 선택하고 좌우 값을 비교하여 가운데 값 보다 큰쪽 방향을 선택한다.
  - 최악의 경우 **O(log2(n))**의 복잡도를 가진다.
  - a[n/2] < a[n/2 - 1] 이면 왼쪽 절반인 1부터 n/2-1까지 보고 극댓값을 찾는다. 
  - 그게 아니고 a[n/2] < a[n/2 + 1] 이면 오른쪽 절반인 n/2 + 1부터 n까지 보고 극댓값을
    찾는다. 
  - 그것도 아니면 n/2 위치가 극댓값이다: 왜일까?
    - a[n/2] ≥ a[n/2 − 1] 
    - a[n/2] ≥ a[n/2 + 1]

### 2차원의 경우

**세로 : n rows / 가로 : m columns**

|      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- |
|      | c    |      |      |      |
| b    | a    | d    |      |      |
|      | e    |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |

- 극대값 조건
  - a ≥ b, a ≥ d, a ≥ c, a ≥ e이면 a는 2차원 극댓값이다.

**문제 : 극대값이 존재할 경우 그 값을 찾아라. (그리고 항상 극대값이 존재하는지 증명하라)**

- 풀이 1 : 탐욕 상승 알고리즘 

  - O(2n) 복잡도를 가짐 (n*m을 다 탐색해야 하고 n=m인 경우)

  ![img](https://i.imgur.com/kj8on3G.png)

- 풀이 2 

  - 중앙 열 j = 2/m 선택한다.

  - j열에서 **최대** 값인 (i, j)를 찾는다.

  - (i, j − 1), (i, j), (i, j + 1)를 비교한다.

  - (i, j − 1) > (i, j)이면 왼쪽 열을 선택한다. 

  - 오른쪽도 똑같이 진행한다. 

  - 두 조건 모두 만족하지 않으면, (i, j)가 2차원 극댓값이다 ← 왜일까? 

  - 열 개수가 절반으로 줄어든 새로운 문제를 푼다. 

  - 열이 1개 남으면, 최댓값을 찾고 끝난다.

  - 결국, 마지막엔 peak를 찾지 못한다면 결국 전체 배열의 최대값까지 탐색하게 되므로 결국 피크를 찾게 된다. 

    ![img](https://i.imgur.com/gpt6KFy.png)

  - 복잡도
    - n개의 행과 m개의 열이 있는 문제를 해결하기 위해 요구되는 일의 양을 T (n, m)라고 하면,
    - T(n,m) = T(n, m/2) + O(n) // O(n)은 최대값을 찾는 작업
    - T(n,m) = O(n) + ... +  O(n)  = O(n log m)
    - if(n=m) : T(n,m) = O( n log n)

## 계산 모델

### 알고리즘이란?

컴퓨터 프로그램의 수학적 추상화

문제 해결을 위한 계산 과정

![img](https://i.imgur.com/XP0gH8l.png)

### 계산 모델(model of computation) 이 규정하는 것 

- 알고리즘이 할 수 있는 연산 
- 각 연산의 비용 (시간, 공간, …) 
- 알고리즘의 비용 = 연산 비용의 합
  - 알고리즘의 시간 비용의 합 = 알고리즘의 실행 시간



### 임의 접근 머신 (Random Access Machine) 

- 거대한 배열로 만들어진 임의 접근 머신 (RAM) 

- 레지스터 (각 1개의 워드)

- Θ(1) 시간 안에 할 수 있는 일 
  - 레지스터에 접근
  - 레지스터 i에 있는 워드를 레지스터 j로 불러오기
  - 레지스터에서 (+, −, ∗, /, &, |, ˆ) 계산 
  - 레지스터 i를 j에 있는 메모리에 저장
- 워드란? w bit를 의미 : w ≥ log 2 (memory size) bit / 워드가 모든 메모리를 인덱싱 할 수 있어야 하기 때문에.
  - 기본적인 객체(e.g., 정수)가 워드에 들어맞는다고 가정한다 
  - 엄청나게 큰수의 연산은 어떻게 할까? (워드 단위를 넘어서는) : 4단원에서 큰 수를 다룸
- 현실적이고 강력함 → 추상적 개념 구현



### 포인터 머신 (Pointer Machine) 

- 동적 할당된 객체 (ex, 튜플)

- 객체 는 O(1)개의 필드를 갖는다. 
- 필드는 워드 (e.g., 정수)가 될수 있고, 또는 객체/널을 가리키는 포인터 ( a.k.a. 참조 ) 
- RAM보다 약하다 (RAM으로 구현 가능)



### 파이썬 모델(Python Model)

- 파이썬은 Random Access Machine과 Pointer Machine을 둘다 적용 할 수 있다. 배열을 가지고 있기 때문에  Random Access Machine 관점으로 사용이 가능하고, 레퍼런스를 가지고 있기 때문에 Pointer Machine의 관점으로도 사용 가능하다. 

  1. 파이썬에서 “리스트”는 사실 배열이다. → RAM 

     L[i] = L[j]+5 → Θ(1) 시간

  2. O(1)개의 속성( 참조 포함 )을 가진 객체 → 포인터 머신 

     x = x.next → Θ(1) 시간

- 파이썬에는 많은 연산이 있다. 각 연산의 비용을 알아보려면, 위의 (1)이나 (2)로 구현해보면 된다.

  L : list

  (a) L.append(x) : O(1) 시간

  (b) L = L1+L2 (두개의 리스트를 합쳐서 L에 넣는 연산)

  (c) 리스트에 특정한 값이 있는지 확인 하는 연산 : O(n)

  (d) 리스트의 길이를 찾는 연산 : O(1) / 리스트의 길이가 내장되어 있기 때문에

  (e) 리스트의 sort : O(0nlogn)

- tuple, str : 값이 변하지 않는 list라고 생각하면 된다.

- dict : 해시테이블을 사용
  
- D[key]=val   / O(1)
  
- set : 값이 없는 dict라고 생각하면 된다.
- heapq
- long



### Document Distance Problem ( 문서의 유사성을 검사하는 문제 )

d( D1, D2 ) 계산

문서 거리 문제는 **유사한 문서** 탐색이나 **중복(위키피디아 미러 사이트와 구글)과 표절** 발견, 그리고 **웹 검색**에 적용된다.

**정의**

- 단어 = 영어와 숫자로 이루어진 문자열
- 문서 = 단어의 나열 (공백, 문장 부호 등 무시)

공통으로 갖는 단어를 통해 거리를 정의하고자 한다. 문서 D를 벡터 로 생각한다. : D[w] = 단어 W 의 등장 횟수.



## 정렬 : 삽입 정렬과 합볍 정렬

### **정렬의 예**

**입력**: 숫자 배열 A[1…n]

**출력**: A 의 순서 배열 B[1…n] 

​	예시: B[1] ≤ B[2] ≤ … ≤ B[n] .

**예시**: A = [7, 2, 5, 5, 9.6] → B = [2, 5, 5, 7, 9.6]

### 

### 왜 정렬을 사용해야 할까?

확실한 응용 사례 

-  MP3 보관함 정렬
- 전화번호부 정리

일단 정렬되면 쉬워지는 문제들

- 중간값 또는 가장 가까운 쌍 찾기
- 이진 탐색, 통계적 이상치 확인

생소한 응용 사례

- 데이터 압축: 정렬로 중복된 부분 검출
- 컴퓨터 그래픽: 앞에서 뒤로 화면 렌더링



### 삽입 정렬

### 합병 정렬



## 힙 & 힙 정렬

### 우선순위 큐

- 요소들의 집합 S를 구현하는 자료구조

  - 선입 선출의 구조가 아닌 **우선순위가 높은 순서**대로 큐에서 나가는 자료 구조

    ⇒ 시물레이션, 네트워크 트래픽 제어, 운영체제의 태스크 스케줄링에 사용 됨

  - 배열을 사용하여 우선순위 큐를 구현하면 삭제, 삽입 연산에서 재배치에 시간이 걸림

  - 연결리스트로 우선순위큐를 구현하더라도 비교연산이 많이 발생함

    ⇒ **Heap 자료구조로 구현하여 해결가능**

- 각 요소들은 키와 관련이 있고, 다음 작업들을 지원한다.
  - insert(S, x) : 요소 x 를 집합 S에 삽입 
  - max(S) : 최대 키인 S의 요소를 반환
  - extract_max(S) : 최대 키인 S의 요소를 반환하고 집합 S에서 제거
  - increase_key(S, x, k) : 요소 x의 키를 새로운 값 k로 증가시킴 (k가 현재 값만큼 크다고 가정)

### Heap

- 우선순위 큐로 구현됨
- 완전 이진트리로 시각화된 배열
- 최대 힙 특성 : 부모 노드의 키가 자식 노드의 키보다 크거나 같아야 한다.
  - key(부모 노드) >= key(자식 노드)
- 최소 힙 특성 : 부모 노드의 키가 자식 노드의 키보다 작아거나 같아야 한다.
  - key(부모 노드) <= key(자식 노드)

![img](https://i.imgur.com/4fBmS12.png)

- 트리의 루트는 배열의 첫번째 요소이다. (i=1)
- 자식 노드의 절반이 부모 노드의 인덱스이다.
  - i번째 요소의 부모노드를 반환하는 함수 : parent(i)    :  i/2
- 자식 노드 중 왼쪽 자식은 부모노드의 두배이다.
  - left(i)=2i : 노드의 왼쪽 자식의 인덱스를 반환
- 자식 노드 중 오른쪽 자식은 부모 노드의 두배에 1을 더한 값이다.
  - right(i)=2i+1: 노드의 오른쪽 자식의 인덱스를 반환
- 포인터가 필요 없다.
- 이진 힙의 높이는 logN이다.

### 힙에서의 연산

- max_heapify : 그 루트의 서브 트리에서 힙 특성을 위반한 걸 한 가지 고친다.

  - 서로 다른 여러개의 힙을 합쳐서 맥스힙을 만들고 싶을 때 사용
  - left(i)와 right(i) **서브 트리들이 최대-힙 이라고 가정**
  - 위에서 아래로 검사
  - 만약 요소 A[i]가 최대-힙 특성을 위반한다면, 요소 A[i]를
    트리 아래로 흘러 내려가도록 하면서 위반을 수정한다.인덱스 i의 서브 트리들을 최대-힙으로 만든다. 그리고 수정된 힙을 반환한다.
  - log(n)의 복잡도를 가진다.

  예시)

  ![img](https://i.imgur.com/CWKsHk6.png)

  노드 10은 노드 5의 왼쪽 자식이지만 편의를 위해 오른쪽에 그렸다.

  MAX_HEAPIFY(A,2) : 2번째 요소 아래가 최대힙인지 검사하고 수정한다.

  ![img](https://i.imgur.com/Gkne74K.png)

  ![img](https://i.imgur.com/FgLOvNG.png)

  - 의사 코드

    ```
    l = left(i) 
    r = right(i) 
    if (l <= heap-size(A) and A[l] > A[i]) 
    	then largest = l else largest = i
    if (r <= heap-size(A) and A[r] > A[largest]) 
    	then largest = r 
    if largest != i
    	then exchange A[i] and A[largest] 
    		Max_Heapify(A, largest)
    ```

- build_max_heap : 정렬이 안된 힙을 최대힙으로 만드는 연산

  - A[1…n]를 최대-힙으로 변환

    ```
    Build_Max_Heap(A): 
        for i=n/2 downto 1 
            do Max_Heapify(A, i)
    ```

    n/2부터 시작하는 이유?

    - n/2는 단말노드를 가지는 노드 (단말 노드의 바로 위 노드) 중 가장 끝에 위치한 노드이다. 즉, n/2의 좌우 서브 트리는 max-heap이고, n/2보다 큰 노드는 서브 트리가 존재하지 않기 때문에, 2/n부터 노드 index 줄여 나가면서 Max-Heapify를 호출 하면 전체가 최대 힙이 된다. 
      - 2/n+1 ~ n 번째 노드들은 모두 단말 노드이다.
      - i >= n/2 + 1 이면 2i > n가 되기 때문에 서브 트리가 존재 하지 않을 수 있다.
  - 단말 노드는 항상 최대 힙 상태이다.
  
- Max_Heapify(A, i)가 2/n번 반복되기 때문에 O(nlogn) 복잡도를 가지는 것 처럼보이지만, 사실 분석해보면 O(n) 복잡도를 가진다.
  
    - 단말 노드 바로 위에 있는 노드들은 Max_Heapify하는 데 O(1) 시간이 걸린다. 일반적으로 단말 노드보다 L단계 위에 있는 노드들은 O(L) 시간이 걸린다. 
    
    - 1단계에서 n/4 노드들을 가지고, 2단계에서 n/8을 가지고, 한 개의 루트 노드만 남을 때까지 계속 이어진다. 마지막은 단말 노드로부터 log n 단계이다.
    
    - for문에서 하는 전체 일의 양은 다음과 같이 계산된다. (C는 상수)
    
      n/4 (1 c) + n/8 (2 c) + n/16 (3 c) + … + 1 (lg n c)
    
    - n/4 = 2^k 라고 가정하면 간단하게 바꿀 수 있다.
    
      c 2^k( 1/2^0 + 2/2^1 + 3/2^2 + … (k+1)/2^k )
    
      => 괄호 안의 항은 상수로 수렴. 즉, 2^k만 남고, 2^k는 n/4가 된다.
    
    - 즉, Build_Max_Heap 의 복잡도는 **O(n)**이다.
    
    ![img](https://i.imgur.com/CcXJ6CG.png)
  
  - Max-Heap 예시
  
    ![img](https://i.imgur.com/4PNxCrF.png)
  
    ![img](https://i.imgur.com/4PNxCrF.png)
  
    <img src="https://i.imgur.com/4YFTBKR.png" alt="img" style="zoom:67%;" />

### 힙 정렬

- 정렬 전략 :

  1. 정렬안된 배열에서 최대-힙을 만든다.(build_max_heap)

  2. 최대 요소 A[1] 을 찾는다.

  3. 요소 A[n]\(마지막 요소)와 A[1]을 스왑한다. 

     이제 최대 요소는 배열의 끝에 위치한다! 

  4. 힙 크기를 줄이는 방법을 통해서 힙에서 n번 째 노드를 제거한다. 

     힙의 크기는 n에서 n-1이 됨

  5. 스왑 후의 새로운 루트는 아마 최대-힙 특성을 위반할 것이다.
    하지만 그 자식 값들이 최대-힙이다. max_heapify로 이걸 해결한다.

  6. 정렬이 완료될 때 까지(힙의 원소가 다사라질 때 까지) 다시 2단계로 돌아가 작업을 반복한다.

- 힙 정렬의 시간 복잡도는 O(n log n)이다.

  - 1번
    - build_max_heap에서 O(n)
  - 2~6번
    - 최대 요소를 찾는 작업 O(1)
    - 스왑 O(1)
    - max_heapify에서 O(log n)
  - 1번 한 번, 2~6번을 n번 수행하면
    - O(n)+O(n log n) => O(n log n) 

- 예시 :

  ![img](https://i.imgur.com/vD51WyJ.png)

  ![img](https://i.imgur.com/4YFSeIv.png)![img](https://i.imgur.com/rRDf4xm.png)

  ![img](https://i.imgur.com/w4yJ19v.png)

  

# 2. 정렬 & 트리: 이벤트 시뮬레이션 



# 3. 해싱: 게놈 비교



# 4. 수: RSA 암호 



# 5. 그래프: 루빅 큐브



# 6. 최단 경로: Caltech → MIT 



# 7. 동적 프로그래밍: 이미지 압축 



# 8. 심화 주제

