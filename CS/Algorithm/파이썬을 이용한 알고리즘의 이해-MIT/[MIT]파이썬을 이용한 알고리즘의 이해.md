# 1. 알고리즘적 사고

## 극대값(Peak) 찾기

### **1차원의 경우**

| 1    | 2    | 3    | 4    | 5    | 6    | 7    | 8    | 9    |
| ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- | ---- |
| a    | b    | c    | d    | e    | f    | g    | h    | i    |

- 극대값(Peak)의 조건
  - 중간 요소 : b ≥ a이고 b ≥ c 이면 2번 위치가 극댓값이다. 
  - 끝 요소 : i ≥ h 이면 9번 위치가 극댓값이다.

**문제 : 극대값이 존재할 경우 그 값을 찾아라. (그리고 항상 극대값이 존재하는지 증명하라)**

| 1    | 2    | ...  | n/2 - 1 | n/2  | n/2 +1 | ...  | n-1  | n    |
| ---- | ---- | ---- | ------- | ---- | ------ | ---- | ---- | ---- |
|      |      |      |         |      |        |      |      |      |

- 풀이 방법 1 : 왼쪽부터 순차적으로 확인
  - 최악의 경우 **O(n)**의 복잡도를 가진다.
- 풀이 방법 2 : 가운데 값부터 가운데 보다 큰 쪽으로 순차적으로 탐색
  - **T(n/2)**의 복잡도를 가진다.
- 풀이 방법 3 : 이진검색을 통해 분할 정복 방식으로, 가운데 값을 선택하고 좌우 값을 비교하여 가운데 값 보다 큰쪽 방향을 선택한다.
  - 최악의 경우 **O(log2(n))**의 복잡도를 가진다.
  - a[n/2] < a[n/2 - 1] 이면 왼쪽 절반인 1부터 n/2-1까지 보고 극댓값을 찾는다. 
  - 그게 아니고 a[n/2] < a[n/2 + 1] 이면 오른쪽 절반인 n/2 + 1부터 n까지 보고 극댓값을
    찾는다. 
  - 그것도 아니면 n/2 위치가 극댓값이다: 왜일까?
    - a[n/2] ≥ a[n/2 − 1] 
    - a[n/2] ≥ a[n/2 + 1]

### 2차원의 경우

**세로 : n rows / 가로 : m columns**

|      |      |      |      |      |
| ---- | ---- | ---- | ---- | ---- |
|      | c    |      |      |      |
| b    | a    | d    |      |      |
|      | e    |      |      |      |
|      |      |      |      |      |
|      |      |      |      |      |

- 극대값 조건
  - a ≥ b, a ≥ d, a ≥ c, a ≥ e이면 a는 2차원 극댓값이다.

**문제 : 극대값이 존재할 경우 그 값을 찾아라. (그리고 항상 극대값이 존재하는지 증명하라)**

- 풀이 1 : 탐욕 상승 알고리즘 

  - O(2n) 복잡도를 가짐 (n*m을 다 탐색해야 하고 n=m인 경우)

  ![img](https://i.imgur.com/kj8on3G.png)

- 풀이 2 

  - 중앙 열 j = 2/m 선택한다.

  - j열에서 **최대** 값인 (i, j)를 찾는다.

  - (i, j − 1), (i, j), (i, j + 1)를 비교한다.

  - (i, j − 1) > (i, j)이면 왼쪽 열을 선택한다. 

  - 오른쪽도 똑같이 진행한다. 

  - 두 조건 모두 만족하지 않으면, (i, j)가 2차원 극댓값이다 ← 왜일까? 

  - 열 개수가 절반으로 줄어든 새로운 문제를 푼다. 

  - 열이 1개 남으면, 최댓값을 찾고 끝난다.

  - 결국, 마지막엔 peak를 찾지 못한다면 결국 전체 배열의 최대값까지 탐색하게 되므로 결국 피크를 찾게 된다. 

    ![img](https://i.imgur.com/gpt6KFy.png)

  - 복잡도
    - n개의 행과 m개의 열이 있는 문제를 해결하기 위해 요구되는 일의 양을 T (n, m)라고 하면,
    - T(n,m) = T(n, m/2) + O(n) // O(n)은 최대값을 찾는 작업
    - T(n,m) = O(n) + ... +  O(n)  = O(n log m)
    - if(n=m) : T(n,m) = O( n log n)

## 계산 모델

### 알고리즘이란?

컴퓨터 프로그램의 수학적 추상화

문제 해결을 위한 계산 과정

![img](https://i.imgur.com/XP0gH8l.png)

### 계산 모델(model of computation) 이 규정하는 것 

- 알고리즘이 할 수 있는 연산 
- 각 연산의 비용 (시간, 공간, …) 
- 알고리즘의 비용 = 연산 비용의 합
  - 알고리즘의 시간 비용의 합 = 알고리즘의 실행 시간



### 임의 접근 머신 (Random Access Machine) 

- 거대한 배열로 만들어진 임의 접근 머신 (RAM) 

- 레지스터 (각 1개의 워드)

- Θ(1) 시간 안에 할 수 있는 일 
  - 레지스터에 접근
  - 레지스터 i에 있는 워드를 레지스터 j로 불러오기
  - 레지스터에서 (+, −, ∗, /, &, |, ˆ) 계산 
  - 레지스터 i를 j에 있는 메모리에 저장
- 워드란? w bit를 의미 : w ≥ log 2 (memory size) bit / 워드가 모든 메모리를 인덱싱 할 수 있어야 하기 때문에.
  - 기본적인 객체(e.g., 정수)가 워드에 들어맞는다고 가정한다 
  - 엄청나게 큰수의 연산은 어떻게 할까? (워드 단위를 넘어서는) : 4단원에서 큰 수를 다룸
- 현실적이고 강력함 → 추상적 개념 구현



### 포인터 머신 (Pointer Machine) 

- 동적 할당된 객체 (ex, 튜플)

- 객체 는 O(1)개의 필드를 갖는다. 
- 필드는 워드 (e.g., 정수)가 될수 있고, 또는 객체/널을 가리키는 포인터 ( a.k.a. 참조 ) 
- RAM보다 약하다 (RAM으로 구현 가능)



### 파이썬 모델(Python Model)

- 파이썬은 Random Access Machine과 Pointer Machine을 둘다 적용 할 수 있다. 배열을 가지고 있기 때문에  Random Access Machine 관점으로 사용이 가능하고, 레퍼런스를 가지고 있기 때문에 Pointer Machine의 관점으로도 사용 가능하다. 

  1. 파이썬에서 “리스트”는 사실 배열이다. → RAM 

     L[i] = L[j]+5 → Θ(1) 시간

  2. O(1)개의 속성( 참조 포함 )을 가진 객체 → 포인터 머신 

     x = x.next → Θ(1) 시간

- 파이썬에는 많은 연산이 있다. 각 연산의 비용을 알아보려면, 위의 (1)이나 (2)로 구현해보면 된다.

  L : list

  (a) L.append(x) : O(1) 시간

  (b) L = L1+L2 (두개의 리스트를 합쳐서 L에 넣는 연산)

  (c) 리스트에 특정한 값이 있는지 확인 하는 연산 : O(n)

  (d) 리스트의 길이를 찾는 연산 : O(1) / 리스트의 길이가 내장되어 있기 때문에

  (e) 리스트의 sort : O(0nlogn)

- tuple, str : 값이 변하지 않는 list라고 생각하면 된다.

- dict : 해시테이블을 사용
  - D[key]=val   / O(1)

- set : 값이 없는 dict라고 생각하면 된다.
- heapq
- long



### Document Distance Problem ( 문서의 유사성을 검사하는 문제 )

d( D1, D2 ) 계산

문서 거리 문제는 **유사한 문서** 탐색이나 **중복(위키피디아 미러 사이트와 구글)과 표절** 발견, 그리고 **웹 검색**에 적용된다.

**정의**

- 단어 = 영어와 숫자로 이루어진 문자열
- 문서 = 단어의 나열 (공백, 문장 부호 등 무시)

공통으로 갖는 단어를 통해 거리를 정의하고자 한다. 문서 D를 벡터 로 생각한다. : D[w] = 단어 W 의 등장 횟수.



## 정렬 : 삽입 정렬과 합볍 정렬

### **정렬의 예**

**입력**: 숫자 배열 A[1…n]

**출력**: A 의 순서 배열 B[1…n] 

​	예시: B[1] ≤ B[2] ≤ … ≤ B[n] .

**예시**: A = [7, 2, 5, 5, 9.6] → B = [2, 5, 5, 7, 9.6]

### 

### 왜 정렬을 사용해야 할까?

확실한 응용 사례 

-  MP3 보관함 정렬
- 전화번호부 정리

일단 정렬되면 쉬워지는 문제들

- 중간값 또는 가장 가까운 쌍 찾기
- 이진 탐색, 통계적 이상치 확인

생소한 응용 사례

- 데이터 압축: 정렬로 중복된 부분 검출
- 컴퓨터 그래픽: 앞에서 뒤로 화면 렌더링



### 삽입 정렬

### 합병 정렬



## 힙 & 힙 정렬

### 우선순위 큐





# 2. 정렬 & 트리: 이벤트 시뮬레이션 



# 3. 해싱: 게놈 비교



# 4. 수: RSA 암호 



# 5. 그래프: 루빅 큐브



# 6. 최단 경로: Caltech → MIT 



# 7. 동적 프로그래밍: 이미지 압축 



# 8. 심화 주제

