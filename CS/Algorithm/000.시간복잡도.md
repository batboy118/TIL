# 시간 복잡도

### 시간 복잡도

- 입력 'N'에 대하여 구현된 알고리즘이 문제를 해결하는데 얼마나 오래걸리는지 분석
- Big-O 표기법으로 시간복잡도를 정의함

### Big-O 표기법

- 알고리즘의 문제 해결에 걸리는 시간을 나타낸 식 중에서 가장 큰 차수( n이 무한대로 갈 때 영향을 가장 크게 미치는 항)만 표기하는 표기법 예시)

  ```
    Regular    Big-O
    2           O(1)    --> It's just a constant number
    2n + 10     O(n)    --> n has the largest effect
    5n^2        O(n^2)  --> n^2 has the largest effect
  ```

- 대표적인 시간 복잡도

  1. **O(1) – 상수 시간** : 입력값 n 이 주어졌을 때, n의 크기와 상관없이 알고리즘이 문제를 해결하는데 오직 한 단계만 거치는 경우
  2. **O(log n) – 로그 시간** : 입력값 n 이 주어졌을 때, 문제를 해결하는데 필요한 단계들이 연산마다 특정 요인에 의해 줄어드는 경우
  3. **O(n) – 직선적 시간** : 문제를 해결하기 위한 단계의 수와 입력값 n이 1:1 관계를 가지는 경우
  4. **O(n^2) – 2차 시간** : 문제를 해결하기 위한 단계의 수가 입력값 n의 제곱인 경우
  5. **O(C^n) – 지수 시간** : 문제를 해결하기 위한 단계의 수가 주어진 상수값 C 의 n 제곱인 경우

  예시)

  ```
    var n = 16; -- 입력값 n 이 16일 때
    O (1) = 1 step "(awesome!)" -- O(1)는 시간복잡도가 1
    O (log n) = 4 steps "(awesome!)" -- O(log n)는 시간복잡도가 4 (log 의 밑이 2라고 가정)
    O (n) = 16 steps "(pretty good!)" -- O(n)는 시간복잡도가 16
    O(n^2) = 256 steps "(uhh..?)" -- O(n^2)는 시간복잡도가 256
    O(2^n) = 65,536 steps "(...)"
  ```

- 예시 코드

  ```
    /* Case 1 */
    sum <- n * n;
    
    /* Case 2 */
    sum <- 0
    for i <- 1 to n do
        sum <- sum + n;
        
    /* Case 3 */
    sum <- 0
    for i <- 1 to n do
        for j <- 1 to n do
            sum <- sum + 1;
  ```

  위 3개의 알고리즘의 연산 횟수를 비교해보면 아래와 같이 나타낼 수 있음

  (간단하게 확인하기 위해 루프 제어 연산은 제외)

  Case 1.

  대입 연산 : 1번, 곱셉 연산 : 1번 ⇒ 총 연산 횟수 : 2

  Case 2.

  대입 연산 : n+1, 덧셈 연산 : n ⇒ 총 연산 횟수 : 2n+1

  Case 3.

  대입 연산 : n*n+1, 덧셈 연산 : n*n ⇒ 총 연산 횟수 : 2n^2+1

  하나의 연산이 t 만큼의 시간이 필요하다고 가정한다면

  **Case 1의 경우**는 2t 만큼의 시간이 필요하고

  **Case 2의 경우**는 (2n+1)t 만큼의 시간

  **Case 3의 경우**에는 (2n2+1)t 만큼의 시간이 필요

  Case 2의 Big-O 표기법으로 자세하게 살펴보면,

  ```
    sum <- 0
    for i <- 1 to n do
        sum <- sum + n;
        
    // i <- 1 : 대입 연산 1회
    // to : n + 1 번의 비교 연산(루프를 탈출하기 직전의 비교 연산 포함)
    // n : n 번의 연산
  ```

  하나의 루프 제어문은 전체적으로 보면 2n+2개의 연산을 추가하게 되어,

  루프문을 제외 했을 때의 결과인 2n+1와 루프 제어문의 연산인 2n+2가 되어 총 연산 횟수는 4n+3이 된다.

  하지만, Big-O 표기법에서는 n이 커짐으로 정비례하는 관계이기 때문에 계수4는 무시되고, 상수 3역시 무시된다. 따라서, 최종적인 Big-O 표기법으로 Case 2를 표현하면, **O(n)** 이 된다.

- Big-O 표기법의 수학적 정의와 예시

  수학적 정의, 두 개의 함수 f(n) 과 g(n) 이 주어졌을 때, 모든 n≥n0 에 대하여 |f(n)|≤c|g(n)| 을 만족하는 2개의 상수 c와 n0가 존재하면 f(n)=O(g(n)) 이다.

  f(n)=5 이면 O(n) 이다. n0=1,c=10 일 때, n≥1 에 대하여 5≤10⋅1 이 되기 때문이다.

  f(n)=3n^2+100 이면 O(n^2) 이다. n0=100,c=5 일 때 n≥100 에 대하여 3^2+100≤5n^2 이 되기 때문이다.

  Big-O 표기법 일반적인 성능

  **(빠름)               N이 32 일때**

  O(1)                 1

  O(logN)          5

  O(N)                32

  O(NlogN)        160

  O(N^2)           1,024

  O (N^3)          32,768

  . . .

  O(2^N)          4,294,967,296‬

  O(3^N)         1,853,020,188,851,841

  . . .

  O(N!)            2.6313083693369353016721801216 x 10^35‬

  **(느림)**

- 최선, 평균, 최악의 경우

  동일한 알고리즘도 입력되는 데이터에 따라 처리 시간에 큰 차이를 보일 수 있음

  예를 들어, 데이터가 무작위로 정렬되어 있는지 어떠한 규칙을 가지고 정렬되어 있는지에 따라 알고리즘의 속도는 차이를 보일 것 입니다.

  Best Case : 실행 시간이 가장 작은 최적의 상황

  Average Case : 모든 가능한 입력 상황을 고려한 평균 수행 시간을 의미

  Worst Case : 실행 시간이 가장 오래걸리는 최악의 상황

  ⇒ 평균적인 실행시간이 가장 일반적인 것 처럼 생각할 수 있지만, 모든 상황을 고려하여 알고리즘을 적용하기란 매우 어려운 일이기 때문에, 보통 **최악의 경우** 를 주로 사용함.

### 출처

https://joshuajangblog.wordpress.com/2016/09/21/time_complexity_big_o_in_easy_explanation

https://madplay.github.io/post/time-complexity-space-complexity